<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>司徒公子的博客</title>
  
  <subtitle>不忘初心，方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.todaycoder.cn/"/>
  <updated>2020-05-22T16:17:52.686Z</updated>
  <id>http://blog.todaycoder.cn/</id>
  
  <author>
    <name>司徒公子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[译] 如何编写整洁代码？从 Robert C. Martin 的“代码整洁之道”中吸取的教训</title>
    <link href="http://blog.todaycoder.cn/2020/05/23/how-to-write-clean-code-lessons-learnt-from-the-clean-code-robert-c-martin/"/>
    <id>http://blog.todaycoder.cn/2020/05/23/how-to-write-clean-code-lessons-learnt-from-the-clean-code-robert-c-martin/</id>
    <published>2020-05-22T16:11:26.000Z</published>
    <updated>2020-05-22T16:17:52.686Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200523001518.png" alt="Writing clean code — Part 1 — Generic principles - Thierry CATRAIN ..."></p><a id="more"></a><blockquote><ul><li>原文地址：<a href="https://medium.com/mindorks/how-to-write-clean-code-lessons-learnt-from-the-clean-code-robert-c-martin-9ffc7aef870c" target="_blank" rel="noopener">How to write clean code? Lessons learnt from “The Clean Code” — Robert C. Martin</a></li><li>原文作者：<a href="https://medium.com/@shubham08gupta" target="_blank" rel="noopener">Shubham Gupta</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/article/2020/how-to-write-clean-code-lessons-learnt-from-the-clean-code-robert-c-martin.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/article/2020/how-to-write-clean-code-lessons-learnt-from-the-clean-code-robert-c-martin.md</a></li><li>译者：<a href="https://github.com/todaycoder001" target="_blank" rel="noopener">司徒公子</a></li><li>校对者：<a href="https://github.com/PingHGao" target="_blank" rel="noopener">PingHGao</a>、<a href="https://github.com/niayyy-S" target="_blank" rel="noopener">niayyy-S</a></li></ul></blockquote><p>有两件事 —— 编程和良好的编程。编程是我们一直在做的事情。现在是时候关注良好的编程了。我们都知道，即使是糟糕的代码也能工作。但是写好代码，需要花费时间和资源。此外，当其他开发者试图找出你代码的运行细节，他们会嘲笑你。但是，关心你的程序永远不会太迟。</p><p>这本书给了我很多关于最佳实践和如何编写代码的知识。现在，我为自己的编程技能感到羞愧。尽管我总是努力改善我的代码，但是这本书教会我的更多。</p><p>现在，你阅读这篇博客有两种原因。第一，你是个程序员；第二，你想成为更好的程序员。很好，我们需要更好的程序员。</p><p><strong>整洁代码的特征</strong>：</p><ol><li>应该是优雅的 —— 整洁的代码读起来令人<strong>愉悦</strong>。读这种代码，就像见到手工精美的音乐盒或者设计精良的汽车一般，让你会心一笑。</li><li>整洁的代码力求集中。每个函数、每个类和每个模块都全神贯注于一件事，完全不受四周细节的干扰和污染。</li><li>整洁的代码是有意维护的 —— 有人曾花时间让它保持简单有序。他们适当地关注到了细节。他们在意过。</li><li>能通过所有的测试</li><li>没有重复代码</li><li>包括尽量少的实体，比如类、方法、函数等</li></ol><h2 id="如何编写整洁代码？"><a href="#如何编写整洁代码？" class="headerlink" title="如何编写整洁代码？"></a>如何编写整洁代码？</h2><h2 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><p>名副其实。选个好名字要花时间，但省下来的时间要比花掉的多。变量、函数或类的名称应该已经回复了所有的大问题。它该告诉你，它为什么会存在，它做什么事，它应该怎么用。如果名称需要注释来补充，那就不算是名副其实。</p><p>Eg- int d; // 消逝的时间，以日计</p><blockquote><p><strong>我们应该选择指明了计量对象和计量单位的名称。</strong></p></blockquote><p>更好的命名应该是：-int elapsedTime。（尽管书中说的是 elapsedTimeInDays，但是我仍然倾向于前者。假设运行的时间改为毫秒，我们不得不将 int 改为 long，并且用 elapsedTimeInMillis 替换 elapsedTimeInDays。我们不知道何时是个尽头。）</p><p><strong>类名</strong> —— 类名和对象名应该是名词或名词短语，如 Customer、WikiPage、Account 和 AddressParser。避免使用 Manager、Processor、Data 或 Info 这样的类名。类名不应当是动词。</p><p><strong>方法名</strong> —— 方法名应当是动词或动词短语，如 postPayment、deletePage 或者 save。属性访问器、修改器和断言应该根据其值命名，并加上 get、set 前缀。</p><p>重载构造器时，使用描述了参数的静态工厂方法名。例如，</p><p>Complex fulcrumPoint = Complex.FromRealNumber(23.0);<br>通常好于<br>Complex fulcrumPoint = new Complex(23.0);</p><p><strong>每个概念对应一个词</strong> —— 每个抽象概念选一个词，而且一以贯之。例如，使用 fetch、retrieve 和 get 来给多种类中的同种方法命名。你怎么能记得住哪个类中对应的是哪个名字呢？同样，在一堆代码中有 controller，又有 manager，还有 driver，就会令人困惑。DeviceManager 和 Protocol-Controller 之间有何根本区别？</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200506082602.png" alt=""></p><p>函数的第一规则就是要短小，第二条规则是还要更短小。这意味着 if 语句、else 语句、while 语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不仅能保持函数短小，而且，因为块内调用的函数拥有具体说明性的名称，从而增加了文档上的价值。</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>一个函数不应该有超过 3 个参数，尽可能使其少点。一个函数需要两个或者三个以上参数的时候，就说明这些参数应该封装为类了。通过创建参数对象，从而减少参数数量，看起来像是在作弊，但实则并非如此。</p><p>现在，当我说要减少函数大小的时候，你肯定在想如何减少 try-catch 的内容，因为，它使你的代码变得越来越臃肿。我的答案是只生成一个仅包含 try-catch-finally 语句的方法。将 try/catch/finally 代码块从主体部分抽离出来，另外形成函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Page page)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     deletePageAndAllReferences(page);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">    logError(e);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deletePageAndAllReferences</span><span class="params">(Page page)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    deletePage(page);</span><br><span class="line">    registry.deleteReference(page.name); </span><br><span class="line">    configKeys.deleteKey(page.name.makeKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logError</span><span class="params">(Exception e)</span> </span>&#123; </span><br><span class="line">    logger.log(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这使得逻辑变得清晰明了，函数名能更容易描述我们想要表达的。错误处理可以忽略。有了这样美妙的区隔，代码就更易于理解和修改了。</p><p><strong>错误处理就是一件事</strong> —— 函数应该只做一件事。错误处理就是一件事。如果关键字 try 在某个函数中存在，它就该是这个函数的第一个关键字，而且在 catch/finally 代码块后面也不该有其他内容。</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>如果你通过写注释来证明你的观点，那你就大错特错了。理想情况下，根本不需要注释。如果你的代码需要注释，说明你做错了。我们的代码应该阐述一切。现代编程语言是英语，我们能更加容易阐述自己的观点。正确的命名能避免注释。</p><p>与法律有关的注释除外，它们是有必要的，与法律有关的注释是指版权及著作权声明。</p><h4 id="对象和数据结构"><a href="#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h4><p>这是个复杂的话题，所以要多加留意。首先，我们要澄清对象与数据结构之间的区别。</p><blockquote><p><strong>对象把数据隐藏于抽象之后，暴露操作数据的函数。数据结构暴露其数据，没有提供有意义的函数。</strong></p></blockquote><p>这两件事完全不同，一个是关于存储 数据，另一个是关于如何操作这些数据。例如，考虑到过程式代码形状规范，Geometry 类操作三个形状类。形状类都是简单的数据结构，没有任何行为。所有行为都在 Geometry 类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> Point topLeft;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> Point topLeft; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> height; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> Point center;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Geometry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">(Object shape)</span> <span class="keyword">throws</span> NoSuchShapeException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Square) &#123; </span><br><span class="line">        Square s = (Square)shape; </span><br><span class="line">        <span class="keyword">return</span> s.side * s.side;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Rectangle) &#123;</span><br><span class="line">        Rectangle r = (Rectangle)shape; </span><br><span class="line">        <span class="keyword">return</span> r.height * r.width;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Circle) &#123;</span><br><span class="line">        Circle c = (Circle)shape;</span><br><span class="line">        <span class="keyword">return</span> PI * c.radius * c.radius;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchShapeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想想看，如果给 Geometry 类添加一个 perimeter() 函数会怎么样。那些形状类根本不会因此而受影响！另一方面，如果添加一个新形状，就得修改 Geometry 中的所有函数来处理它，再读一遍代码，注意，这两种情形也是直接对立的。</p><p>现在考虑上述场景的另一种方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Point topLeft;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> side;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> side*side;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> Point topLeft;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> height;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> height * width;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Point center;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，与之前的案例相比，我们能很轻松的添加新形状，即数据结构。而且，如果我们只需在一个 Shape 类中添加 perimeter() 方法，则我们就必须在所有 Shapes 类中实现该函数，因为 Shapes 类是一个包含 area() 和 perimeter() 方法的接口。这意味着：</p><blockquote><p><strong>数据结构便于在不改动既有数据结构的前提下添加新函数。面向对象代码（使用对象）便于在不改动既有函数的前提下添加新类。</strong></p></blockquote><p>反过来讲也说得通：</p><blockquote><p><strong>过程式代码（使用数据结构的代码）难以添加新的数据结构，因为必须修改所有的函数。面向对象代码难以添加新函数，因为必须修改所有的类。</strong></p></blockquote><p>因此，对于面向对象困难的事情对于面向过程来说很容易，对于面向对象容易的事情对于面向过程来说很困难。</p><p>在任何复杂的系统中，我们有时会希望能够灵活的添加新的数据类型而不是新的函数。在这种情况下，对象和面向对象就是最合适的。另外一些时候，我们希望能灵活的添加新函数而不是数据类型。在这种情况下，过程式代码和数据结构将会更加合适。</p><p>老练的程序员知道，一切都是对象<strong>只是一个传说</strong>。有时，你真的想要在简单的数据结构上<strong>做</strong>一些过程试的操作。因此，你必须仔细思考要实现什么，也要考虑未来的前景，什么是容易更新的。在这个例子中，因为以后可能会添加其他新的形状，所以我会选择面向对象的方法。</p><hr><p>我知道，在给定时间期限内完成你的工作，很难写好代码。但是你要耽搁多久呢？慢慢开始，坚持不懈。你的代码可以为你自己和其他人（主要受益者）创造奇迹。我已经开始，并且发现了许多我一直在犯的错误。虽然它每天占用我一些额外的时间，但将来我会得到报酬的。</p><blockquote><p>这不是博客的结尾。我将继续编写关于代码整洁之道的新方法。此外，我还将写一些基础的设计模式，这是从事任何技术的开发者都必须了解的知识。</p></blockquote><p>同时，如果你喜欢我的博客并从中获益，请鼓掌。它给了我更快创建新博客的动力 :) 欢迎进行评论/建议。不断学习，不断分享。</p><p><a href="https://mindorks.com/android-app-development-online-course" target="_blank" rel="noopener"><strong>学习 Android APP 开发的完整指南</strong></a></p><p><strong>在 <a href="https://mindorks.com/android-tutorial" target="_blank" rel="noopener">mindorks.com</a> 上查看所有顶级教程</strong></p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-private.oss-cn-shanghai.aliyuncs.com/20200523001518.png&quot; alt=&quot;Writing clean code — Part 1 — Generic principles - Thierry CATRAIN ...&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="code review" scheme="http://blog.todaycoder.cn/tags/code-review/"/>
    
      <category term="clean code" scheme="http://blog.todaycoder.cn/tags/clean-code/"/>
    
      <category term="代码整洁之道" scheme="http://blog.todaycoder.cn/tags/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>[译] Coding Interview University 一套完整的学习手册帮助自己准备 Google 的面试</title>
    <link href="http://blog.todaycoder.cn/2020/04/03/coding-interview-university/"/>
    <id>http://blog.todaycoder.cn/2020/04/03/coding-interview-university/</id>
    <published>2020-04-03T03:24:15.000Z</published>
    <updated>2020-04-03T03:30:54.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是？"><a href="#这是？" class="headerlink" title="这是？"></a>这是？</h2><p>这是我为了从 web 开发者（自学、非计算机科学学位）蜕变至 Google 软件工程师所制定的计划，其内容历时数月。</p><p><img src="https://d3j2pkmjtin6ou.cloudfront.net/coding-at-the-whiteboard-silicon-valley.png" alt="白板上编程 ———— 来自 HBO 频道的剧集，“硅谷”"></p><p>这一长列表是从 <strong>Google 的指导笔记</strong> 中萃取出来并进行扩展。因此，有些事情你必须去了解一下。我在列表的底部添加了一些额外项，用于解决面试中可能会出现的问题。这些额外项大部分是来自于 Steve Yegge 的“<a href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html" target="_blank" rel="noopener">得到在 Google 工作的机会</a>”。而在 Google 指导笔记的逐字间，它们有时也会被反映出来。</p><a id="more"></a><blockquote><ul><li>原文地址：<a href="https://github.com/jwasham/coding-interview-university" target="_blank" rel="noopener">Coding Interview University</a></li><li>原文作者：<a href="https://github.com/jwasham" target="_blank" rel="noopener">John Washam</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>译者：<a href="https://github.com/aleen42" target="_blank" rel="noopener">aleen42</a>，<a href="https://github.com/Newt0n" target="_blank" rel="noopener">Newton</a>，<a href="https://github.com/bobmayuze" target="_blank" rel="noopener">bobmayuze</a>，<a href="https://github.com/laobie" target="_blank" rel="noopener">Jaeger</a>，<a href="https://github.com/sqrthree" target="_blank" rel="noopener">sqrthree</a></li></ul></blockquote><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#这是">这是？</a></li><li><a href="#为何要用到它">为何要用到它？</a></li><li><a href="#如何使用它">如何使用它</a></li><li><a href="#拥有一名-googler-的心态">拥有一名 Googler 的心态</a></li><li><a href="#我得到了工作吗">我得到了工作吗？</a></li><li><a href="#跟着我的脚步">跟着我的脚步</a></li><li><a href="#不要妄自菲薄">不要妄自菲薄</a></li><li><a href="#关于-google">关于 Google</a></li><li><a href="#相关视频资源">相关视频资源</a></li><li><a href="#面试过程--通用的面试准备">面试过程 &amp; 通用的面试准备</a></li><li><a href="#为你的面试选择一种语言">为你的面试选择一种语言</a></li><li><a href="#在你开始之前">在你开始之前</a></li><li><a href="#你所看不到的">你所看不到的</a></li><li><a href="#日常计划">日常计划</a></li><li><a href="#必备知识">必备知识</a></li><li><a href="#算法复杂度--big-o--渐进分析法">算法复杂度 / Big-O / 渐进分析法</a></li><li><a href="#数据结构">数据结构</a><ul><li><a href="#数组arrays">数组（Arrays）</a></li><li><a href="#链表linked-lists">链表（Linked Lists）</a></li><li><a href="#堆栈stack">堆栈（Stack）</a></li><li><a href="#队列queue">队列（Queue）</a></li><li><a href="#哈希表hash-table">哈希表（Hash table）</a></li></ul></li><li><a href="#更多的知识">更多的知识</a><ul><li><a href="#二分查找binary-search">二分查找（Binary search）</a></li><li><a href="#按位运算bitwise-operations">按位运算（Bitwise operations）</a></li></ul></li><li><a href="#树trees">树（Trees）</a><ul><li><a href="#树--笔记--背景">树 —— 笔记 &amp; 背景</a></li><li><a href="#二叉查找树binary-search-treesbsts">二叉查找树（Binary search trees）：BSTs</a></li><li><a href="#堆heap--优先级队列priority-queue--二叉堆binary-heap">堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</a></li><li><a href="#字典树tries">字典树（Tries）</a></li><li><a href="#平衡查找树balanced-search-trees">平衡查找树（Balanced search trees）</a></li><li><a href="#n-叉树k-叉树m-叉树">N 叉树（K 叉树、M 叉树）</a></li></ul></li><li><a href="#排序sorting">排序</a></li><li><a href="#图graphs">图（Graphs）</a></li><li><a href="#更多知识">更多知识</a><ul><li><a href="#递归recursion">递归</a></li><li><a href="#动态规划dynamic-programming">动态规划</a></li><li><a href="#组合combinatorics-n-中选-k-个--概率probability">组合 &amp; 概率</a></li><li><a href="#np-np-完全和近似算法">NP, NP-完全和近似算法</a></li><li><a href="#缓存cache">缓存</a></li><li><a href="#进程processe和线程thread">进程和线程</a></li><li><a href="#系统设计可伸缩性数据处理">系统设计、可伸缩性、数据处理</a></li><li><a href="#论文">论文</a></li><li><a href="#测试">测试</a></li><li><a href="#调度">调度</a></li><li><a href="#实现系统例程">实现系统例程</a></li><li><a href="#字符串搜索和操作">字符串搜索和操作</a></li></ul></li><li><a href="#终面">终面</a></li><li><a href="#书籍">书籍</a></li><li><a href="#编码练习和挑战">编码练习和挑战</a></li><li><a href="#当你临近面试时">当你临近面试时</a></li><li><a href="#你的简历">你的简历</a></li><li><a href="#当面试来临的时候">当面试来临的时候</a></li><li><a href="#问面试官的问题">问面试官的问题</a></li><li><a href="#当你获得了梦想的职位">当你获得了梦想的职位</a></li></ul><p>—————- 下面的内容是可选的 —————-</p><ul><li><a href="#附加的学习">附加的学习</a><ul><li><a href="#unicode">Unicode</a></li><li><a href="#字节顺序">字节顺序</a></li><li><a href="#emacs-and-vim">Emacs and vi(m)</a></li><li><a href="#unix-命令行工具">Unix 命令行工具</a></li><li><a href="#信息资源-视频">信息资源 (视频)</a></li><li><a href="#奇偶校验位--汉明码-视频">奇偶校验位 &amp; 汉明码 (视频)</a></li><li><a href="#系统熵值系统复杂度">系统熵值（系统复杂度）</a></li><li><a href="#密码学">密码学</a></li><li><a href="#压缩">压缩</a></li><li><a href="#网络-视频">网络 (视频)</a></li><li><a href="#计算机安全">计算机安全</a></li><li><a href="#释放缓存">释放缓存</a></li><li><a href="#并行并发编程">并行/并发编程</a></li><li><a href="#设计模式">设计模式</a></li><li><a href="#信息传输-序列化和队列化的系统">信息传输, 序列化, 和队列化的系统</a></li><li><a href="#快速傅里叶变换">快速傅里叶变换</a></li><li><a href="#布隆过滤器">布隆过滤器</a></li><li><a href="#van-emde-boas-树">van Emde Boas 树</a></li><li><a href="#更深入的数据结构">更深入的数据结构</a></li><li><a href="#跳表">跳表</a></li><li><a href="#网络流">网络流</a></li><li><a href="#不相交集--联合查找">不相交集 &amp; 联合查找</a></li><li><a href="#math-for-fast-processing">快速处理数学</a></li><li><a href="#树堆-treap">树堆 (Treap)</a></li><li><a href="#线性规划linear-programming视频">线性规划</a></li><li><a href="#几何凸包geometry-convex-hull视频">几何：凸包（Geometry, Convex hull）</a></li><li><a href="#离散数学">离散数学</a></li><li><a href="#机器学习machine-learning">机器学习</a></li><li><a href="#go-语言">Go 语言</a></li></ul></li><li><a href="#一些主题的额外内容">一些主题的额外内容</a></li><li><a href="#视频系列">视频系列</a></li><li><a href="#计算机科学课程">计算机科学课程</a></li></ul><hr><h2 id="为何要用到它？"><a href="#为何要用到它？" class="headerlink" title="为何要用到它？"></a>为何要用到它？</h2><p>我一直都是遵循该计划去准备 Google 的面试。自 1997 年以来，我一直从事于 web 程序的构建、服务器的构建及创业型公司的创办。对于只有着一个经济学学位，而不是计算机科学学位（CS degree）的我来说，在职业生涯中所取得的都非常成功。然而，我想在 Google 工作，并进入大型系统中，真正地去理解计算机系统、算法效率、数据结构性能、低级别编程语言及其工作原理。可一项都不了解的我，怎么会被 Google 所应聘呢？</p><p>当我创建该项目时，我从一个堆栈到一个堆都不了解。那时的我，完全不了解 Big-O 、树，或如何去遍历一个图。如果非要我去编写一个排序算法的话，我只能说我所写的肯定是很糟糕。一直以来，我所用的任何数据结构都是内建于编程语言当中。至于它们在背后是如何运作，对此我一概不清楚。此外，以前的我并不需要对内存进行管理，最多就只是在一个正在执行的进程抛出了“内存不足”的错误后，采取一些权变措施。而在我的编程生活中，也甚少使用到多维数组，可关联数组却成千上万。而且，从一开始到现在，我都还未曾自己实现过数据结构。</p><p>就是这样的我，在经过该学习计划后，已然对被 Google 所雇佣充满信心。这是一个漫长的计划，以至于花费了我数月的时间。若您早已熟悉大部分的知识，那么也许能节省大量的时间。</p><h2 id="如何使用它"><a href="#如何使用它" class="headerlink" title="如何使用它"></a>如何使用它</h2><p>下面所有的东西都只是一个概述。因此，你需要由上而下逐一地去处理它。</p><p>在学习过程中，我是使用 GitHub 特殊的语法特性 markdown flavor 去检查计划的进展，包括使用任务列表。</p><ul><li style="list-style: none"><input type="checkbox" checked> 创建一个新的分支，以使得你可以像这样去检查计划的进展。直接往方括号中填写一个字符 x 即可：[x]</li></ul><p><a href="https://guides.github.com/features/mastering-markdown/#GitHub-flavored-markdown" target="_blank" rel="noopener">更多关于 Github-flavored markdown 的详情</a></p><h2 id="我得到了工作吗？"><a href="#我得到了工作吗？" class="headerlink" title="我得到了工作吗？"></a>我得到了工作吗？</h2><p>我还没去应聘。</p><p>因为我离完成学习（完成该疯狂的计划列表）还需要数天的时间，并打算在下周开始用一整天的时间，以编程的方式去解决问题。当然，这将会持续数周的时间。然后，我才通过使用在二月份所得到的一个介绍资格，去正式应聘 Google（没错，是二月份时就得到的）。</p><pre><code>感谢 JP 的这次介绍。</code></pre><h2 id="跟着我的脚步"><a href="#跟着我的脚步" class="headerlink" title="跟着我的脚步"></a>跟着我的脚步</h2><p>目前我仍在该计划的执行过程中，如果你想跟随我脚步去学习的话，可以登进我在 <a href="https://googleyasheck.com/" target="_blank" rel="noopener">GoogleyAsHeck.com</a> 上所写的博客。</p><p>下面是我的联系方式：</p><ul><li>Twitter: <a href="https://twitter.com/googleyasheck" target="_blank" rel="noopener">@googleyasheck</a></li><li>Twitter: <a href="https://twitter.com/StartupNextDoor" target="_blank" rel="noopener">@StartupNextDoor</a></li><li>Google+: <a href="https://plus.google.com/+Googleyasheck" target="_blank" rel="noopener">+Googleyasheck</a></li><li>LinkedIn: <a href="https://www.linkedin.com/in/johnawasham" target="_blank" rel="noopener">johnawasham</a></li></ul><p><img src="https://dng5l3qzreal6.cloudfront.net/2016/Aug/book_stack_photo_resized_18_1469302751157-1472661280368.png" alt="John Washam - Coding Interview University"></p><h2 id="不要妄自菲薄"><a href="#不要妄自菲薄" class="headerlink" title="不要妄自菲薄"></a>不要妄自菲薄</h2><ul><li>Google 的工程师都是才智过人的。但是，就算是工作在 Google 的他们，仍然会因为觉得自己不够聪明而感到一种不安。</li><li><a href="https://www.youtube.com/watch?v=0SARbwvhupQ" target="_blank" rel="noopener">天才程序员的神话</a></li></ul><h2 id="关于-Google"><a href="#关于-Google" class="headerlink" title="关于 Google"></a>关于 Google</h2><ul><li style="list-style: none"><input type="checkbox"> 面向学生 —— <a href="https://www.google.com/about/careers/students/guide-to-technical-development.html" target="_blank" rel="noopener">Google 的职业生涯：技术开发指导</a></li><li style="list-style: none"><input type="checkbox"> Google 检索的原理：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=mTBShTwCnD4" target="_blank" rel="noopener">Google 检索的发展史（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.google.com/insidesearch/howsearchworks/thestory/" target="_blank" rel="noopener">Google 检索的原理 —— 故事篇</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.google.com/insidesearch/howsearchworks/" target="_blank" rel="noopener">Google 检索的原理</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=BNHR6IQJGZs" target="_blank" rel="noopener">Google 检索的原理 —— Matt Cutts（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=J5RZOU6vK4Q" target="_blank" rel="noopener">Google 是如何改善其检索算法（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 系列文章：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/how-google-search-dealt-with-mobile-33bc09852dc9" target="_blank" rel="noopener">Google 检索是如何处理移动设备</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/googles-secret-study-to-find-out-our-needs-eba8700263bf" target="_blank" rel="noopener">Google 为了寻找大众需求的秘密研究</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/google-search-will-be-your-next-brain-5207c26e4523" target="_blank" rel="noopener">Google 检索将成为你的下一个大脑</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/the-deep-mind-of-demis-hassabis-156112890d8a" target="_blank" rel="noopener">Demis Hassabis 的心灵直白</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.amazon.com/How-Google-Works-Eric-Schmidt/dp/1455582344" target="_blank" rel="noopener">书籍：Google 公司是如何运作的</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q4y0KOeXViI" target="_blank" rel="noopener">由 Google 通告所制作 —— 2016年10月（视频）</a></li></ul><h2 id="相关视频资源"><a href="#相关视频资源" class="headerlink" title="相关视频资源"></a>相关视频资源</h2><p>部分视频只能通过在 Coursera、Edx 或 Lynda.com class 上注册登录才能观看。这些视频被称为网络公开课程（MOOC）。即便是免费观看，部分课程可能会由于不在时间段内而无法获取。因此，你需要多等待几个月。</p><pre><code>很感谢您能帮我把网络公开课程的视频链接转换成公开的视频源，以代替那些在线课程的视频。此外，一些大学的讲座视频也是我所青睐的。</code></pre><h2 id="面试过程-amp-通用的面试准备"><a href="#面试过程-amp-通用的面试准备" class="headerlink" title="面试过程 &amp; 通用的面试准备"></a>面试过程 &amp; 通用的面试准备</h2><ul><li><p>[ ] 视频：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oWbUtlUhwa8&amp;feature=youtu.be" target="_blank" rel="noopener">如何在 Google 工作 —— 考生指导课程（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=qc1owf2-220&amp;feature=youtu.be" target="_blank" rel="noopener">Google 招聘者所分享的技术面试小窍门（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8npJLXkcmu8" target="_blank" rel="noopener">如何在 Google 工作：技术型简历的准备（视频）</a></li></ul></li><li><p>[ ] 文章：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.google.com/about/careers/lifeatgoogle/hiringprocess/" target="_blank" rel="noopener">三步成为 Googler</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html" target="_blank" rel="noopener">得到在 Google 的工作机会</a><ul><li>所有他所提及的事情都列在了下面</li></ul></li><li style="list-style: none"><input type="checkbox"> <em>（早已过期）</em> <a href="http://dondodge.typepad.com/the_next_big_thing/2010/09/how-to-get-a-job-at-google-interview-questions-hiring-process.html" target="_blank" rel="noopener">如何得到 Google 的一份工作，面试题，应聘过程</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions" target="_blank" rel="noopener">电话面试的问题</a></li></ul></li><li><p>[ ] 附加的（虽然 Google 不建议，但我还是添加在此）：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://medium.com/always-be-coding/abc-always-be-coding-d5f8051afce2#.4heg8zvm4" target="_blank" rel="noopener">ABC：永远都要去编程（Always Be Coding）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://medium.com/always-be-coding/four-steps-to-google-without-a-degree-8f381aa6bd5e#.asalo1vfx" target="_blank" rel="noopener">四步成为 Google 里一名没有学位的员工</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://medium.com/@dpup/whiteboarding-4df873dbba2e#.hf6jn45g1" target="_blank" rel="noopener">共享白板（Whiteboarding）</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.kpcb.com/blog/lessons-learned-how-google-thinks-about-hiring-management-and-culture" target="_blank" rel="noopener">Google 是如何看待应聘、管理和公司文化</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.coderust.com/blog/2014/04/10/effective-whiteboarding-during-programming-interviews/" target="_blank" rel="noopener">程序开发面试中有效的白板（Whiteboarding）</a></li><li style="list-style: none"><input type="checkbox"> 震撼开发类面试 第一集：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=rEJzOhC5ZtQ" target="_blank" rel="noopener">Gayle L McDowell —— 震撼开发类面试（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=aClxtDcdpsQ" target="_blank" rel="noopener">震撼开发类面试 —— 作者 Gayle Laakmann McDowell（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 如何在世界四强企业中获得一份工作：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=YJZCUhxNCv8" target="_blank" rel="noopener">“如何在世界四强企业中获得一份工作 —— Amazon、Facebook、Google 和 Microsoft”（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://alexbowe.com/failing-at-google-interviews/" target="_blank" rel="noopener">面试 Google 失败</a></li></ul></li></ul><h2 id="为你的面试选择一种语言"><a href="#为你的面试选择一种语言" class="headerlink" title="为你的面试选择一种语言"></a>为你的面试选择一种语言</h2><p>在这，我就以下话题写一篇短文 —— <a href="https://googleyasheck.com/important-pick-one-language-for-the-google-interview/" target="_blank" rel="noopener">重点：为在 Google 的面试选择一种语言</a></p><p>在大多数公司的面试当中，你可以在编程这一环节，使用一种自己用起来较为舒适的语言去完成编程。但在 Google，你只有三种固定的选择：</p><ul><li>C++</li><li>Java</li><li>Python</li></ul><p>有时你也可以使用下面两种，但需要事先查阅说明。因为，说明中会有警告：</p><ul><li>JavaScript</li><li>Ruby</li></ul><p>你需要对你所选择的语言感到非常舒适且足够了解。</p><p>更多关于语言选择的阅读：</p><ul><li><a href="http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/" target="_blank" rel="noopener">http://www.byte-by-byte.com/choose-the-right-language-for-your-coding-interview/</a></li><li><a href="http://blog.codingforinterviews.com/best-programming-language-jobs/" target="_blank" rel="noopener">http://blog.codingforinterviews.com/best-programming-language-jobs/</a></li><li><a href="https://www.quora.com/What-is-the-best-language-to-program-in-for-an-in-person-Google-interview" target="_blank" rel="noopener">https://www.quora.com/What-is-the-best-language-to-program-in-for-an-in-person-Google-interview</a></li></ul><p><a href="../programming-language-resources.md">在此查看相关语言的资源</a></p><p>由于，我正在学习C、C++ 和 Python。因此，在下面你会看到部分关于它们的学习资料。相关书籍请看文章的底部。</p><h2 id="在你开始之前"><a href="#在你开始之前" class="headerlink" title="在你开始之前"></a>在你开始之前</h2><p>该列表已经持续更新了很长的一段时间，所以，我们的确很容易会对其失去控制。</p><p>这里列出了一些我所犯过的错误，希望您不要重滔覆辙。</p><h3 id="1-你不可能把所有的东西都记住"><a href="#1-你不可能把所有的东西都记住" class="headerlink" title="1. 你不可能把所有的东西都记住"></a>1. 你不可能把所有的东西都记住</h3><p>就算我查看了数小时的视频，并记录了大量的笔记。几个月后的我，仍然会忘却其中大部分的东西。所以，我翻阅了我的笔记，并将可回顾的东西制作成抽认卡（flashcard）（请往下看）</p><h3 id="2-使用抽认卡"><a href="#2-使用抽认卡" class="headerlink" title="2. 使用抽认卡"></a>2. 使用抽认卡</h3><p>为了解决善忘的问题，我制作了一些关于抽认卡的页面，用于添加两种抽认卡：正常的及带有代码的。每种卡都会有不同的格式设计。</p><p>而且，我还以移动设备为先去设计这些网页，以使得在任何地方的我，都能通过我的手机及平板去回顾知识。</p><p>你也可以免费制作属于你自己的抽认卡网站：</p><ul><li><a href="https://github.com/jwasham/computer-science-flash-cards" target="_blank" rel="noopener">抽认卡页面的代码仓库</a></li><li><a href="https://github.com/jwasham/computer-science-flash-cards/blob/master/cards-jwasham.db" target="_blank" rel="noopener">我的抽认卡数据库</a>：有一点需要记住的是，我做事有点过头，以至于把卡片都覆盖到所有的东西上。从汇编语言和 Python 的细枝末节，乃至到机器学习和统计都被覆盖到卡片上。而这种做法，对于 Google 的要求来说，却是多余。</li></ul><p><strong>在抽认卡上做笔记：</strong> 若你第一次发现你知道问题的答案时，先不要急着把其标注成“已懂”。你需要做的，是去查看一下是否有同样的抽认卡，并在你真正懂得如何解决问题之前，多问自己几次。重复地问答可帮助您深刻记住该知识点。</p><h3 id="3-回顾，回顾，回顾"><a href="#3-回顾，回顾，回顾" class="headerlink" title="3. 回顾，回顾，回顾"></a>3. 回顾，回顾，回顾</h3><p>我留有一组 ASCII 码表、OSI 堆栈、Big-O 记号及更多的小抄纸，以便在空余的时候可以学习。</p><p>每编程半个小时就要休息一下，并去回顾你的抽认卡。</p><h3 id="4-专注"><a href="#4-专注" class="headerlink" title="4. 专注"></a>4. 专注</h3><p>在学习的过程中，往往会有许多令人分心的事占据着我们宝贵的时间。因此，专注和集中注意力是非常困难的。</p><h2 id="你所看不到的"><a href="#你所看不到的" class="headerlink" title="你所看不到的"></a>你所看不到的</h2><p>由于，这个巨大的列表一开始是作为我个人从 Google 面试指导笔记所形成的一个事件处理列表。因此，有一些我熟悉且普遍的技术在此都未被谈及到：</p><ul><li>SQL</li><li>Javascript</li><li>HTML、CSS 和其他前端技术</li></ul><h2 id="日常计划"><a href="#日常计划" class="headerlink" title="日常计划"></a>日常计划</h2><p>部分问题可能会花费一天的时间去学习，而部分则会花费多天。当然，有些学习并不需要我们懂得如何实现。</p><p>因此，每一天我都会在下面所列出的列表中选择一项，并查看相关的视频。然后，使用以下的一种语言去实现：</p><pre><code>C —— 使用结构体和函数，该函数会接受一个结构体指针 * 及其他数据作为参数。C++ —— 不使用内建的数据类型。C++ —— 使用内建的数据类型，如使用 STL 的 std::list 来作为链表。Python ——  使用内建的数据类型（为了持续练习 Python），并编写一些测试去保证自己代码的正确性。有时，只需要使用断言函数 assert() 即可。此外，你也可以使用 Java 或其他语言。以上只是我的个人偏好而已。</code></pre><p>为何要在这些语言上分别实现一次？</p><pre><code>因为可以练习，练习，练习，直至我厌倦它，并完美地实现出来。（若有部分边缘条件没想到时，我会用书写的形式记录下来并去记忆）因为可以在纯原生的条件下工作（不需垃圾回收机制的帮助下，分配/释放内存（除了 Python））因为可以利用上内建的数据类型，以使得我拥有在现实中使用内建工具的经验（在生产环境中，我不会去实现自己的链表）</code></pre><p>就算我没有时间去每一项都这么做，但我也会尽我所能的。</p><p>在这里，你可以查看到我的代码：</p><ul><li><a href="https://github.com/jwasham/practice-c" target="_blank" rel="noopener">C</a></li><li><a href="https://github.com/jwasham/practice-cpp" target="_blank" rel="noopener">C++</a></li><li><a href="https://github.com/jwasham/practice-python" target="_blank" rel="noopener">Python</a></li></ul><p>你不需要记住每一个算法的内部原理。</p><p>在一个白板上写代码，而不要直接在计算机上编写。在测试完部分简单的输入后，到计算机上再测试一遍。</p><h2 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h2><ul><li><p>[ ] <strong>计算机是如何处理一段程序：</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=42KTvGYQYnA" target="_blank" rel="noopener">CPU 是如何执行代码（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Mv2XQgpbTNE" target="_blank" rel="noopener">机器码指令（视频）</a></li></ul></li><li><p>[ ] <strong>编译器</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=IhC7sdYe-Jg" target="_blank" rel="noopener">编译器是如何在 ~1 分钟内工作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=CSZLNYF4Klo" target="_blank" rel="noopener">Hardvard CS50 —— 编译器（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=twodd1KFfGk" target="_blank" rel="noopener">C++（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=FnGCDLhaxKU" target="_blank" rel="noopener">掌握编译器的优化（C++）（视频）</a></li></ul></li><li><p>[ ] <strong>浮点数是如何存储的：</strong></p><ul><li style="list-style: none"><input type="checkbox"> 简单的 8-bit：<a href="https://www.youtube.com/watch?v=ji3SfClm8TU" target="_blank" rel="noopener">浮点数的表达形式　—— 1（视频 —— 在计算上有一个错误 —— 详情请查看视频的介绍）</a></li><li style="list-style: none"><input type="checkbox"> 32 bit：<a href="https://www.youtube.com/watch?v=50ZYcZebIec" target="_blank" rel="noopener">IEEE754 32-bit 浮点二进制（视频）</a></li></ul></li></ul><h2 id="算法复杂度-Big-O-渐进分析法"><a href="#算法复杂度-Big-O-渐进分析法" class="headerlink" title="算法复杂度 / Big-O / 渐进分析法"></a>算法复杂度 / Big-O / 渐进分析法</h2><ul><li>并不需要实现</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iOq5kSKqeR4" target="_blank" rel="noopener">Harvard CS50 —— 渐进表示（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=V6mKVRU1evU" target="_blank" rel="noopener">Big O 记号（通用快速教程）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ei-A_wy5Yxw&amp;index=2&amp;list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN" target="_blank" rel="noopener">Big O 记号（以及 Omega 和 Theta）——  最佳数学解释（视频）</a></li><li style="list-style: none"><input type="checkbox"> Skiena 算法：<ul><li><a href="https://www.youtube.com/watch?v=gSyDMtdPNpU&amp;index=2&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">视频</a></li><li><a href="http://www3.cs.stonybrook.edu/~algorith/video-lectures/2007/lecture2.pdf" target="_blank" rel="noopener">幻灯片</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://discrete.gr/complexity/" target="_blank" rel="noopener">对于算法复杂度分析的一次详细介绍</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/59" target="_blank" rel="noopener">增长阶数（Orders of Growth）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/61" target="_blank" rel="noopener">渐进性（Asymptotics）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/VIS4YDpuP98" target="_blank" rel="noopener">UC Berkeley Big O（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/ca3e7UVmeUc" target="_blank" rel="noopener">UC Berkeley Big Omega（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=B3SpQZaAZP4&amp;index=10&amp;list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN" target="_blank" rel="noopener">平摊分析法（Amortized Analysis）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://class.coursera.org/algorithmicthink1-004/lecture/63" target="_blank" rel="noopener">举证“Big O”（视频）</a></li><li style="list-style: none"><input type="checkbox"> 高级编程（包括递归关系和主定理）：<ul><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-1/" target="_blank" rel="noopener">计算性复杂度：第一部</a></li><li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/computational-complexity-section-2/" target="_blank" rel="noopener">计算性复杂度：第二部</a></li></ul></li><li><p>[ ] <a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">速查表（Cheat sheet）</a></p><p>  如果部分课程过于学术性，你可直接跳到文章底部，去查看离散数学的视频以获取相关背景知识。</p></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><h3 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h3><ul><li>实现一个可自动调整大小的动态数组。</li><li style="list-style: none"><input type="checkbox"> 介绍：<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/OsBSF/arrays" target="_blank" rel="noopener">数组（视频）</a></li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/02_04-basicArrays.mp4" target="_blank" rel="noopener">数组的基础知识（视频）</a></li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/02_05-multidimensionalArrays.mp4" target="_blank" rel="noopener">多维数组（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/EwbnV/dynamic-arrays" target="_blank" rel="noopener">动态数组（视频）</a></li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/02_06-jaggedArrays.mp4" target="_blank" rel="noopener">不规则数组（视频）</a></li><li><a href="https://archive.org/details/0102WhatYouShouldKnow/03_01-resizableArrays.mp4" target="_blank" rel="noopener">调整数组的大小（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 实现一个动态数组（可自动调整大小的可变数组）：<ul><li style="list-style: none"><input type="checkbox"> 练习使用数组和指针去编码，并且指针是通过计算去跳转而不是使用索引</li><li style="list-style: none"><input type="checkbox"> 通过分配内存来新建一个原生数据型数组<ul><li>可以使用 int 类型的数组，但不能使用其语法特性</li><li>从大小为16或更大的数（使用2的倍数 —— 16、32、64、128）开始编写</li></ul></li><li style="list-style: none"><input type="checkbox"> size() —— 数组元素的个数</li><li style="list-style: none"><input type="checkbox"> capacity() —— 可容纳元素的个数</li><li style="list-style: none"><input type="checkbox"> is_empty()</li><li style="list-style: none"><input type="checkbox"> at(index) —— 返回对应索引的元素，且若索引越界则愤然报错</li><li style="list-style: none"><input type="checkbox"> push(item)</li><li style="list-style: none"><input type="checkbox"> insert(index, item) —— 在指定索引中插入元素，并把后面的元素依次后移</li><li style="list-style: none"><input type="checkbox"> prepend(item) —— 可以使用上面的 insert 函数，传参 index 为 0</li><li style="list-style: none"><input type="checkbox"> pop() —— 删除在数组末端的元素，并返回其值</li><li style="list-style: none"><input type="checkbox"> delete(index) —— 删除指定索引的元素，并把后面的元素依次前移</li><li style="list-style: none"><input type="checkbox"> remove(item) —— 删除指定值的元素，并返回其索引（即使有多个元素）</li><li style="list-style: none"><input type="checkbox"> find(item) —— 寻找指定值的元素并返回其中第一个出现的元素其索引，若未找到则返回 -1</li><li style="list-style: none"><input type="checkbox"> resize(new_capacity) // 私有函数<ul><li>若数组的大小到达其容积，则变大一倍</li><li>获取元素后，若数组大小为其容积的1/4，则缩小一半</li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> 时间复杂度<ul><li>在数组末端增加/删除、定位、更新元素，只允许占 O(1) 的时间复杂度（平摊（amortized）去分配内存以获取更多空间）</li><li>在数组任何地方插入/移除元素，只允许 O(n) 的时间复杂度</li></ul></li><li style="list-style: none"><input type="checkbox"> 空间复杂度<ul><li>因为在内存中分配的空间邻近，所以有助于提高性能</li><li>空间需求 = （大于或等于 n 的数组容积）* 元素的大小。即便空间需求为 2n，其空间复杂度仍然是 O(n)</li></ul></li></ul></li><li><h3 id="链表（Linked-Lists）"><a href="#链表（Linked-Lists）" class="headerlink" title="链表（Linked Lists）"></a>链表（Linked Lists）</h3><ul><li style="list-style: none"><input type="checkbox"> 介绍：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/kHhgK/singly-linked-lists" target="_blank" rel="noopener">单向链表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=sJtJOtXCW_M&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=5" target="_blank" rel="noopener">CS 61B —— 链表（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=QN6FPiD0Gzo" target="_blank" rel="noopener">C 代码（视频）</a><ul><li>并非看完整个视频，只需要看关于节点结果和内存分配那一部分即可</li></ul></li><li style="list-style: none"><input type="checkbox"> 链表 vs 数组：<ul><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/rjBs9/core-linked-lists-vs-arrays" target="_blank" rel="noopener">基本链表 Vs 数组（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/QUaUd/in-the-real-world-lists-vs-arrays" target="_blank" rel="noopener">在现实中，链表 Vs 数组（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=YQs6IC-vgmo" target="_blank" rel="noopener">为什么你需要避免使用链表（视频）</a></li><li style="list-style: none"><input type="checkbox"> 的确：你需要关于“指向指针的指针”的相关知识：（因为当你传递一个指针到一个函数时，该函数可能会改变指针所指向的地址）该页只是为了让你了解“指向指针的指针”这一概念。但我并不推荐这种链式遍历的风格。因为，这种风格的代码，其可读性和可维护性太低。<ul><li><a href="https://www.eskimo.com/~scs/cclass/int/sx8.html" target="_blank" rel="noopener">指向指针的指针</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 实现（我实现了使用尾指针以及没有使用尾指针这两种情况）：<ul><li style="list-style: none"><input type="checkbox"> size() —— 返回链表中数据元素的个数</li><li style="list-style: none"><input type="checkbox"> empty() —— 若链表为空则返回一个布尔值 true</li><li style="list-style: none"><input type="checkbox"> value_at(index) —— 返回第 n 个元素的值（从0开始计算）</li><li style="list-style: none"><input type="checkbox"> push_front(value) —— 添加元素到链表的首部</li><li style="list-style: none"><input type="checkbox"> pop_front() —— 删除首部元素并返回其值</li><li style="list-style: none"><input type="checkbox"> push_back(value) —— 添加元素到链表的尾部</li><li style="list-style: none"><input type="checkbox"> pop_back() —— 删除尾部元素并返回其值</li><li style="list-style: none"><input type="checkbox"> front() —— 返回首部元素的值</li><li style="list-style: none"><input type="checkbox"> back() —— 返回尾部元素的值</li><li style="list-style: none"><input type="checkbox"> insert(index, value) —— 插入值到指定的索引，并把当前索引的元素指向到新的元素</li><li style="list-style: none"><input type="checkbox"> erase(index) —— 删除指定索引的节点</li><li style="list-style: none"><input type="checkbox"> value_n_from_end(n) —— 返回倒数第 n 个节点的值</li><li style="list-style: none"><input type="checkbox"> reverse() —— 逆序链表</li><li style="list-style: none"><input type="checkbox"> remove_value(value) —— 删除链表中指定值的第一个元素</li></ul></li><li style="list-style: none"><input type="checkbox"> 双向链表<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/jpGKD/doubly-linked-lists" target="_blank" rel="noopener">介绍（视频）</a></li><li>并不需要实现</li></ul></li></ul></li><li><h3 id="堆栈（Stack）"><a href="#堆栈（Stack）" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/UdKzQ/stacks" target="_blank" rel="noopener">堆栈（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/05_01-usingStacksForLast-inFirst-out.mp4" target="_blank" rel="noopener">使用堆栈 —— 后进先出（视频）</a></li><li style="list-style: none"><input type="checkbox"> 可以不实现，因为使用数组来实现并不重要</li></ul></li><li><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/05_03-usingQueuesForFirst-inFirst-out.mp4" target="_blank" rel="noopener">使用队列 —— 先进先出（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/EShpq/queue" target="_blank" rel="noopener">队列（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank" rel="noopener">原型队列/先进先出（FIFO）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/05_04-priorityQueuesAndDeques.mp4" target="_blank" rel="noopener">优先级队列（视频）</a></li><li style="list-style: none"><input type="checkbox"> 使用含有尾部指针的链表来实现:<ul><li>enqueue(value) —— 在尾部添加值</li><li>dequeue() —— 删除最早添加的元素并返回其值（首部元素）</li><li>empty()</li></ul></li><li style="list-style: none"><input type="checkbox"> 使用固定大小的数组实现：<ul><li>enqueue(value) —— 在可容的情况下添加元素到尾部</li><li>dequeue() —— 删除最早添加的元素并返回其值</li><li>empty()</li><li>full()</li></ul></li><li style="list-style: none"><input type="checkbox"> 花销：<ul><li>在糟糕的实现情况下，使用链表所实现的队列，其入列和出列的时间复杂度将会是 O(n)。因为，你需要找到下一个元素，以致循环整个队列</li><li>enqueue：O(1)（平摊（amortized）、链表和数组 [探测（probing）]）</li><li>dequeue：O(1)（链表和数组）</li><li>empty：O(1)（链表和数组）</li></ul></li></ul></li><li><h3 id="哈希表（Hash-table）"><a href="#哈希表（Hash-table）" class="headerlink" title="哈希表（Hash table）"></a>哈希表（Hash table）</h3><ul><li><p>[ ] 视频：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=0M_kIqhwbFo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=8" target="_blank" rel="noopener">链式哈希表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=BRO7mVIFt08&amp;index=9&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">Table Doubling 和 Karp-Rabin（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=rvdJDijO2Ro&amp;index=10&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">Open Addressing 和密码型哈希（Cryptographic Hashing）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=C4Kc8xzcA68" target="_blank" rel="noopener">PyCon 2010：The Mighty Dictionary（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=z0lJ2k0sl1g&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=11" target="_blank" rel="noopener">（进阶）随机取样（Randomization）：全域哈希（Universal Hashing）&amp; 完美哈希（Perfect Hashing）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=N0COwN14gt0&amp;list=PL2B4EEwhKD-NbwZ4ezj7gyc_3yNrojKM9&amp;index=4" target="_blank" rel="noopener">（进阶）完美哈希（Perfect hashing）（视频）</a></li></ul></li><li><p>[ ] 在线课程：</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/06_02-understandingHashFunctions.mp4" target="_blank" rel="noopener">哈希函数的掌握（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/06_03-usingHashTables.mp4" target="_blank" rel="noopener">使用哈希表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/06_04-supportingHashing.mp4" target="_blank" rel="noopener">哈希表的支持（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://archive.org/details/0102WhatYouShouldKnow/06_05-languageSupportForHashTables.mp4" target="_blank" rel="noopener">哈希表的语言支持（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/m7UuP/core-hash-tables" target="_blank" rel="noopener">基本哈希表（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/home/week/3" target="_blank" rel="noopener">数据结构（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/NYZZP/phone-book-problem" target="_blank" rel="noopener">电话薄问题（Phone Book Problem）（视频）</a></li><li style="list-style: none"><input type="checkbox"> 分布式哈希表：<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/DvaIb/instant-uploads-and-storage-optimization-in-dropbox" target="_blank" rel="noopener">Dropbox 中的瞬时上传及存储优化（视频）</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/tvH8H/distributed-hash-tables" target="_blank" rel="noopener">分布式哈希表（视频）</a></li></ul></li></ul></li><li><p>[ ] 使用线性探测的数组去实现</p><ul><li>hash(k, m) —— m 是哈希表的大小</li><li>add(key, value) —— 如果 key 已存在则更新值</li><li>exists(key)</li><li>get(key)</li><li>remove(key)</li></ul></li></ul></li></ul><h2 id="更多的知识"><a href="#更多的知识" class="headerlink" title="更多的知识"></a>更多的知识</h2><ul><li><h3 id="二分查找（Binary-search）"><a href="#二分查找（Binary-search）" class="headerlink" title="二分查找（Binary search）"></a>二分查找（Binary search）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=D5SrAga1pno" target="_blank" rel="noopener">二分查找（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search" target="_blank" rel="noopener">二分查找（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/" target="_blank" rel="noopener">详情</a></li><li style="list-style: none"><input type="checkbox"> 实现：<ul><li>二分查找（在一个已排序好的整型数组中查找）</li><li>迭代式二分查找</li></ul></li></ul></li><li><h3 id="按位运算（Bitwise-operations）"><a href="#按位运算（Bitwise-operations）" class="headerlink" title="按位运算（Bitwise operations）"></a>按位运算（Bitwise operations）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/jwasham/coding-interview-university/blob/master/extras/cheat%20sheets/bits-cheat-cheet.pdf" target="_blank" rel="noopener">Bits 速查表</a><ul><li>你需要知道大量2的幂数值（从2^1 到 2^16 及 2^32）</li></ul></li><li style="list-style: none"><input type="checkbox"> 好好理解位操作符的含义：&amp;、|、^、~、&gt;&gt;、&lt;&lt;<ul><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Word_(computer_architecture" target="_blank" rel="noopener">字码（words）</a>)</li><li style="list-style: none"><input type="checkbox"> 好的介绍：<br>  <a href="https://www.youtube.com/watch?v=7jkIUgLC29I" target="_blank" rel="noopener">位操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=d0AwjSpNXR0" target="_blank" rel="noopener">C 语言编程教程 2-10：按位运算（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Bit_manipulation" target="_blank" rel="noopener">位操作</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Bitwise_operation" target="_blank" rel="noopener">按位运算</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://graphics.stanford.edu/~seander/bithacks.html" target="_blank" rel="noopener">Bithacks</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://bits.stephan-brumme.com/" target="_blank" rel="noopener">位元抚弄者（The Bit Twiddler）</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://bits.stephan-brumme.com/interactive.html" target="_blank" rel="noopener">交互式位元抚弄者（The Bit Twiddler Interactive）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 一补数和补码<ul><li><a href="https://www.youtube.com/watch?v=lKTsv6iVxV4" target="_blank" rel="noopener">二进制：利 &amp; 弊（为什么我们要使用补码）（视频）</a></li><li><a href="https://en.wikipedia.org/wiki/Ones%27_complement" target="_blank" rel="noopener">一补数（1s Complement）</a></li><li><a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener">补码（2s Complement）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 计算置位（Set Bits）<ul><li><a href="https://youtu.be/Hzuzo9NJrlc" target="_blank" rel="noopener">计算一个字节中置位（Set Bits）的四种方式（视频）</a></li><li><a href="https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan" target="_blank" rel="noopener">计算比特位</a></li><li><a href="http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer" target="_blank" rel="noopener">如何在一个 32 位的整型中计算置位（Set Bits）的数量</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 四舍五入2的幂数：<ul><li><a href="http://bits.stephan-brumme.com/roundUpToNextPowerOfTwo.html" target="_blank" rel="noopener">四舍五入到2的下一幂数</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 交换值：<ul><li><a href="http://bits.stephan-brumme.com/swap.html" target="_blank" rel="noopener">交换（Swap）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 绝对值：<ul><li><a href="http://bits.stephan-brumme.com/absInteger.html" target="_blank" rel="noopener">绝对整型（Absolute Integer）</a></li></ul></li></ul></li></ul><h2 id="树（Trees）"><a href="#树（Trees）" class="headerlink" title="树（Trees）"></a>树（Trees）</h2><ul><li><h3 id="树-——-笔记-amp-背景"><a href="#树-——-笔记-amp-背景" class="headerlink" title="树 —— 笔记 &amp; 背景"></a>树 —— 笔记 &amp; 背景</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/ovovP/core-trees" target="_blank" rel="noopener">系列：基本树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/95qda/trees" target="_blank" rel="noopener">系列：树（视频）</a></li><li>基本的树形结构</li><li>遍历</li><li>操作算法</li><li>BFS（广度优先检索，breadth-first search）<ul><li><a href="https://www.youtube.com/watch?v=s-CYnVz-uh4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=13" target="_blank" rel="noopener">MIT（视频）</a></li><li>层序遍历（使用队列的 BFS 算法）<ul><li>时间复杂度： O(n)</li><li>空间复杂度：<ul><li>最好情况： O(1)</li><li>最坏情况：O(n/2)=O(n)</li></ul></li></ul></li></ul></li><li>DFS（深度优先检索，depth-first search）<ul><li><a href="https://www.youtube.com/watch?v=AfSk24UTFS8&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=14" target="_blank" rel="noopener">MIT（视频）</a></li><li>笔记：<ul><li>时间复杂度：O(n)</li><li>空间复杂度：<ul><li>最好情况：O(log n) - 树的平均高度</li><li>最坏情况：O(n)</li></ul></li></ul></li><li>中序遍历（DFS：左、节点本身、右）</li><li>后序遍历（DFS：左、右、节点本身）</li><li>先序遍历（DFS：节点本身、左、右）</li></ul></li></ul></li><li><h3 id="二叉查找树（Binary-search-trees）：BSTs"><a href="#二叉查找树（Binary-search-trees）：BSTs" class="headerlink" title="二叉查找树（Binary search trees）：BSTs"></a>二叉查找树（Binary search trees）：BSTs</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=x6At0nzX92o&amp;index=1&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">二叉查找树概览（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/p82sw/core-introduction-to-binary-search-trees" target="_blank" rel="noopener">系列（视频）</a><ul><li>从符号表开始到 BST 程序</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/E7cXP/introduction" target="_blank" rel="noopener">介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9Jry5-82I68" target="_blank" rel="noopener">MIT（视频）</a></li><li>C/C++:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=COZK7NATh4k&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=28" target="_blank" rel="noopener">二叉查找树 —— 在 C/C++ 中实现（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hWokyBoo0aI&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=29" target="_blank" rel="noopener">BST 的实现 —— 在堆栈和堆中的内存分配（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Ut90klNN264&amp;index=30&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">在二叉查找树中找到最小和最大的元素（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=_pnqMz5nrRs&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=31" target="_blank" rel="noopener">寻找二叉树的高度（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9RHO6jU--GU&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=32" target="_blank" rel="noopener">二叉树的遍历 —— 广度优先和深度优先策略（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=86g8jAQug04&amp;index=33&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">二叉树：层序遍历（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gm8DUJJhmY4&amp;index=34&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">二叉树的遍历：先序、中序、后序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yEwSGhSsT0U&amp;index=35&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">判断一棵二叉树是否为二叉查找树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gcULXE7ViZw&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&amp;index=36" target="_blank" rel="noopener">从二叉查找树中删除一个节点（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=5cPbNCrdotA&amp;index=37&amp;list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P" target="_blank" rel="noopener">二叉查找树中序遍历的后继者（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 实现：<ul><li style="list-style: none"><input type="checkbox"> insert    // 往树上插值</li><li style="list-style: none"><input type="checkbox"> get_node_count // 查找树上的节点数</li><li style="list-style: none"><input type="checkbox"> print_values // 从小到大打印树中节点的值</li><li style="list-style: none"><input type="checkbox"> delete_tree</li><li style="list-style: none"><input type="checkbox"> is_in_tree // 如果值存在于树中则返回 true</li><li style="list-style: none"><input type="checkbox"> get_height // 返回节点所在的高度（如果只有一个节点，那么高度则为1）</li><li style="list-style: none"><input type="checkbox"> get_min   // 返回树上的最小值</li><li style="list-style: none"><input type="checkbox"> get_max   // 返回树上的最大值</li><li style="list-style: none"><input type="checkbox"> is_binary_search_tree</li><li style="list-style: none"><input type="checkbox"> delete_value</li><li style="list-style: none"><input type="checkbox"> get_successor // 返回给定值的后继者，若没有则返回-1</li></ul></li></ul></li><li><h3 id="堆（Heap）-优先级队列（Priority-Queue）-二叉堆（Binary-Heap）"><a href="#堆（Heap）-优先级队列（Priority-Queue）-二叉堆（Binary-Heap）" class="headerlink" title="堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）"></a>堆（Heap） / 优先级队列（Priority Queue） / 二叉堆（Binary Heap）</h3><ul><li>可视化是一棵树，但通常是以线性的形式存储（数组、链表）</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Heap_(data_structure" target="_blank" rel="noopener">堆</a>)</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/2OpTs/introduction" target="_blank" rel="noopener">介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/z3l9N/naive-implementations" target="_blank" rel="noopener">无知的实现（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/GRV2q/binary-trees" target="_blank" rel="noopener">二叉树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/supplement/S5xxz/tree-height-remark" target="_blank" rel="noopener">关于树高的讨论（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/0g1dl/basic-operations" target="_blank" rel="noopener">基本操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/gl5Ni/complete-binary-trees" target="_blank" rel="noopener">完全二叉树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/HxQo9/pseudocode" target="_blank" rel="noopener">伪代码（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/odNJmw5TOEE?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3291" target="_blank" rel="noopener">堆排序 —— 跳到起点（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/hSzMO/heap-sort" target="_blank" rel="noopener">堆排序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/dwrOS/building-a-heap" target="_blank" rel="noopener">构建一个堆（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=B7hVxCmfPtM&amp;index=4&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">MIT：堆与堆排序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yIUFT6AKBGE&amp;index=24&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B Lecture 24：优先级队列（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MiyLo8adrWw" target="_blank" rel="noopener">构建线性时间复杂度的堆（大顶堆）</a></li><li style="list-style: none"><input type="checkbox"> 实现一个大顶堆：<ul><li style="list-style: none"><input type="checkbox"> insert</li><li style="list-style: none"><input type="checkbox"> sift_up —— 用于插入元素</li><li style="list-style: none"><input type="checkbox"> get_max —— 返回最大值但不移除元素</li><li style="list-style: none"><input type="checkbox"> get_size() —— 返回存储的元素数量</li><li style="list-style: none"><input type="checkbox"> is_empty() —— 若堆为空则返回 true</li><li style="list-style: none"><input type="checkbox"> extract_max —— 返回最大值并移除</li><li style="list-style: none"><input type="checkbox"> sift_down —— 用于获取最大值元素</li><li style="list-style: none"><input type="checkbox"> remove(i) —— 删除指定索引的元素</li><li style="list-style: none"><input type="checkbox"> heapify —— 构建堆，用于堆排序</li><li style="list-style: none"><input type="checkbox"> heap_sort() —— 拿到一个未排序的数组，然后使用大顶堆进行就地排序<ul><li>注意：若用小顶堆可节省操作，但导致空间复杂度加倍。（无法做到就地）</li></ul></li></ul></li></ul></li><li><h3 id="字典树（Tries）"><a href="#字典树（Tries）" class="headerlink" title="字典树（Tries）"></a>字典树（Tries）</h3><ul><li>需要注意的是，字典树各式各样。有些有前缀，而有些则没有。有些使用字符串而不使用比特位来追踪路径。</li><li>阅读代码，但不实现。</li><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Tries" target="_blank" rel="noopener">数据结构笔记及编程技术</a></li><li style="list-style: none"><input type="checkbox"> 短课程视频：<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/08Xyf/core-introduction-to-tries" target="_blank" rel="noopener">对字典树的介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/PvlZW/core-performance-of-tries" target="_blank" rel="noopener">字典树的性能（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/DFvd3/core-implementing-a-trie" target="_blank" rel="noopener">实现一棵字典树（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.toptal.com/java/the-trie-a-neglected-data-structure" target="_blank" rel="noopener">字典树：一个被忽略的数据结构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/using-tries/" target="_blank" rel="noopener">高级编程 —— 使用字典树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TJ8SkcUSdbU" target="_blank" rel="noopener">标准教程（现实中的用例）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NinWEPPrkDQ&amp;index=16&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf" target="_blank" rel="noopener">MIT，高阶数据结构，使用字符串追踪路径（可事半功倍）</a></li></ul></li><li><h3 id="平衡查找树（Balanced-search-trees）"><a href="#平衡查找树（Balanced-search-trees）" class="headerlink" title="平衡查找树（Balanced search trees）"></a>平衡查找树（Balanced search trees）</h3><ul><li>掌握至少一种平衡查找树（并懂得如何实现）：</li><li>“在各种平衡查找树当中，AVL 树和2-3树已经成为了过去，而红黑树（red-black trees）看似变得越来越受人青睐。这种令人特别感兴趣的数据结构，亦称伸展树（splay tree）。它可以自我管理，且会使用轮换来移除任何访问过根节点的 key。” —— Skiena</li><li>因此，在各种各样的平衡查找树当中，我选择了伸展树来实现。虽然，通过我的阅读，我发现在 Google 的面试中并不会被要求实现一棵平衡查找树。但是，为了胜人一筹，我们还是应该看看如何去实现。在阅读了大量关于红黑树的代码后，我才发现伸展树的实现确实会使得各方面更为高效。<ul><li>伸展树：插入、查找、删除函数的实现，而如果你最终实现了红黑树，那么请尝试一下：</li><li>跳过删除函数，直接实现搜索和插入功能</li></ul></li><li>我希望能阅读到更多关于 B 树的资料，因为它也被广泛地应用到大型的数据库当中。</li><li><p>[ ] <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank" rel="noopener">自平衡二叉查找树</a></p></li><li><p>[ ] <strong>AVL 树</strong></p><ul><li>实际中：我能告诉你的是，该种树并无太多的用途，但我能看到有用的地方在哪里：AVL 树是另一种平衡查找树结构。其可支持时间复杂度为 O(log n) 的查询、插入及删除。它比红黑树严格意义上更为平衡，从而导致插入和删除更慢，但遍历却更快。正因如此，才彰显其结构的魅力。只需要构建一次，就可以在不重新构造的情况下读取，适合于实现诸如语言字典（或程序字典，如一个汇编程序或解释程序的操作码）。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=FNeL18KsWPc&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=6" target="_blank" rel="noopener">MIT AVL 树 / AVL 树的排序（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/Qq5E0/avl-trees" target="_blank" rel="noopener">AVL 树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/PKEBC/avl-tree-implementation" target="_blank" rel="noopener">AVL 树的实现（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/22BgE/split-and-merge" target="_blank" rel="noopener">分离与合并</a></li></ul></li><li><p>[ ] <strong>伸展树</strong></p><ul><li>实际中：伸展树一般用于缓存、内存分配者、路由器、垃圾回收者、数据压缩、ropes（字符串的一种替代品，用于存储长串的文本字符）、Windows NT（虚拟内存、网络及文件系统）等的实现。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Najzh1rYQTo&amp;index=23&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd" target="_blank" rel="noopener">CS 61B：伸展树（Splay trees）（视频）</a></li><li style="list-style: none"><input type="checkbox"> MIT 教程：伸展树（Splay trees）：<ul><li>该教程会过于学术，但请观看到最后的10分钟以确保掌握。</li><li><a href="https://www.youtube.com/watch?v=QnPl_Y6EqMo" target="_blank" rel="noopener">视频</a></li></ul></li></ul></li><li><p>[ ] <strong>2-3查找树</strong></p><ul><li>实际中：2-3树的元素插入非常快速，但却有着查询慢的代价（因为相比较 AVL 树来说，其高度更高）。</li><li>你会很少用到2-3树。这是因为，其实现过程中涉及到不同类型的节点。因此，人们更多地会选择红黑树。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=C3SsdUqasD4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=2" target="_blank" rel="noopener">2-3树的直感与定义（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iYvBtGKsqSg&amp;index=3&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">2-3树的二元观点</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TOb1tuEZ2X4&amp;index=5&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">2-3树（学生叙述）（视频）</a></li></ul></li><li><p>[ ] <strong>2-3-4树 (亦称2-4树)</strong></p><ul><li>实际中：对于每一棵2-4树，都有着对应的红黑树来存储同样顺序的数据元素。在2-4树上进行插入及删除操作等同于在红黑树上进行颜色翻转及轮换。这使得2-4树成为一种用于掌握红黑树背后逻辑的重要工具。这就是为什么许多算法引导文章都会在介绍红黑树之前，先介绍2-4树，尽管<strong>2-4树在实际中并不经常使用</strong>。</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=zqrqYXkth6Q&amp;index=26&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B Lecture 26：平衡查找树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DQdMYevEyE4&amp;index=4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">自底向上的2-4树（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2679VQ26Fp4&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=5" target="_blank" rel="noopener">自顶向下的2-4树（视频）</a></li></ul></li><li><p>[ ] <strong>B 树</strong></p><ul><li>有趣的是：为啥叫 B 仍然是一个神秘。因为 B 可代表波音（Boeing）、平衡（Balanced）或 Bayer（联合创造者）</li><li>实际中：B 树会被广泛适用于数据库中，而现代大多数的文件系统都会使用到这种树（或变种)。除了运用在数据库中，B 树也会被用于文件系统以快速访问一个文件的任意块。但存在着一个基本的问题，那就是如何将文件块 i 转换成一个硬盘块（或一个柱面-磁头-扇区）上的地址。</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">B 树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=I22wEC1tTGo&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&amp;index=6" target="_blank" rel="noopener">B 树的介绍（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=s3bCdZGrgpA&amp;index=7&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">B 树的定义及其插入操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=svfnVhJOfMc&amp;index=8&amp;list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6" target="_blank" rel="noopener">B 树的删除操作（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=V3omVLzI0WE&amp;index=7&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf" target="_blank" rel="noopener">MIT 6.851 —— 内存层次模块（Memory Hierarchy Models）（视频）</a><ul><li>覆盖有高速缓存参数无关型（cache-oblivious）B 树和非常有趣的数据结构</li><li>头37分钟讲述的很专业，或许可以跳过（B 指块的大小、即缓存行的大小）</li></ul></li></ul></li><li><p>[ ] <strong>红黑树</strong></p><ul><li>实际中：红黑树提供了在最坏情况下插入操作、删除操作和查找操作的时间保证。这些时间值的保障不仅对时间敏感型应用有用，例如实时应用，还对在其他数据结构中块的构建非常有用，而这些数据结构都提供了最坏情况下的保障；例如，许多用于计算几何学的数据结构都可以基于红黑树，而目前 Linux 系统所采用的完全公平调度器（the Completely Fair Scheduler）也使用到了该种树。在 Java 8中，红黑树也被用于存储哈希列表集合中相同的数据，而不是使用链表及哈希码。</li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/1W3x0f_RmUo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3871" target="_blank" rel="noopener">Aduni —— 算法 —— 课程4（该链接直接跳到开始部分）（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hm2GHwyKF1o&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=5" target="_blank" rel="noopener">Aduni —— 算法 —— 课程5（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank" rel="noopener">黑树（Black Tree）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/an-introduction-to-binary-search-and-red-black-trees/" target="_blank" rel="noopener">二分查找及红黑树的介绍</a></li></ul></li></ul></li><li><h3 id="N-叉树（K-叉树、M-叉树）"><a href="#N-叉树（K-叉树、M-叉树）" class="headerlink" title="N 叉树（K 叉树、M 叉树）"></a>N 叉树（K 叉树、M 叉树）</h3><ul><li>注意：N 或 K 指的是分支系数（即树的最大分支数）：<ul><li>二叉树是一种分支系数为2的树</li><li>2-3树是一种分支系数为3的树</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/K-ary_tree" target="_blank" rel="noopener">K 叉树</a></li></ul></li></ul><h2 id="排序（Sorting）"><a href="#排序（Sorting）" class="headerlink" title="排序（Sorting）"></a>排序（Sorting）</h2><ul><li><p>[ ] 笔记:</p><ul><li>实现各种排序 &amp; 知道每种排序的最坏、最好和平均的复杂度分别是什么场景:<ul><li>不要用冒泡排序 - 大多数情况下效率感人 - 时间复杂度 O(n^2), 除非 n &lt;= 16</li></ul></li><li style="list-style: none"><input type="checkbox"> 排序算法的稳定性 (“快排是稳定的么?”)<ul><li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://stackoverflow.com/questions/1517793/stability-in-sorting-algorithms" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://stackoverflow.com/questions/1517793/stability-in-sorting-algorithms" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://www.geeksforgeeks.org/stability-in-sorting-algorithms/" target="_blank" rel="noopener">排序算法的稳定性</a></li><li><a href="http://homepages.math.uic.edu/~leon/cs-mcs401-s08/handouts/stability.pdf" target="_blank" rel="noopener">排序算法 - 稳定性</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 哪种排序算法可以用链表？哪种用数组？哪种两者都可？<ul><li>并不推荐对一个链表排序，但归并排序是可行的.</li><li><a href="http://www.geeksforgeeks.org/merge-sort-for-linked-list/" target="_blank" rel="noopener">链表的归并排序</a></li></ul></li></ul></li><li><p>关于堆排序，请查看前文堆的数据结构部分。堆排序很强大，不过是非稳定排序。</p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=P00xJgWzz2c&amp;index=1&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">冒泡排序 (video)</a></p></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ni_zk257Nqo&amp;index=7&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">冒泡排序分析 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Kg4bqzAqRBM&amp;index=3&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">插入排序 &amp; 归并排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=c4BRHC7kTaQ&amp;index=2&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">插入排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=GCae1WNvnZM&amp;index=3&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">归并排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=y_G9BkAm6B8&amp;index=4&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">快排 (video)</a></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=6nDMgr0-Yyo&amp;index=8&amp;list=PL89B61F78B552C1AB" target="_blank" rel="noopener">选择排序 (video)</a></p></li><li><p>[ ] 斯坦福大学关于排序算法的视频:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ENp00xylP7c&amp;index=15&amp;list=PLFE6E58F856038C69" target="_blank" rel="noopener">课程 15 | 编程抽象 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=y4M9IVgrVKo&amp;index=16&amp;list=PLFE6E58F856038C69" target="_blank" rel="noopener">课程 16 | 编程抽象 (video)</a></li></ul></li><li><p>[ ] Shai Simonson 视频, <a href="http://www.aduni.org/" target="_blank" rel="noopener">Aduni.org</a>:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=odNJmw5TOEE&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=2" target="_blank" rel="noopener">算法 - 排序 - 第二讲 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hj8YKFTFKEE&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=3" target="_blank" rel="noopener">算法 - 排序2 - 第三讲 (video)</a></li></ul></li><li><p>[ ] Steven Skiena 关于排序的视频:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/ute-pmMkyuk?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1600" target="_blank" rel="noopener">课程从 26:46 开始 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yLvp-pB8mak&amp;index=8&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">课程从 27:40 开始 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q7K9otnzlfE&amp;index=9&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">课程从 35:00 开始 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TvqIGu9Iupw&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=10" target="_blank" rel="noopener">课程从 23:50 开始 (video)</a></li></ul></li><li><p>[ ] 加州大学伯克利分校（UC Berkeley） 大学课程:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=EiUvYS2DT6I&amp;list=PL4BBB74C7D2A1049C&amp;index=29" target="_blank" rel="noopener">CS 61B 课程 29: 排序 I (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2hTY3t80Qsk&amp;list=PL4BBB74C7D2A1049C&amp;index=30" target="_blank" rel="noopener">CS 61B 课程 30: 排序 II (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Y6LOLpxg6Dc&amp;index=32&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B 课程 32: 排序 III (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=qNMQ4ly43p4&amp;index=33&amp;list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">CS 61B 课程 33: 排序 V (video)</a></li></ul></li><li><p>[ ] - 归并排序:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/sorting/mergesort.c" target="_blank" rel="noopener">使用外部数组</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/jwasham/practice-cpp/blob/master/merge_sort/merge_sort.cc" target="_blank" rel="noopener">对原数组直接排序</a></li></ul></li><li><p>[ ] - 快速排序:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/examples/randomization/quick.c" target="_blank" rel="noopener">实现</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/jwasham/practice-c/blob/master/quick_sort/quick_sort.c" target="_blank" rel="noopener">实现</a></li></ul></li><li><p>[ ] 实现:</p><ul><li style="list-style: none"><input type="checkbox"> 归并：平均和最差情况的时间复杂度为 O(n log n)。</li><li style="list-style: none"><input type="checkbox"> 快排：平均时间复杂度为 O(n log n)。</li><li>选择排序和插入排序的最坏、平均时间复杂度都是 O(n^2)。</li><li>关于堆排序，请查看前文堆的数据结构部分。</li></ul></li><li><p>[ ] 有兴趣的话，还有一些补充 - 但并不是必须的:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#radixSort" target="_blank" rel="noopener">基数排序</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=xhr26ia4k38" target="_blank" rel="noopener">基数排序 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Nz1KZXbghj8&amp;index=7&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">基数排序, 计数排序 (线性时间内) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=cNB2lADK3_s&amp;index=8&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">随机算法: 矩阵相乘, 快排, Freivalds’ 算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=pOKy3RZbSws&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&amp;index=14" target="_blank" rel="noopener">线性时间内的排序 (video)</a></li></ul></li></ul><h2 id="图（Graphs）"><a href="#图（Graphs）" class="headerlink" title="图（Graphs）"></a>图（Graphs）</h2><p>图论能解决计算机科学里的很多问题，所以这一节会比较长，像树和排序的部分一样。</p><ul><li><p>Yegge 的笔记:</p><ul><li>有 3 种基本方式在内存里表示一个图:<ul><li>对象和指针</li><li>矩阵</li><li>邻接表</li></ul></li><li>熟悉以上每一种图的表示法，并了解各自的优缺点</li><li>宽度优先搜索和深度优先搜索 - 知道它们的计算复杂度和设计上的权衡以及如何用代码实现它们</li><li>遇到一个问题时，首先尝试基于图的解决方案，如果没有再去尝试其他的。</li></ul></li><li><p>[ ] Skiena 教授的课程 - 很不错的介绍:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=OiXxhDrFruw&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=11" target="_blank" rel="noopener">CSE373 2012 - 课程 11 - 图的数据结构 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=g5vF8jscteo&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=12" target="_blank" rel="noopener">CSE373 2012 - 课程 12 - 广度优先搜索 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=S23W6eTcqdY&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=13" target="_blank" rel="noopener">CSE373 2012 - 课程 13 - 图的算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=WitPBKGV0HY&amp;index=14&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 14 - 图的算法 (1) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ia1L30l7OIg&amp;index=15&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 15 - 图的算法 (2) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=jgDOQq6iWy8&amp;index=16&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 16 - 图的算法 (3) (video)</a></li></ul></li><li><p>[ ] 图 (复习和其他):</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Aa2sqUhIn-E&amp;index=15&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">6.006 单源最短路径问题 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2E7MmKv0Y24&amp;index=16&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">6.006 Dijkstra 算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ozsuci5pIso&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=17" target="_blank" rel="noopener">6.006 Bellman-Ford 算法(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=CHvQ3q_gJ7E&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=18" target="_blank" rel="noopener">6.006 Dijkstra 效率优化 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=i_AQT_XfvD8&amp;index=6&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">Aduni: 图的算法 I - 拓扑排序, 最小生成树, Prim 算法 -  第六课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ufj5_bppBsA&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=7" target="_blank" rel="noopener">Aduni: 图的算法 II - 深度优先搜索, 广度优先搜索, Kruskal 算法, 并查集数据结构 - 第七课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DiedsPsMKXc&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=8" target="_blank" rel="noopener">Aduni: 图的算法 III: 最短路径 - 第八课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=XIAQRlNkJAw&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=9" target="_blank" rel="noopener">Aduni: 图的算法. IV: 几何算法介绍 - 第九课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/dgjX4HdMI-Q?list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;t=3489" target="_blank" rel="noopener">CS 61B 2014 (从 58:09 开始) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=aJjlQCFwylA&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=19" target="_blank" rel="noopener">CS 61B 2014: 加权图 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=tKwnms5iRBU&amp;index=16&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">贪心算法: 最小生成树 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=RpgcYiky7uw" target="_blank" rel="noopener">图的算法之强连通分量 Kosaraju 算法 (video)</a></li></ul></li><li><p>完整的 Coursera 课程:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-on-graphs/home/welcome" target="_blank" rel="noopener">图的算法 (video)</a></li></ul></li><li><p>Yegge: 如果有机会，可以试试研究更酷炫的算法:</p><ul><li style="list-style: none"><input type="checkbox"> Dijkstra 算法 - 上文 - 6.006</li><li style="list-style: none"><input type="checkbox"> A* 算法<ul><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank" rel="noopener">A* 算法</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=KNXfSOx4eEE" target="_blank" rel="noopener">A* 寻路教程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=-L-WgKMFuhE" target="_blank" rel="noopener">A* 寻路 (E01: 算法解释) (video)</a></li></ul></li></ul></li><li><p>我会实现:</p><ul><li style="list-style: none"><input type="checkbox"> DFS 邻接表 (递归)</li><li style="list-style: none"><input type="checkbox"> DFS 邻接表 (栈迭代)</li><li style="list-style: none"><input type="checkbox"> DFS 邻接矩阵 (递归)</li><li style="list-style: none"><input type="checkbox"> DFS 邻接矩阵 (栈迭代)</li><li style="list-style: none"><input type="checkbox"> BFS 邻接表</li><li style="list-style: none"><input type="checkbox"> BFS 邻接矩阵</li><li style="list-style: none"><input type="checkbox"> 单源最短路径问题 (Dijkstra)</li><li style="list-style: none"><input type="checkbox"> 最小生成树</li><li>基于 DFS 的算法 (根据上文 Aduni 的视频):<ul><li style="list-style: none"><input type="checkbox"> 检查环 (我们会先检查是否有环存在以便做拓扑排序)</li><li style="list-style: none"><input type="checkbox"> 拓扑排序</li><li style="list-style: none"><input type="checkbox"> 计算图中的连通分支</li><li style="list-style: none"><input type="checkbox"> 列出强连通分量</li><li style="list-style: none"><input type="checkbox"> 检查双向图</li></ul></li></ul></li></ul><p>可以从 Skiena 的书（参考下面的书推荐小节）和面试书籍中学习更多关于图的实践。</p><h2 id="更多知识"><a href="#更多知识" class="headerlink" title="更多知识"></a>更多知识</h2><ul><li><h3 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h3><ul><li style="list-style: none"><input type="checkbox"> Stanford 大学关于递归 &amp; 回溯的课程:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gl3emqCuueQ&amp;list=PLFE6E58F856038C69&amp;index=8" target="_blank" rel="noopener">课程 8 | 抽象编程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=uFJhEPrbycQ&amp;list=PLFE6E58F856038C69&amp;index=9" target="_blank" rel="noopener">课程 9 | 抽象编程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NdF1QDTRkck&amp;index=10&amp;list=PLFE6E58F856038C69" target="_blank" rel="noopener">课程 10 | 抽象编程 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=p-gpaIGRCQI&amp;list=PLFE6E58F856038C69&amp;index=11" target="_blank" rel="noopener">课程 11 | 抽象编程 (video)</a></li></ul></li><li>什么时候适合使用</li><li>尾递归会更好么?<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.quora.com/What-is-tail-recursion-Why-is-it-so-bad" target="_blank" rel="noopener">什么是尾递归以及为什么它如此糟糕?</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=L1jjXGfxozc" target="_blank" rel="noopener">尾递归 (video)</a></li></ul></li></ul></li><li><h3 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h3><ul><li><strong>注意</strong> ：动态规划是门极为重要的技术，尽管其并未被 Google 提供的准备手册提及，但你可能会对寻求最佳解的方式有点疑问，所以我将其列入这份表单。</li><li>这一部分会有点困难，每个可以用动态规划解决的问题都必须先定义出递推关系，要推导出来可能会有点棘手。</li><li><p>我建议先阅读和学习足够多的动态规划的例子，以便对解决 DP 问题的一般模式有个扎实的理解。</p></li><li><p>[ ] 视频:</p><ul><li>Skiena 的视频可能会有点难跟上，有时候他用白板写的字会比较小，难看清楚。</li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/Qc2ieXRgR0k?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1718" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 19 - 动态规划介绍 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/IsmMhMdyeGY?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=2749" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 20 - 编辑距离 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/o0V9eYF4UI8?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=406" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 21 - 动态规划举例 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=dRbMC1Ltl3A&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=22" target="_blank" rel="noopener">Skiena: CSE373 2012 - 课程 22 - 动态规划应用 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/J5aJEcOr6Eo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3558" target="_blank" rel="noopener">Simonson: 动态规划 0 (starts at 59:18) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=0EzHjQ_SOeU&amp;index=11&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">Simonson: 动态规划 I - 课程 11 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=v1qiRwuJU7g&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=12" target="_blank" rel="noopener">Simonson: 动态规划 II - 课程 12 (video)</a></li><li style="list-style: none"><input type="checkbox"> 单独的 DP 问题 (每一个视频都很短):<br>  <a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr" target="_blank" rel="noopener">动态规划 (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Yale 课程笔记:<ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#dynamicProgramming" target="_blank" rel="noopener">动态规划</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Coursera 课程:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/80RrW/the-rna-secondary-structure-problem" target="_blank" rel="noopener">RNA 二级结构问题 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/PSonq/a-dynamic-programming-algorithm" target="_blank" rel="noopener">动态规划算法 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/oUEK2/illustrating-the-dp-algorithm" target="_blank" rel="noopener">DP 算法描述 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/nfK2r/running-time-of-the-dp-algorithm" target="_blank" rel="noopener">DP 算法的运行时间 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/M999a/dp-vs-recursive-implementation" target="_blank" rel="noopener">DP vs 递归实现 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/UZ7o6/global-pairwise-sequence-alignment" target="_blank" rel="noopener">全局成对序列排列 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithmic-thinking-2/lecture/WnNau/local-pairwise-sequence-alignment" target="_blank" rel="noopener">本地成对序列排列 (video)</a></li></ul></li></ul></li><li><h3 id="组合（Combinatorics）-n-中选-k-个-amp-概率（Probability）"><a href="#组合（Combinatorics）-n-中选-k-个-amp-概率（Probability）" class="headerlink" title="组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）"></a>组合（Combinatorics） (n 中选 k 个) &amp; 概率（Probability）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8RRo6Ti9d0U" target="_blank" rel="noopener">数据技巧: 如何找出阶乘、排列和组合(选择) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=sZkAAk9Wwa4" target="_blank" rel="noopener">来点学校的东西: 概率 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=dNaJg-mLobQ" target="_blank" rel="noopener">来点学校的东西: 概率和马尔可夫链 (video)</a></li><li style="list-style: none"><input type="checkbox"> 可汗学院:<ul><li>课程设置:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/math/probability/probability-and-combinatorics-topic" target="_blank" rel="noopener">概率理论基础</a></li></ul></li><li>视频 - 41 (每一个都短小精悍):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=uzkc-qNVoOk&amp;list=PLC58778F28211FA19" target="_blank" rel="noopener">概率解释 (video)</a></li></ul></li></ul></li></ul></li><li><h3 id="NP-NP-完全和近似算法"><a href="#NP-NP-完全和近似算法" class="headerlink" title="NP, NP-完全和近似算法"></a>NP, NP-完全和近似算法</h3><ul><li>知道最经典的一些 NP 完全问题，比如旅行商问题和背包问题,<br>  而且能在面试官试图忽悠你的时候识别出他们。</li><li>知道 NP 完全是什么意思.</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=moPtwq_cVH8&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=23" target="_blank" rel="noopener">计算复杂度 (video)</a></li><li style="list-style: none"><input type="checkbox"> Simonson:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=2939" target="_blank" rel="noopener">贪心算法. II &amp; 介绍 NP-完全性 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=e0tGC6ZQdQE&amp;index=16&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">NP-完全性 II &amp; 归约 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=fCX1BGT3wjE&amp;index=17&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">NP-完全性 III (Video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NKLDp3Rch3M&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=18" target="_blank" rel="noopener">NP-完全性 IV (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Skiena:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/KiK5TVgXbFg?list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;t=1508" target="_blank" rel="noopener">CSE373 2012 - 课程 23 - 介绍 NP-完全性 IV (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=27Al52X3hd4&amp;index=24&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 24 - NP-完全性证明 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=xCPH4gwIIXM&amp;index=25&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b" target="_blank" rel="noopener">CSE373 2012 - 课程 25 - NP-完全性挑战 (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=eHZifpgyH_4&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=22" target="_blank" rel="noopener">复杂度: P, NP, NP-完全性, 规约 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MEz1J9wY2iM&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=24" target="_blank" rel="noopener">复杂度: 近视算法 Algorithms (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=4q-jmGrmxKs&amp;index=25&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">复杂度: 固定参数算法 (video)</a></li><li>Peter Norvik 讨论旅行商问题的近似最优解:<ul><li><a href="http://nbviewer.jupyter.org/url/norvig.com/ipython/TSP.ipynb" target="_blank" rel="noopener">Jupyter 笔记本</a></li></ul></li><li>《算法导论》的第 1048 - 1140 页。</li></ul></li><li><h3 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h3><ul><li style="list-style: none"><input type="checkbox"> LRU 缓存:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=R5ON3iwx78M" target="_blank" rel="noopener">LRU 的魔力 (100 Days of Google Dev) (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=bq6N7Ym81iI" target="_blank" rel="noopener">实现 LRU (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8-FZRAjR7qU" target="_blank" rel="noopener">LeetCode - 146 LRU Cache (C++) (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> CPU 缓存:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=vjYF_fAZI5E&amp;list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-&amp;index=24" target="_blank" rel="noopener">MIT 6.004 L15: 存储体系 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ajgC3-pyGlk&amp;index=25&amp;list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-" target="_blank" rel="noopener">MIT 6.004 L16: 缓存的问题 (video)</a></li></ul></li></ul></li><li><h3 id="进程（Processe）和线程（Thread）"><a href="#进程（Processe）和线程（Thread）" class="headerlink" title="进程（Processe）和线程（Thread）"></a>进程（Processe）和线程（Thread）</h3><ul><li style="list-style: none"><input type="checkbox"> 计算机科学 162 - 操作系统 (25 个视频):<ul><li>视频 1-11 是关于进程和线程</li><li><a href="https://www.youtube.com/playlist?list=PL-XXv-cvA_iBDyz-ba4yDskqMDY6A1w_c" target="_blank" rel="noopener">操作系统和系统编程 (video)</a></li></ul></li><li><a href="https://www.quora.com/What-is-the-difference-between-a-process-and-a-thread" target="_blank" rel="noopener">进程和线程的区别是什么?</a></li><li>涵盖了:<ul><li>进程、线程、协程<ul><li>进程和线程的区别</li><li>进程</li><li>线程</li><li>锁</li><li>互斥</li><li>信号量</li><li>监控</li><li>他们是如何工作的</li><li>死锁</li><li>活锁</li></ul></li><li>CPU 活动, 中断, 上下文切换</li><li>现代多核处理器的并发式结构</li><li>进程资源需要（内存：代码、静态存储器、栈、堆、文件描述符、I/O）</li><li>线程资源需要（在同一个进程内和其他线程共享以上的资源，但是每个线程都有独立的程序计数器、栈计数器、寄存器和栈）</li><li>Fork 操作是真正的写时复制（只读），直到新的进程写到内存中，才会生成一份新的拷贝。</li><li>上下文切换<ul><li>操作系统和底层硬件是如何初始化上下文切换的。</li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M" target="_blank" rel="noopener">C++ 的线程 (系列 - 10 个视频)</a></li><li style="list-style: none"><input type="checkbox"> Python 的协程 (视频):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL1H1sBF1VAKVMONJWJkmUh6_p8g4F2oy1" target="_blank" rel="noopener">线程系列</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Bs7vPNbB9JM" target="_blank" rel="noopener">Python 线程</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Obt-vMVdM8s" target="_blank" rel="noopener">理解 Python 的 GIL (2010)</a><ul><li><a href="http://www.dabeaz.com/GIL" target="_blank" rel="noopener">参考</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MCs5OvhV9S4" target="_blank" rel="noopener">David Beazley - Python 协程 - PyCon 2015</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ZzfHjytDceU" target="_blank" rel="noopener">Keynote David Beazley - 兴趣主题 (Python 异步 I/O)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=0zaPs8OtyKY" target="_blank" rel="noopener">Python 中的互斥</a></li></ul></li></ul></li></ul><pre><code>系统设计以及可伸缩性，要把软硬件的伸缩性设计的足够好有很多的东西要考虑，所以这是个包含非常多内容和资源的大主题。需要花费相当多的时间在这个主题上。</code></pre><ul><li><h3 id="系统设计、可伸缩性、数据处理"><a href="#系统设计、可伸缩性、数据处理" class="headerlink" title="系统设计、可伸缩性、数据处理"></a>系统设计、可伸缩性、数据处理</h3><ul><li>Yegge 的注意事项:<ul><li>伸缩性<ul><li>把大数据集提取为单一值</li><li>大数据集转换</li><li>处理大量的数据集</li></ul></li><li>系统<ul><li>特征集</li><li>接口</li><li>类层次结构</li><li>在特定的约束下设计系统</li><li>轻量和健壮性</li><li>权衡和折衷</li><li>性能分析和优化</li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> <strong>从这里开始</strong>: <a href="http://www.hiredintech.com/system-design/" target="_blank" rel="noopener">HiredInTech：系统设计</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.quora.com/How-do-I-prepare-to-answer-design-questions-in-a-technical-interview?redirected_qid=1500023" target="_blank" rel="noopener">该如何为技术面试里设计方面的问题做准备?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://blog.gainlo.co/index.php/2015/10/22/8-things-you-need-to-know-before-system-design-interviews/" target="_blank" rel="noopener">在系统设计面试前必须知道的 8 件事</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.hiredintech.com/algorithm-design/" target="_blank" rel="noopener">算法设计</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=UrYLYV7WSHM" target="_blank" rel="noopener">数据库范式 - 1NF, 2NF, 3NF and 4NF (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://github.com/checkcheckzz/system-design-interview" target="_blank" rel="noopener">系统设计面试</a> - 这一部分有很多的资源，浏览一下我放在下面的文章和例子。</li><li style="list-style: none"><input type="checkbox"> <a href="http://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/" target="_blank" rel="noopener">如何在系统设计面试中脱颖而出</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://everythingisdata.wordpress.com/2009/10/17/numbers-everyone-should-know/" target="_blank" rel="noopener">每个人都该知道的一些数字</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html" target="_blank" rel="noopener">上下文切换操作会耗费多少时间?</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=srOgpXECblk" target="_blank" rel="noopener">跨数据中心的事务 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/" target="_blank" rel="noopener">简明 CAP 理论介绍</a></li><li style="list-style: none"><input type="checkbox"> Paxos 一致性算法:<ul><li><a href="https://www.youtube.com/watch?v=s8JqcZtvnsM" target="_blank" rel="noopener">时间很短</a></li><li><a href="https://www.youtube.com/watch?v=JEpsBg0AO6o" target="_blank" rel="noopener">用例 和 multi-paxos</a></li><li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener">论文</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.tom-e-white.com/2007/11/consistent-hashing.html" target="_blank" rel="noopener">一致性哈希</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html" target="_blank" rel="noopener">NoSQL 模式</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=OkC7HKtiZC0&amp;list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc" target="_blank" rel="noopener">OOSE: UML 2.0 系列 (video)</a></li><li style="list-style: none"><input type="checkbox"> OOSE: 使用 UML 和 Java 开发软件 (21 videos):<ul><li>如果你对 OO 都深刻的理解和实践，可以跳过这部分。</li><li><a href="https://www.youtube.com/playlist?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">OOSE: 使用 UML 和 Java 开发软件</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 面向对象编程的 SOLID 原则:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=TMuno5RZNeE" target="_blank" rel="noopener">Bob Martin 面向对象的 SOLID 原则和敏捷设计 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL8m4NUhTQU48oiGCSgCP1FiJEcg_xJzyQ" target="_blank" rel="noopener">C# SOLID 设计模式 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PL4CE9F710017EA77A" target="_blank" rel="noopener">SOLID 原则 (video)</a></li><li style="list-style: none"><input type="checkbox"> S - <a href="http://www.oodesign.com/single-responsibility-principle.html" target="_blank" rel="noopener">单一职责原则</a> | <a href="http://www.javacodegeeks.com/2011/11/solid-single-responsibility-principle.html" target="_blank" rel="noopener">每个对象的单一职责</a><ul><li><a href="https://docs.google.com/open?id=0ByOwmqah_nuGNHEtcU5OekdDMkk" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> O - <a href="http://www.oodesign.com/open-close-principle.html" target="_blank" rel="noopener">开闭原则</a>  | <a href="https://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="noopener">生产环境里的对象应该为扩展做准备而不是为更改</a><ul><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> L - <a href="http://www.oodesign.com/liskov-s-substitution-principle.html" target="_blank" rel="noopener">里氏代换原则</a> | <a href="http://stackoverflow.com/questions/56860/what-is-the-liskov-substitution-principle" target="_blank" rel="noopener">基类和继承类遵循 ‘IS A’ 原则</a><ul><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgNzAzZjA5ZmItNjU3NS00MzQ5LTkwYjMtMDJhNDU5ZTM0MTlh&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> I - <a href="http://www.oodesign.com/interface-segregation-principle.html" target="_blank" rel="noopener">接口隔离原则</a> | 客户端被迫实现用不到的接口<ul><li><a href="https://www.youtube.com/watch?v=3CtAfl7aXAQ" target="_blank" rel="noopener">5 分钟讲解接口隔离原则 (video)</a></li><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgOTViYjJhYzMtMzYxMC00MzFjLWJjMzYtOGJiMDc5N2JkYmJi&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li><li style="list-style: none"><input type="checkbox"> D -<a href="http://www.oodesign.com/dependency-inversion-principle.html" target="_blank" rel="noopener">依赖反转原则</a> | 减少对象里的依赖。<ul><li><a href="http://stackoverflow.com/questions/62539/what-is-the-dependency-inversion-principle-and-why-is-it-important" target="_blank" rel="noopener">什么是依赖倒置以及它为什么重要</a></li><li><a href="http://docs.google.com/a/cleancoder.com/viewer?a=v&amp;pid=explorer&amp;chrome=true&amp;srcid=0BwhCYaYDn8EgMjdlMWIzNGUtZTQ0NC00ZjQ5LTkwYzQtZjRhMDRlNTQ3ZGMz&amp;hl=en" target="_blank" rel="noopener">更多</a></li></ul></li></ul></li><li style="list-style: none"><input type="checkbox"> 可伸缩性:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=-W9F__D3oY4" target="_blank" rel="noopener">很棒的概述 (video)</a></li><li style="list-style: none"><input type="checkbox"> 简短系列:<ul><li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="noopener">克隆</a></li><li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database" target="_blank" rel="noopener">数据库</a></li><li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache" target="_blank" rel="noopener">缓存</a></li><li><a href="http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism" target="_blank" rel="noopener">异步</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.aosabook.org/en/distsys.html" target="_blank" rel="noopener">可伸缩的 Web 架构和分布式系统</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://pages.cs.wisc.edu/~zuyu/files/fallacies.pdf" target="_blank" rel="noopener">错误的分布式系统解释</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html" target="_blank" rel="noopener">实用编程技术</a><ul><li><a href="http://horicky.blogspot.com/2010/07/google-pregel-graph-processing.html" target="_blank" rel="noopener">extra: Google Pregel 图形处理</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=modXC5IWTJI" target="_blank" rel="noopener">Jeff Dean - 在 Goolge 构建软件系统 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://lethain.com/introduction-to-architecting-systems-for-scale/" target="_blank" rel="noopener">可伸缩系统架构设计介绍</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9nWyWwY2Onc" target="_blank" rel="noopener">使用 App Engine 和云存储扩展面向全球用户的手机游戏架构实践(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=H4vMcD7zKM0" target="_blank" rel="noopener">How Google Does Planet-Scale Engineering for Planet-Scale Infra (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/the-importance-of-algorithms/" target="_blank" rel="noopener">算法的重要性</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html" target="_blank" rel="noopener">分片</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.infoq.com/presentations/Scale-at-Facebook" target="_blank" rel="noopener">Facebook 系统规模扩展实践 (2009)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oodS71YtkGU" target="_blank" rel="noopener">Facebook 系统规模扩展实践 (2012), “为 10 亿用户构建” (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=p0jGmgIrf_M&amp;list=PLRXxvay_m8gqVlExPC5DG3TGWJTaBgqSA&amp;index=4" target="_blank" rel="noopener">Long Game 工程实践 - Astrid Atkinson Keynote(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2012/3/26/7-years-of-youtube-scalability-lessons-in-30-minutes.html" target="_blank" rel="noopener">30 分钟看完 YouTuBe 7 年系统扩展经验</a><ul><li><a href="https://www.youtube.com/watch?v=G-lGCC4KKok" target="_blank" rel="noopener">video</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/8/15/how-paypal-scaled-to-billions-of-transactions-daily-using-ju.html" target="_blank" rel="noopener">PayPal 如何用 8 台虚拟机扛住 10 亿日交易量系统</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://blog.clevertap.com/how-to-remove-duplicates-in-large-datasets/" target="_blank" rel="noopener">如何对大数据集去重</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=3vV4YiqKm1o" target="_blank" rel="noopener">Etsy 的扩展和工程文化探究 Jon Cowie (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://thenewstack.io/led-amazon-microservices-architecture/" target="_blank" rel="noopener">是什么造就了 Amazon 自己的微服务架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://eng.uber.com/trip-data-squeeze/" target="_blank" rel="noopener">压缩还是不压缩，是 Uber 面临的问题</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/3/3/asyncio-tarantool-queue-get-in-the-queue.html" target="_blank" rel="noopener">异步 I/O Tarantool 队列</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/25/when-should-approximate-query-processing-be-used.html" target="_blank" rel="noopener">什么时候应该用近视查询处理?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/23/googles-transition-from-single-datacenter-to-failover-to-a-n.html" target="_blank" rel="noopener">Google 从单数据中心到故障转移, 到本地多宿主架构的演变</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2012/9/24/google-spanners-most-surprising-revelation-nosql-is-out-and.html" target="_blank" rel="noopener">Spanner</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/15/egnyte-architecture-lessons-learned-in-building-and-scaling.html" target="_blank" rel="noopener">Egnyte: 构建和扩展 PB 级分布式系统架构的经验教训</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/7/6/machine-learning-driven-programming-a-new-programming-for-a.html" target="_blank" rel="noopener">机器学习驱动的编程: 新世界的新编程方式</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/6/15/the-image-optimization-technology-that-serves-millions-of-re.html" target="_blank" rel="noopener">日服务数百万请求的图像优化技术</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/2/1/a-patreon-architecture-short.html" target="_blank" rel="noopener">Patreon 架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/27/tinder-how-does-one-of-the-largest-recommendation-engines-de.html" target="_blank" rel="noopener">Tinder: 推荐引擎是如何决定下一个你将会看到谁的?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/25/design-of-a-modern-cache.html" target="_blank" rel="noopener">现代缓存设计</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/13/live-video-streaming-at-facebook-scale.html" target="_blank" rel="noopener">Facebook 实时视频流扩展</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2016/1/11/a-beginners-guide-to-scaling-to-11-million-users-on-amazons.html" target="_blank" rel="noopener">在 Amazon AWS 上把服务扩展到 1100 万量级的新手教程</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2015/12/16/how-does-the-use-of-docker-effect-latency.html" target="_blank" rel="noopener">对延时敏感的应用是否应该使用 Docker?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2015/12/14/does-amp-counter-an-existential-threat-to-google.html" target="_blank" rel="noopener">AMP（Accelerated Mobile Pages）的存在是对 Google 的威胁么?</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2015/11/9/a-360-degree-view-of-the-entire-netflix-stack.html" target="_blank" rel="noopener">360 度解读 Netflix 技术栈</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/latency-everywhere-and-it-costs-you-sales-how-crush-it" target="_blank" rel="noopener">延迟无处不在 - 如何搞定它？</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://martinfowler.com/articles/serverless.html" target="_blank" rel="noopener">无服务器架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances" target="_blank" rel="noopener">是什么驱动着 Instagram: 上百个实例、几十种技术</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html" target="_blank" rel="noopener">Cinchcast 架构 - 每天处理 1500 小时的音频</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html" target="_blank" rel="noopener">Justin.Tv 实时视频播放架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html" target="_blank" rel="noopener">Playfish’s 社交游戏架构 - 每月五千万用户增长</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html" target="_blank" rel="noopener">猫途鹰架构 - 40 万访客, 200 万动态页面访问, 30TB 数据</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/plentyoffish-architecture" target="_blank" rel="noopener">PlentyOfFish 架构</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html" target="_blank" rel="noopener">Salesforce 架构 - 如何扛住 13 亿日交易量</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html" target="_blank" rel="noopener">ESPN’s 架构扩展</a></li><li style="list-style: none"><input type="checkbox"> 下面 『消息、序列化和消息系统』部分的内容会提到什么样的技术能把各种服务整合到一起</li><li style="list-style: none"><input type="checkbox"> Twitter:<ul><li><a href="https://www.youtube.com/watch?v=5cKTP36HVgI" target="_blank" rel="noopener">O’Reilly MySQL CE 2011: Jeremy Cole, “Big and Small Data at @Twitter” (video)</a></li><li><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability" target="_blank" rel="noopener">时间线的扩展</a></li></ul></li><li>更多内容可以查看视频部分的『大规模数据挖掘』视频系列。</li></ul></li><li style="list-style: none"><input type="checkbox"> 系统设计问题练习：下面有一些指导原则，每一个都有相关文档以及在现实中该如何处理。<ul><li>复习: <a href="http://www.hiredintech.com/system-design/" target="_blank" rel="noopener">HiredInTech 的系统设计</a></li><li><a href="https://github.com/jwasham/coding-interview-university/blob/master/extras/cheat%20sheets/system-design.pdf" target="_blank" rel="noopener">cheat sheet</a></li><li>流程:<ol><li>理解问题和范围:<ul><li>在面试官的帮助下定义用例</li><li>提出附加功能的建议</li><li>去掉面试官认定范围以外的内容</li><li>假定高可用是必须的，而且要作为一个用例</li></ul></li><li>考虑约束:<ul><li>问一下每月请求量</li><li>问一下每秒请求量 (他们可能会主动提到或者让你算一下)</li><li>评估读写所占的百分比</li><li>评估的时候牢记 2/8 原则</li><li>每秒写多少数据</li><li>总的数据存储量要考虑超过 5 年的情况</li><li>每秒读多少数据</li></ul></li><li>抽象设计:<ul><li>分层 (服务, 数据, 缓存)</li><li>基础设施: 负载均衡, 消息</li><li>粗略的概括任何驱动整个服务的关键算法</li><li>考虑瓶颈并指出解决方案</li></ul></li></ol></li><li>练习:<ul><li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;context=compsci" target="_blank" rel="noopener">设计一个 CDN 网络</a></li><li><a href="https://blog.twitter.com/2010/announcing-snowflake" target="_blank" rel="noopener">设计一个随机唯一 ID 生成系统</a></li><li><a href="http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html" target="_blank" rel="noopener">设计一个在线多人卡牌游戏</a></li><li><a href="http://www.slideshare.net/dvirsky/introduction-to-redis" target="_blank" rel="noopener">设计一个 key-value 数据库</a></li><li><a href="https://icmi.cs.ucsb.edu/research/tech_reports/reports/2005-23.pdf" target="_blank" rel="noopener">设计一个函数获取过去某个时间段内前 K 个最高频访问的请求</a></li><li><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html" target="_blank" rel="noopener">设计一个图片分享系统</a></li><li><a href="http://ijcai13.org/files/tutorial_slides/td3.pdf" target="_blank" rel="noopener">设计一个推荐系统</a></li><li><a href="http://www.hiredintech.com/system-design/the-system-design-process/" target="_blank" rel="noopener">设计一个短域名生成系统</a></li><li><a href="https://www.adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="noopener">设计一个缓存系统</a></li></ul></li></ul></li></ul></li><li><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><ul><li>有 Google 的论文和一些知名的论文.</li><li>你很可能实在没时间一篇篇完整的读完他们。我建议可以有选择的读其中一些论文里的核心部分。</li><li style="list-style: none"><input type="checkbox"> <a href="http://spinroot.com/courses/summer/Papers/hoare_1978.pdf" target="_blank" rel="noopener">1978: 通信顺序处理</a><ul><li><a href="https://godoc.org/github.com/thomas11/csp" target="_blank" rel="noopener">Go 实现</a></li><li><a href="https://www.cs.cmu.edu/~crary/819-f09/" target="_blank" rel="noopener">喜欢经典的论文?</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf" target="_blank" rel="noopener">2003: The Google 文件系统</a><ul><li>2012 年被 Colossus 取代了</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">2004: MapReduce: Simplified Data Processing on Large Clusters</a><ul><li>大多被云数据流取代了?</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.akkadia.org/drepper/cpumemory.pdf" target="_blank" rel="noopener">2007: 每个程序员都应该知道的内存知识 (非常长，作者建议跳过某些章节来阅读)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.wired.com/2012/07/google-colossus/" target="_blank" rel="noopener">2012: Google 的 Colossus</a><ul><li>没有论文</li></ul></li><li style="list-style: none"><input type="checkbox"> 2012: AddressSanitizer: 快速的内存访问检查器:<ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/37752.pdf" target="_blank" rel="noopener">论文</a></li><li><a href="https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany" target="_blank" rel="noopener">视频</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 2013: Spanner: Google 的分布式数据库:<ul><li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf" target="_blank" rel="noopener">论文</a></li><li><a href="https://www.usenix.org/node/170855" target="_blank" rel="noopener">视频</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43146.pdf" target="_blank" rel="noopener">2014: Machine Learning: The High-Interest Credit Card of Technical Debt</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43790.pdf" target="_blank" rel="noopener">2015: Continuous Pipelines at Google</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44686.pdf" target="_blank" rel="noopener">2015: 大规模高可用: 构建 Google Ads 的数据基础设施</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://download.tensorflow.org/paper/whitepaper2015.pdf" target="_blank" rel="noopener">2015: TensorFlow: 异构分布式系统上的大规模机器学习</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43835.pdf" target="_blank" rel="noopener">2015: 开发者应该如何搜索代码：用例学习</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf" target="_blank" rel="noopener">2016: Borg, Omega, and Kubernetes</a></li></ul></li><li><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>涵盖了:<ul><li>单元测试是如何工作的</li><li>什么是模拟对象</li><li>什么是集成测试</li><li>什么是依赖注入</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=SAhJf36_u5U" target="_blank" rel="noopener">James Bach 讲敏捷软件测试 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ILkT_HV9DVU" target="_blank" rel="noopener">James Bach 软件测试公开课 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://vimeo.com/83960706" target="_blank" rel="noopener">Steve Freeman - 测试驱动的开发 (video)</a><ul><li><a href="http://gotocon.com/dl/goto-berlin-2013/slides/SteveFreeman_TestDrivenDevelopmentThatsNotWhatWeMeant.pdf" target="_blank" rel="noopener">slides</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html" target="_blank" rel="noopener">测试驱动的开发已死。测试不朽。</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=z9quxZsLcfo" target="_blank" rel="noopener">测试驱动的开发已死? (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=nzJapzxH_rE&amp;list=PLAwxTw4SYaPkWVHeC_8aSIbSxE_NXI76g" target="_blank" rel="noopener">视频系列 (152 个) - 并不都是必须 (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.obeythetestinggoat.com/pages/book.html#toc" target="_blank" rel="noopener">Python：测试驱动的 Web 开发</a></li><li style="list-style: none"><input type="checkbox"> 依赖注入:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=IKD2-MAkXyQ" target="_blank" rel="noopener">视频</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://jasonpolites.github.io/tao-of-testing/ch3-1.1.html" target="_blank" rel="noopener">测试之道</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://jasonpolites.github.io/tao-of-testing/ch4-1.1.html" target="_blank" rel="noopener">如何编写测试</a></li></ul></li><li><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul><li>在操作系统中是如何运作的</li><li>在操作系统部分的视频里有很多资料</li></ul></li><li><h3 id="实现系统例程"><a href="#实现系统例程" class="headerlink" title="实现系统例程"></a>实现系统例程</h3><ul><li>理解你使用的系统 API 底层有什么</li><li>你能自己实现它们么?</li></ul></li><li><h3 id="字符串搜索和操作"><a href="#字符串搜索和操作" class="headerlink" title="字符串搜索和操作"></a>字符串搜索和操作</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/tAfHI/search-pattern-in-text" target="_blank" rel="noopener">文本的搜索模式 (video)</a></li><li style="list-style: none"><input type="checkbox"> Rabin-Karp (videos):<ul><li><a href="https://www.coursera.org/learn/data-structures/lecture/c0Qkw/rabin-karps-algorithm" target="_blank" rel="noopener">Rabin Karps 算法</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/nYrc8/optimization-precomputation" target="_blank" rel="noopener">预先计算的优化</a></li><li><a href="https://www.coursera.org/learn/data-structures/lecture/h4ZLc/optimization-implementation-and-analysis" target="_blank" rel="noopener">优化: 实现和分析</a></li><li><a href="https://www.youtube.com/watch?v=BRO7mVIFt08&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=9" target="_blank" rel="noopener">Table Doubling, Karp-Rabin</a></li><li><a href="https://www.youtube.com/watch?v=w6nuXg0BISo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=32" target="_blank" rel="noopener">滚动哈希</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Knuth-Morris-Pratt (KMP) 算法:<ul><li><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="noopener">Pratt 算法</a></li><li><a href="https://www.youtube.com/watch?v=2ogqPWJSftE" target="_blank" rel="noopener">教程: Knuth-Morris-Pratt (KMP) 字符串匹配算法</a></li></ul></li><li style="list-style: none"><input type="checkbox"> Boyer–Moore 字符串搜索算法<ul><li><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" target="_blank" rel="noopener">Boyer-Moore字符串搜索算法</a></li><li><a href="https://www.youtube.com/watch?v=QDZpzctPf10" target="_blank" rel="noopener">Boyer-Moore-Horspool 高级字符串搜索算法 (video)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/algorithms-on-strings/home/week/1" target="_blank" rel="noopener">Coursera: 字符串的算法</a></li></ul></li></ul><hr><h2 id="终面"><a href="#终面" class="headerlink" title="终面"></a>终面</h2><pre><code>这一部分有一些短视频，你可以快速的观看和复习大多数重要概念。这对经常性的巩固很有帮助。</code></pre><h4 id="综述"><a href="#综述" class="headerlink" title="综述:"></a>综述:</h4><ul><li style="list-style: none"><input type="checkbox"> 2-3 分钟的短视频系列 (23 个)<ul><li><a href="https://www.youtube.com/watch?v=r4r1DZcx1cM&amp;list=PLmVb1OknmNJuC5POdcDv5oCS7_OUkDgpj&amp;index=22" target="_blank" rel="noopener">Videos</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 2-5 分钟的短视频系列 - Michael Sambol (18 个):<ul><li><a href="https://www.youtube.com/channel/UCzDJwLWoYCUQowF_nG3m5OQ" target="_blank" rel="noopener">Videos</a></li></ul></li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序:"></a>排序:</h4><ul><li style="list-style: none"><input type="checkbox"> 归并排序: <a href="https://www.youtube.com/watch?v=GCae1WNvnZM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=GCae1WNvnZM</a></li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><h3 id="Google-Coaching-里提到的"><a href="#Google-Coaching-里提到的" class="headerlink" title="Google Coaching 里提到的"></a>Google Coaching 里提到的</h3><p><strong>阅读并做练习:</strong></p><ul><li><p>[ ] 算法设计手册 (Skiena)</p><ul><li>书 (Kindle 上可以租到):<ul><li><a href="http://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202" target="_blank" rel="noopener">Algorithm Design Manual</a></li></ul></li><li>Half.com 是一个资源丰富且性价比很高的在线书店.</li><li>答案:<ul><li><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/The_Algorithms_Design_Manual_(Second_Edition" target="_blank" rel="noopener">解答</a>)</li><li><a href="http://blog.panictank.net/category/algorithmndesignmanualsolutions/page/2/" target="_blank" rel="noopener">解答</a></li></ul></li><li><p><a href="http://www3.cs.stonybrook.edu/~skiena/algorist/book/errata" target="_blank" rel="noopener">勘误表</a></p><p>read and do exercises from the books below. Then move to coding challenges (further down below)<br>一旦你理解了每日计划里的所有内容，就去读上面所列的书并完成练习，然后开始读下面所列的书并做练习，之后就可以开始实战写代码了（本文再往后的部分）</p></li></ul></li></ul><p><strong>首先阅读:</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-047012167X.html" target="_blank" rel="noopener">Programming Interviews Exposed: Secrets to Landing Your Next Job, 2nd Edition</a></li></ul><p><strong>然后阅读 (这本获得了很多推荐， 但是不在 Google coaching 的文档里):</strong></p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.amazon.com/Cracking-Coding-Interview-6th-Programming/dp/0984782850/" target="_blank" rel="noopener">Cracking the Coding Interview, 6th Edition</a><ul><li>如果你看到有人在看 “The Google Resume”, 实际上它和 “Cracking the Coding Interview” 是同一个作者写的，而且后者是升级版。</li></ul></li></ul><h3 id="附加书单"><a href="#附加书单" class="headerlink" title="附加书单"></a>附加书单</h3><p>这些没有被 Google 推荐阅读，不过我因为需要这些背景知识所以也把它们列在了这里。</p><ul><li><p>[ ] C Programming Language, Vol 2</p><ul><li><a href="https://github.com/lekkas/c-algorithms" target="_blank" rel="noopener">练习的答案</a></li></ul></li><li><p>[ ] C++ Primer Plus, 6th Edition</p></li><li><p>[ ] <a href="http://product.half.ebay.com/The-UNIX-Programming-Environment-by-Brian-W-Kernighan-and-Rob-Pike-1983-Other/54385&amp;tg=info" target="_blank" rel="noopener">《Unix 环境高级编程》 The Unix Programming Environment</a></p></li><li><p>[ ] <a href="http://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880" target="_blank" rel="noopener">《编程珠玑》 Programming Pearls</a></p></li><li><p>[ ] <a href="http://www.amazon.com/Algorithms-Programming-Solutions-Alexander-Shen/dp/0817638474" target="_blank" rel="noopener">Algorithms and Programming: Problems and Solutions</a></p></li></ul><h3 id="如果你有时间"><a href="#如果你有时间" class="headerlink" title="如果你有时间"></a>如果你有时间</h3><ul><li><p>[ ] <a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844" target="_blank" rel="noopener">Introduction to Algorithms</a></p></li><li><p>[ ] <a href="https://www.amazon.com/Elements-Programming-Interviews-Insiders-Guide/dp/1479274836" target="_blank" rel="noopener">Elements of Programming Interviews</a></p><ul><li>如果你希望在面试里用 C++ 写代码，这本书的代码全都是 C++ 写的</li><li>通常情况下能找到解决方案的好书.</li></ul></li></ul><h2 id="编码练习和挑战"><a href="#编码练习和挑战" class="headerlink" title="编码练习和挑战"></a>编码练习和挑战</h2><p>一旦你学会了理论基础，就应该把它们拿出来练练。<br>尽量坚持每天做编码练习，越多越好。</p><p>编程问题预备:</p><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.hiredintech.com/algorithm-design/" target="_blank" rel="noopener">不错的介绍 (摘自 System Design 章节): 算法设计:</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/how-to-find-a-solution/" target="_blank" rel="noopener">如何找到解决方案</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/how-to-dissect-a-topcoder-problem-statement/" target="_blank" rel="noopener">如何剖析 Topcoder 题目描述</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/mathematics-for-topcoders/" target="_blank" rel="noopener">Topcoders 里用到的数学</a></li><li><p>[ ] <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/dynamic-programming-from-novice-to-advanced/" target="_blank" rel="noopener">动态规划 – 从入门到精通</a></p></li><li><p><a href="https://courses.csail.mit.edu/iap/interview/materials.php" target="_blank" rel="noopener">MIT 面试材料</a></p></li><li><p><a href="http://exercism.io/languages" target="_blank" rel="noopener">针对编程语言本身的练习</a></p></li></ul><p>编码练习平台:</p><ul><li><a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a></li><li><a href="https://www.topcoder.com/" target="_blank" rel="noopener">TopCoder</a></li><li><a href="https://projecteuler.net/index.php?section=problems" target="_blank" rel="noopener">Project Euler (数学方向为主)</a></li><li><a href="http://www.codewars.com" target="_blank" rel="noopener">Codewars</a></li><li><a href="https://www.hackerrank.com/" target="_blank" rel="noopener">HackerRank</a></li><li><a href="https://codility.com/programmers/" target="_blank" rel="noopener">Codility</a></li><li><a href="https://www.interviewcake.com/" target="_blank" rel="noopener">InterviewCake</a></li><li><p><a href="https://www.interviewbit.com/invite/icjf" target="_blank" rel="noopener">InterviewBit</a></p></li><li><p><a href="http://www.gainlo.co/" target="_blank" rel="noopener">模拟大公司的面试</a></p></li></ul><h2 id="当你临近面试时"><a href="#当你临近面试时" class="headerlink" title="当你临近面试时"></a>当你临近面试时</h2><ul><li style="list-style: none"><input type="checkbox"> 搞定代码面试 (videos):<ul><li><a href="https://www.youtube.com/watch?v=4NIb9l3imAo" target="_blank" rel="noopener">Cracking The Code Interview</a></li><li><a href="https://www.youtube.com/watch?v=Eg5-tdAwclo" target="_blank" rel="noopener">Cracking the Coding Interview - 全栈系列</a></li><li><a href="https://www.youtube.com/watch?v=1fqxMuPmGak" target="_blank" rel="noopener">Ask Me Anything: Gayle Laakmann McDowell (Cracking the Coding Interview 的作者)</a></li></ul></li></ul><h2 id="你的简历"><a href="#你的简历" class="headerlink" title="你的简历"></a>你的简历</h2><ul><li><a href="http://steve-yegge.blogspot.co.uk/2007_09_01_archive.html" target="_blank" rel="noopener">10 条小贴士让你写出一份还算不错的简历</a></li><li>这是搞定面试的第一个关键步骤</li></ul><h2 id="当面试来临的时候"><a href="#当面试来临的时候" class="headerlink" title="当面试来临的时候"></a>当面试来临的时候</h2><pre><code>随着下面列举的问题思考下你可能会遇到的 20 个面试问题每个问题准备 2-3 种回答准备点故事，不要只是摆一些你完成的事情的数据，相信我，人人都喜欢听故事</code></pre><ul><li>你为什么想得到这份工作？</li><li>你解决过的最有难度的问题是什么？</li><li>面对过的最大挑战是什么?</li><li>见过的最好或者最坏的设计是怎么样的?</li><li>对某项 Google 产品提出改进建议。</li><li>你作为一个个体同时也是团队的一员，如何达到最好的工作状态?</li><li>你的什么技能或者经验是你的角色中不可或缺的?为什么？</li><li>你在某份工作或某个项目中最享受的是什么?</li><li>你在某份工作或某个项目中面临过的最大挑战是什么?</li><li>你在某份工作或某个项目中遇到过的最蛋疼的 Bug 是什么样的？</li><li>你在某份工作或某个项目中学到了什么？</li><li>你在某份工作或某个项目中哪些地方还可以做的更好？</li></ul><h2 id="问面试官的问题"><a href="#问面试官的问题" class="headerlink" title="问面试官的问题"></a>问面试官的问题</h2><pre><code>我会问的一些：(可能我已经知道了答案但我想听听面试官的看法或者了解团队的前景):</code></pre><ul><li>团队多大规模?</li><li>开发周期是怎样的? 会使用瀑布流/极限编程/敏捷开发么?</li><li>经常会为 deadline 加班么? 或者是有弹性的?</li><li>团队里怎么做技术选型?</li><li>每周平均开多少次会?</li><li>你觉得工作环境有助于员工集中精力吗?</li><li>目前正在做什么工作?</li><li>喜欢这些事情吗?</li><li>工作期限是怎么样的?</li></ul><h2 id="当你获得了梦想的职位"><a href="#当你获得了梦想的职位" class="headerlink" title="当你获得了梦想的职位"></a>当你获得了梦想的职位</h2><p>我还能说些什么呢，恭喜你！</p><ul><li><a href="https://medium.com/@moonstorming/10-things-i-wish-i-knew-on-my-first-day-at-google-107581d87286#.livxn7clw" target="_blank" rel="noopener">我希望在 Google 的第一天就知道的 10 件事</a></li></ul><p>坚持继续学习。</p><p>得到这份工作只是一个开始。</p><hr><pre><code>**********************************************************************************************************************************************************************************************************下面的内容都是可选的。这些是我的推荐，不是 Google 的。通过学习这些内容，你将会得到更多的有关 CS 的概念，并将为所有的软件工程工作做更好的准备。**********************************************************************************************************************************************************************************************************</code></pre><hr><h2 id="附加的学习"><a href="#附加的学习" class="headerlink" title="附加的学习"></a>附加的学习</h2><ul><li><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.joelonsoftware.com/articles/Unicode.html" target="_blank" rel="noopener">每一个软件开发者的绝对最低限度，必须要知道的关于 Unicode 和字符集知识</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://kunststube.net/encoding/" target="_blank" rel="noopener">关于处理文本需要的编码和字符集, 每个程序员绝对需要知道的知识</a></li></ul></li><li><h3 id="字节顺序"><a href="#字节顺序" class="headerlink" title="字节顺序"></a>字节顺序</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Data/endian.html" target="_blank" rel="noopener">大、小端字节序</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=JrNF0KRAlyo" target="_blank" rel="noopener">大端字节 Vs 小端字节(视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oBSuXP-1Tc0" target="_blank" rel="noopener">大、小端字节序的里里外外(Big And Little Endian Inside/Out) (视频)</a><ul><li>内核开发者的讨论非常技术性，如果大多数都超出了你的理解范围，不要太担心。</li><li>前半段已经足够了。</li></ul></li></ul></li><li><h3 id="Emacs-and-vi-m"><a href="#Emacs-and-vi-m" class="headerlink" title="Emacs and vi(m)"></a>Emacs and vi(m)</h3><ul><li>Yegge 的建议，从一个很早以前的亚马逊招聘信息中而来：熟悉基于 unix 的代码编辑器</li><li>vi(m):<ul><li><a href="https://www.youtube.com/watch?v=5givLEMcINQ&amp;index=1&amp;list=PL13bz4SHGmRxlZVmWQ9DvXo1fEg4UdGkr" target="_blank" rel="noopener">使用 vim 进行编辑 01 - 安装, 设置和模式 (视频)</a></li><li><a href="http://vim-adventures.com/" target="_blank" rel="noopener">VIM 的冒险之旅</a></li><li>4 个视频集:<ul><li><a href="https://www.youtube.com/watch?v=SI8TeVMX8pk" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 1</a></li><li><a href="https://www.youtube.com/watch?v=F3OO7ZIOaJE" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 2</a></li><li><a href="https://www.youtube.com/watch?v=1lYD5gwgZIA" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 4</a></li><li><a href="https://www.youtube.com/watch?v=ZYEccA_nMaI" target="_blank" rel="noopener">vi/vim 编辑器 - 课程 3</a></li></ul></li><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Using_Vi_instead_of_Emacs" target="_blank" rel="noopener">使用 Vi 而不是 Emacs</a></li></ul></li><li>emacs:<ul><li><a href="https://www.youtube.com/watch?v=hbmV1bnQ-i0" target="_blank" rel="noopener">基础 Emacs 教程 (视频)</a></li><li>3 个视频集:<ul><li><a href="https://www.youtube.com/watch?v=ujODL7MD04Q" target="_blank" rel="noopener">Emacs 教程 (初学者) -第 1 部分- 文件命令, 剪切/复制/粘贴,  自定义命令</a></li><li><a href="https://www.youtube.com/watch?v=XWpsRupJ4II" target="_blank" rel="noopener">Emacs 教程 (初学者 -第 2 部分- Buffer 管理, 搜索, M-x grep 和 rgrep 模式</a></li><li><a href="https://www.youtube.com/watch?v=paSgzPso-yc" target="_blank" rel="noopener">Emacs 教程 (初学者 -第 3 部分- 表达式, 声明, ~/.emacs 文件和包机制</a></li></ul></li><li><a href="https://www.youtube.com/watch?v=JWD1Fpdd4Pc" target="_blank" rel="noopener">Evil 模式: 或许, 我是怎样对 Emacs 路人转粉的 (视频)</a></li><li><a href="http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Writing_C_programs_with_Emacs" target="_blank" rel="noopener">使用 Emacs 开发 C 程序</a></li><li><a href="https://www.youtube.com/watch?v=nsGYet02bEk" target="_blank" rel="noopener">(或许) 深度组织模式:管理结构 (视频)</a></li></ul></li></ul></li><li><h3 id="Unix-命令行工具"><a href="#Unix-命令行工具" class="headerlink" title="Unix 命令行工具"></a>Unix 命令行工具</h3><ul><li>下列内容中的优秀工具由的 Yegge 推荐，Yegge 目前致力于 Amazon 人事招聘处。</li><li style="list-style: none"><input type="checkbox"> bash</li><li style="list-style: none"><input type="checkbox"> cat</li><li style="list-style: none"><input type="checkbox"> grep</li><li style="list-style: none"><input type="checkbox"> sed</li><li style="list-style: none"><input type="checkbox"> awk</li><li style="list-style: none"><input type="checkbox"> curl or wget</li><li style="list-style: none"><input type="checkbox"> sort</li><li style="list-style: none"><input type="checkbox"> tr</li><li style="list-style: none"><input type="checkbox"> uniq</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Strace" target="_blank" rel="noopener">strace</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="noopener">tcpdump</a></li></ul></li><li><h3 id="信息资源-视频"><a href="#信息资源-视频" class="headerlink" title="信息资源 (视频)"></a>信息资源 (视频)</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/informationtheory" target="_blank" rel="noopener">Khan Academy 可汗学院</a></li><li style="list-style: none"><input type="checkbox"> 更多有关马尔可夫的内容:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/waxgx/core-markov-text-generation" target="_blank" rel="noopener">Core Markov Text Generation马尔可夫内容生成</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/gZhiC/core-implementing-markov-text-generation" target="_blank" rel="noopener">Core Implementing Markov Text Generation马尔可夫内容生成补充</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures-optimizing-performance/lecture/EUjrq/project-markov-text-generation-walk-through" target="_blank" rel="noopener">Project = Markov Text Generation Walk Through一个马尔可夫内容生成器的项目</a></li></ul></li><li>关于更多信息，请参照下方 MIT 6.050J 信息和系统复杂度的内容.</li></ul></li><li><h3 id="奇偶校验位-amp-汉明码-视频"><a href="#奇偶校验位-amp-汉明码-视频" class="headerlink" title="奇偶校验位 &amp; 汉明码 (视频)"></a>奇偶校验位 &amp; 汉明码 (视频)</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q-3BctoUpHE" target="_blank" rel="noopener">入门</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DdMcAUlxh1M" target="_blank" rel="noopener">奇偶校验位</a></li><li style="list-style: none"><input type="checkbox"> 汉明码(Hamming Code):<ul><li><a href="https://www.youtube.com/watch?v=1A_NcXxdoCc" target="_blank" rel="noopener">发现错误</a></li><li><a href="https://www.youtube.com/watch?v=JAMLuxdHH8o" target="_blank" rel="noopener">修正错误</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=wbH2VxzmoZk" target="_blank" rel="noopener">检查错误</a></li></ul></li><li><h3 id="系统熵值（系统复杂度）"><a href="#系统熵值（系统复杂度）" class="headerlink" title="系统熵值（系统复杂度）"></a>系统熵值（系统复杂度）</h3><ul><li>请参考下方视频</li><li>观看之前，请先确定观看了信息论的视频</li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/JnJq3Py0dyM?t=176" target="_blank" rel="noopener">信息理论, 克劳德·香农, 熵值, 系统冗余, 数据比特压缩 (视频)</a></li></ul></li><li><h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><ul><li>请参考下方视频</li><li>观看之前，请先确定观看了信息论的视频</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/密码学" target="_blank" rel="noopener">可汗学院</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=KqqOXndnvic&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=30" target="_blank" rel="noopener">密码学: 哈希函数</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=9TNI2wHmaeI&amp;index=31&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">密码学: 加密</a></li></ul></li><li><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul><li>观看之前，请先确定观看了信息论的视频</li><li style="list-style: none"><input type="checkbox"> 压缩 (视频):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Lto-ajuqW3w" target="_blank" rel="noopener">压缩</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=M5c_RFKVkko" target="_blank" rel="noopener">压缩熵值</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=umTbivyJoiI" target="_blank" rel="noopener">由上而下的树 (霍夫曼编码树)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=DV8efuB3h2g" target="_blank" rel="noopener">额外比特 - 霍夫曼编码树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=goOa3DGezUA" target="_blank" rel="noopener">优雅的压缩数据 (无损数据压缩方法)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=cCDCfoHTsaU" target="_blank" rel="noopener">Text Compression Meets Probabilities</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIJGErt5rrCqaSGTMyyqNt2H" target="_blank" rel="noopener">数据压缩的艺术</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=whGwm0Lky2s" target="_blank" rel="noopener">(可选) 谷歌开发者: GZIP 还差远了呢!</a></li></ul></li><li><h3 id="网络-视频"><a href="#网络-视频" class="headerlink" title="网络 (视频)"></a>网络 (视频)</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.khanacademy.org/computing/computer-science/internet-intro" target="_blank" rel="noopener">可汗学院</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Vdc8TCESIg8" target="_blank" rel="noopener">网络传输协议中的数据压缩</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=e5DEVa9eSN0" target="_blank" rel="noopener">TCP/IP 和 OSI 模型解析!</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=nomyRJehhnM" target="_blank" rel="noopener">TCP/IP 教程：传输数据包.</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=WGJrLqtX7As" target="_blank" rel="noopener">HTTP</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=S2iBR2ZlZf0" target="_blank" rel="noopener">SSL 和 HTTPS</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Rp3iZUvXWlM" target="_blank" rel="noopener">SSL/TLS</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=E9FxNzv1Tr8" target="_blank" rel="noopener">HTTP 2.0</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLEbnTDJUr_IegfoqO4iPnPYQui46QqT0j" target="_blank" rel="noopener">视频</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=t5xYI0jzOf4" target="_blank" rel="noopener">子网络解密 - 第五部分 经典内部域名指向 CIDR 标记</a></li></ul></li><li><h3 id="计算机安全"><a href="#计算机安全" class="headerlink" title="计算机安全"></a>计算机安全</h3><ul><li><a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">MIT</a><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=GqmQg-cszw4&amp;index=1&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">威胁模型：入门</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=6bwzNg5qQ0o&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=2" target="_blank" rel="noopener">控制攻击</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=drQyrzRoRiA&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=3" target="_blank" rel="noopener">缓冲数据注入和防御</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=6SIJmoE9L9g&amp;index=4&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">优先权区分</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8VqTSY-11F4&amp;index=5&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">能力</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=VEV74hwASeU&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh&amp;index=6" target="_blank" rel="noopener">在沙盒中运行原生代码</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=chkFBigodIw&amp;index=7&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络安全模型</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=EBQIGy1ROLY&amp;index=8&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络安全应用</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=yRVZPvHYHzw&amp;index=9&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">标志化执行</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=SIEVvk3NVuk&amp;index=11&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络安全</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=QOtA76ga_fY&amp;index=12&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">网络协议</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=PuVMkSEcPiI&amp;index=15&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">旁路攻击</a></li></ul></li></ul></li><li><h3 id="释放缓存"><a href="#释放缓存" class="headerlink" title="释放缓存"></a>释放缓存</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=StdfeXaKGEc&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=25" target="_blank" rel="noopener">Java 释放缓存; 片段化数据 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLO9y7hOkmmSGTy5z6HZ-W4k2y8WXF7Bff" target="_blank" rel="noopener">编译器 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iHVs_HkjdmI" target="_blank" rel="noopener">Python 释放缓存 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.infoq.com/presentations/garbage-collection-benefits" target="_blank" rel="noopener">深度解析：论释放缓存在 JAVA 中的重要性</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=P-8Z0-MhdQs&amp;list=PLdzf4Clw0VbOEWOS_sLhT_9zaiQDrS5AR&amp;index=3" target="_blank" rel="noopener">深度解析：论释放缓存在 Python 中的重要性(视频)</a></li></ul></li><li><h3 id="并行-并发编程"><a href="#并行-并发编程" class="headerlink" title="并行/并发编程"></a>并行/并发编程</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/parprog1/home/week/1" target="_blank" rel="noopener">Coursera (Scala)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=uY85GkaYzBk" target="_blank" rel="noopener">论并行/并发编程如何提高 Python 执行效率 (视频)</a></li></ul></li><li><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=3cmzqZzwNDM&amp;list=PLGLfVvz_LVvQ5G-LdJ8RLqe-ndo7QITYc&amp;index=3" target="_blank" rel="noopener">UML统一建模语言概览 (视频)</a></li><li style="list-style: none"><input type="checkbox"> 主要有如下的设计模式:<ul><li style="list-style: none"><input type="checkbox"> s(strategy)</li><li style="list-style: none"><input type="checkbox"> singleton</li><li style="list-style: none"><input type="checkbox"> adapter</li><li style="list-style: none"><input type="checkbox"> prototype</li><li style="list-style: none"><input type="checkbox"> decorator</li><li style="list-style: none"><input type="checkbox"> visitor</li><li style="list-style: none"><input type="checkbox"> factory, abstract factory</li><li style="list-style: none"><input type="checkbox"> facade</li><li style="list-style: none"><input type="checkbox"> observer</li><li style="list-style: none"><input type="checkbox"> proxy</li><li style="list-style: none"><input type="checkbox"> delegate</li><li style="list-style: none"><input type="checkbox"> command</li><li style="list-style: none"><input type="checkbox"> state</li><li style="list-style: none"><input type="checkbox"> memento</li><li style="list-style: none"><input type="checkbox"> iterator</li><li style="list-style: none"><input type="checkbox"> composite</li><li style="list-style: none"><input type="checkbox"> flyweight</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/LAP2A80Ajrg?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO&amp;t=3344" target="_blank" rel="noopener">第六章 (第 1 部分 ) - 设计模式 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=U8-PGsjvZc4&amp;index=12&amp;list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">第六章 (第 2 部分 ) - Abstraction-Occurrence, General Hierarchy, Player-Role, Singleton, Observer, Delegation (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=7sduBHuex4c&amp;index=13&amp;list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">第六章 (第 3 部分 ) - Adapter, Facade, Immutable, Read-Only Interface, Proxy (video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLF206E906175C7E07" target="_blank" rel="noopener">视频</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124" target="_blank" rel="noopener">Head First 设计模型</a><ul><li>尽管这本书叫做设计模式：重复使用模块，但是我还是认为Head First是对于新手来说很不错的书。</li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://sourcemaking.com/design-patterns-and-tips" target="_blank" rel="noopener">基于实际操作对于入门开发者的建议</a></li></ul></li><li><h3 id="信息传输-序列化-和队列化的系统"><a href="#信息传输-序列化-和队列化的系统" class="headerlink" title="信息传输, 序列化,和队列化的系统"></a>信息传输, 序列化,和队列化的系统</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://thrift.apache.org/" target="_blank" rel="noopener">Thrift</a><ul><li><a href="http://thrift-tutorial.readthedocs.io/en/latest/intro.html" target="_blank" rel="noopener">教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">协议缓冲</a><ul><li><a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener">教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.grpc.io/" target="_blank" rel="noopener">gRPC</a><ul><li><a href="https://www.youtube.com/watch?v=5tmPvSe7xXQ&amp;list=PLcTqM9n_dieN0k1nSeN36Z_ppKnvMJoly&amp;index=1" target="_blank" rel="noopener">gRPC 对于JAVA开发者的入门教程（视频）</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://redis.io/" target="_blank" rel="noopener">Redis</a><ul><li><a href="http://try.redis.io/" target="_blank" rel="noopener">教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://aws.amazon.com/sqs/" target="_blank" rel="noopener">Amazon的 SQS 系统 (队列)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://aws.amazon.com/sns/" target="_blank" rel="noopener">Amazon的 SNS 系统 (pub-sub)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.rabbitmq.com/" target="_blank" rel="noopener">RabbitMQ</a><ul><li><a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">入门教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.celeryproject.org/" target="_blank" rel="noopener">Celery</a><ul><li><a href="http://docs.celeryproject.org/en/latest/getting-started/first-steps-with-celery.html" target="_blank" rel="noopener">Celery入门</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://zeromq.org/" target="_blank" rel="noopener">ZeroMQ</a><ul><li><a href="http://zeromq.org/intro:read-the-manual" target="_blank" rel="noopener">入门教程</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="http://activemq.apache.org/" target="_blank" rel="noopener">ActiveMQ</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://kafka.apache.org/documentation.html#introduction" target="_blank" rel="noopener">Kafka</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://msgpack.org/index.html" target="_blank" rel="noopener">MessagePack</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://avro.apache.org/" target="_blank" rel="noopener">Avro</a></li></ul></li><li><h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="http://www.askamathematician.com/2012/09/q-what-is-a-fourier-transform-what-is-it-used-for/" target="_blank" rel="noopener">什么是傅立叶变换？论傅立叶变换的用途</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Xxut2PN-V8Q" target="_blank" rel="noopener">什么是傅立叶变换？ (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=iTMn0Kt18tg&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=4" target="_blank" rel="noopener">关于 FFT 的不同观点 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/" target="_blank" rel="noopener">FTT 是什么</a></li></ul></li><li><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul><li>给一个布隆过滤器m比特和k个哈希函数，所有的注入和相关测试都会是通过。</li><li><a href="https://www.youtube.com/watch?v=-SuTGoFYjZs" target="_blank" rel="noopener">布隆过滤器</a></li><li><a href="https://www.youtube.com/watch?v=qBTdukbzc78" target="_blank" rel="noopener">布隆过滤器 | 数据挖掘 | Stanford University</a></li><li><a href="http://billmill.org/bloomfilter-tutorial/" target="_blank" rel="noopener">教程</a></li><li><a href="http://blog.michaelschmatz.com/2016/04/11/how-to-write-a-bloom-filter-cpp/" target="_blank" rel="noopener">如何写一个布隆过滤器应用</a></li></ul></li><li><h3 id="van-Emde-Boas-树"><a href="#van-Emde-Boas-树" class="headerlink" title="van Emde Boas 树"></a>van Emde Boas 树</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=hmReJCupbNU&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=6" target="_blank" rel="noopener">争论: van Emde Boas 树 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2012/lecture-notes/MIT6_046JS12_lec15.pdf" target="_blank" rel="noopener">MIT课堂笔记</a></li></ul></li><li><h3 id="更深入的数据结构"><a href="#更深入的数据结构" class="headerlink" title="更深入的数据结构"></a>更深入的数据结构</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/zksIj9O8_jc?list=PL4BBB74C7D2A1049C&amp;t=950" target="_blank" rel="noopener">CS 61B 第 39 课: 更深入的数据结构</a></li></ul></li><li><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><ul><li>“有一种非常迷幻的数据类型” - Skiena</li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2g9OSRKJuzM&amp;index=10&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">随机化: 跳表 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank" rel="noopener">更生动详细的解释</a></li></ul></li><li><h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=v1VgJmkEJW0" target="_blank" rel="noopener">5分钟简析Ford-Fulkerson (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=v1VgJmkEJW0" target="_blank" rel="noopener">Ford-Fulkerson 算法 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2vhN4Ice5jI" target="_blank" rel="noopener">网络流 (视频)</a></li></ul></li><li><h3 id="不相交集-amp-联合查找"><a href="#不相交集-amp-联合查找" class="headerlink" title="不相交集 &amp; 联合查找"></a>不相交集 &amp; 联合查找</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="noopener">不相交集</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MAEGXTwmUsI&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd&amp;index=21" target="_blank" rel="noopener">UCB 61B - 不相交集; 排序 &amp; 选择(视频)</a></li><li style="list-style: none"><input type="checkbox"> Coursera (not needed since the above video explains it great):<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/JssSY/overview" target="_blank" rel="noopener">概览</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/EM5D0/naive-implementations" target="_blank" rel="noopener">初级实践</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/Mxu0w/trees" target="_blank" rel="noopener">树状结构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/qb4c2/union-by-rank" target="_blank" rel="noopener">合并树状结构</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/Q9CVI/path-compression" target="_blank" rel="noopener">路径压缩</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/data-structures/lecture/GQQLN/analysis-optional" target="_blank" rel="noopener">分析选项</a></li></ul></li></ul></li><li><h3 id="快速处理数学"><a href="#快速处理数学" class="headerlink" title="快速处理数学"></a>快速处理数学</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=eCaXlAaN2uE&amp;index=11&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">整数运算, Karatsuba 乘法 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ru7mWZJlRQg" target="_blank" rel="noopener">中国剩余定理 (在密码学中的使用) (视频)</a></li></ul></li><li><h3 id="树堆-Treap"><a href="#树堆-Treap" class="headerlink" title="树堆 (Treap)"></a>树堆 (Treap)</h3><ul><li>一个二叉搜索树和一个堆的组合</li><li style="list-style: none"><input type="checkbox"> <a href="https://en.wikipedia.org/wiki/Treap" target="_blank" rel="noopener">树堆</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=6podLUYinH8" target="_blank" rel="noopener">数据结构：树堆的讲解(video)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.cs.cmu.edu/~scandal/papers/treaps-spaa98.pdf" target="_blank" rel="noopener">集合操作的应用(Applications in set operations)</a></li></ul></li><li><h3 id="线性规划（Linear-Programming）（视频）"><a href="#线性规划（Linear-Programming）（视频）" class="headerlink" title="线性规划（Linear Programming）（视频）"></a>线性规划（Linear Programming）（视频）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=M4K6HYLHREQ" target="_blank" rel="noopener">线性规划</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=2ACJ9ewUC6U" target="_blank" rel="noopener">寻找最小成本</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=8AA_81xI3ik" target="_blank" rel="noopener">寻找最大值</a></li></ul></li><li><h3 id="几何：凸包（Geometry-Convex-hull）（视频）"><a href="#几何：凸包（Geometry-Convex-hull）（视频）" class="headerlink" title="几何：凸包（Geometry, Convex hull）（视频）"></a>几何：凸包（Geometry, Convex hull）（视频）</h3><ul><li style="list-style: none"><input type="checkbox"> <a href="https://youtu.be/XIAQRlNkJAw?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;t=3164" target="_blank" rel="noopener">Graph Alg. IV: 几何算法介绍 - 第 9 课</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=J5aJEcOr6Eo&amp;index=10&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm" target="_blank" rel="noopener">Graham &amp; Jarvis: 几何算法 - 第 10 课</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=EzeYI7p9MjU&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=2" target="_blank" rel="noopener">Divide &amp; Conquer: 凸包, 中值查找</a></li></ul></li><li><h3 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h3><ul><li>查看下面的视频：(这里没看到视频= =）</li></ul></li><li><h3 id="机器学习（Machine-Learning）"><a href="#机器学习（Machine-Learning）" class="headerlink" title="机器学习（Machine Learning）"></a>机器学习（Machine Learning）</h3><ul><li style="list-style: none"><input type="checkbox"> 为什么学习机器学习？<ul><li style="list-style: none"><input type="checkbox"> <a href="https://backchannel.com/how-google-is-remaking-itself-as-a-machine-learning-first-company-ada63defcb70" target="_blank" rel="noopener">谷歌如何将自己改造成一家「机器学习优先」公司？</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=QSaZGT4-6EY" target="_blank" rel="noopener">智能计算机系统的大规模深度学习 (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=X769cyzBNVw" target="_blank" rel="noopener">Peter Norvig：深度学习和理解与软件工程和验证的对比</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Ja2hxBAwG_0" target="_blank" rel="noopener">谷歌云机器学习工具（视频）</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIIuiBfYad6rFYQU_jL2ryal" target="_blank" rel="noopener">谷歌开发者机器学习清单 (Scikit Learn 和 Tensorflow) (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oZikw5k_2FM" target="_blank" rel="noopener">Tensorflow (视频)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.tensorflow.org/versions/r0.11/tutorials/index.html" target="_blank" rel="noopener">Tensorflow 教程</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.analyticsvidhya.com/blog/2016/04/neural-networks-python-theano/" target="_blank" rel="noopener">Python 实现神经网络实例教程（使用 Theano）</a></li><li>课程:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">很棒的初级课程：机器学习</a><pre><code>- [视频教程](https://www.youtube.com/playlist?list=PLZ9qNFMHZ-A4rycgrgOYma6zxF4BZGGPW)- 看第 12-18 集复习线性代数（第 14 集和第 15 集是重复的）</code></pre></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.coursera.org/learn/neural-networks" target="_blank" rel="noopener">机器学习中的神经网络</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.udacity.com/course/deep-learning--ud730" target="_blank" rel="noopener">Google 深度学习微学位</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.udacity.com/course/machine-learning-engineer-nanodegree-by-google--nd009" target="_blank" rel="noopener">Google/Kaggle 机器学习工程师微学位</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.udacity.com/drive" target="_blank" rel="noopener">无人驾驶工程师微学位</a></li><li style="list-style: none"><input type="checkbox"> <a href="http://www.thisismetis.com/explore-data-science" target="_blank" rel="noopener">Metis 在线课程 (两个月 99 美元)</a></li></ul></li><li>资源:<ul><li>书籍: Data Science from Scratch: First Principles with Python: <a href="https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X" target="_blank" rel="noopener">https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X</a></li><li>网站: Data School: <a href="http://www.dataschool.io/" target="_blank" rel="noopener">http://www.dataschool.io/</a></li></ul></li></ul></li><li><h3 id="Go-语言"><a href="#Go-语言" class="headerlink" title="Go 语言"></a>Go 语言</h3><ul><li style="list-style: none"><input type="checkbox"> 视频:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=FTl0tl9BGdc" target="_blank" rel="noopener">为什么学习 Go 语言？</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=CF9S4QZuV30" target="_blank" rel="noopener">Go 语言编程</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ytEkHepK08c" target="_blank" rel="noopener">Go 语言之旅</a></li></ul></li><li style="list-style: none"><input type="checkbox"> 书籍:<ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.golang-book.com/books/intro" target="_blank" rel="noopener">Go 语言编程入门 (免费在线阅读)</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440" target="_blank" rel="noopener">Go 语言圣经 (Donovan &amp; Kernighan)</a></li></ul></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.golang-book.com/guides/bootcamp" target="_blank" rel="noopener">Go 语言新手训练营</a></li></ul></li></ul><p>–</p><h2 id="一些主题的额外内容"><a href="#一些主题的额外内容" class="headerlink" title="一些主题的额外内容"></a>一些主题的额外内容</h2><pre><code>我为前面提到的某些主题增加了一些额外的内容，之所以没有直接添加到前面，是因为这样很容易导致某个主题内容过多。毕竟你想在本世纪找到一份工作，对吧？</code></pre><ul><li><p>[ ] <strong>动态规划的更多内容</strong> (视频)</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=OQ5jsbhAv_M&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=19" target="_blank" rel="noopener">6.006: 动态规划 I: 斐波那契数列, 最短路径</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ENyox7kNKeY&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=20" target="_blank" rel="noopener">6.006: 动态规划 II: 文本匹配, 二十一点/黑杰克</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=ocZMDMZwhCY&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;index=21" target="_blank" rel="noopener">6.006: 动态规划 III: 最优加括号方式, 最小编辑距离, 背包问题</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=tp4_UXaVyx8&amp;index=22&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb" target="_blank" rel="noopener">6.006: 动态规划 IV: 吉他指法，拓扑，超级马里奥.</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=Tw1k46ywN6E&amp;index=14&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">6.046: 动态规划: 动态规划进阶</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=NzgFUwOaoIw&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=15" target="_blank" rel="noopener">6.046: 动态规划: 所有点对最短路径</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=krZI60lKPek&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=12" target="_blank" rel="noopener">6.046: 动态规划: 更多示例</a></li></ul></li><li><p>[ ] <strong>图形处理进阶</strong> (视频)</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=mUBmcbbJNf4&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=27" target="_blank" rel="noopener">异步分布式算法: 对称性破缺，最小生成树</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=kQ-UQAzcnzA&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&amp;index=28" target="_blank" rel="noopener">异步分布式算法: 最小生成树</a></li></ul></li><li><p>[ ] MIT <strong>概率论</strong> (mathy, and go slowly, which is good for mathy things) (视频):</p><ul><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=SmFwFdESMHI&amp;index=18&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 概率论概述</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=E6FbvM-FGZ8&amp;index=19&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 条件概率 Probability</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=l1BCv3qqW4A&amp;index=20&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 独立</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=MOfhhFaQdjw&amp;list=PLB7540DEDD482705B&amp;index=21" target="_blank" rel="noopener">MIT 6.042J - 随机变量</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=gGlMSe7uEkA&amp;index=22&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 期望 I</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=oI9fMUqgfxY&amp;index=23&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 期望 II</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=q4mwO2qS2z4&amp;index=24&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J - 大偏差</a></li><li style="list-style: none"><input type="checkbox"> <a href="https://www.youtube.com/watch?v=56iFMY8QW2k&amp;list=PLB7540DEDD482705B&amp;index=25" target="_blank" rel="noopener">MIT 6.042J - 随机游走</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=oDniZCmNmNw&amp;list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&amp;index=19" target="_blank" rel="noopener">Simonson: 近似算法 (视频)</a></p></li></ul><h2 id="视频系列"><a href="#视频系列" class="headerlink" title="视频系列"></a>视频系列</h2><p> 坐下来享受一下吧。”netflix and skill” :P</p><ul><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr" target="_blank" rel="noopener">个人的动态规划问题列表 (都是短视频哟)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL038BE01D3BAEFDB0" target="_blank" rel="noopener">x86 架构，汇编，应用程序 (11 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLE7DDD91010BC51F8" target="_blank" rel="noopener">MIT 18.06 线性代数，2005 年春季 (35 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL3B08AE665AB9002A" target="_blank" rel="noopener">绝妙的 MIT 微积分：单变量微积分</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL-XXv-cvA_iD8wQm8U0gG_Z1uHjImKXFy" target="_blank" rel="noopener">计算机科学 70, 001 - 2015 年春季 - 离散数学和概率理论</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL3o9D4Dl2FJ9q0_gtFXPh_H4POI5dK0yG" target="_blank" rel="noopener">离散数学 (19 个视频)</a></p></li><li><p>[ ] CSE373 - 算法分析 (25 个视频)</p><ul><li><a href="https://www.youtube.com/watch?v=ZFjhkohHdAA&amp;list=PLOtl7M3yp-DV69F32zdK7YJcNXpTunF2b&amp;index=1" target="_blank" rel="noopener">Skiena 的算法设计手册讲座</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=mFPmKGIrQs4&amp;list=PL-XXv-cvA_iAlnI-BQr9hjqADPBtujFJd" target="_blank" rel="noopener">UC Berkeley 61B (2014 年春季): 数据结构 (25 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL4BBB74C7D2A1049C" target="_blank" rel="noopener">UC Berkeley 61B (2006 年秋季): 数据结构 (39 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=gJJeUFyuvvg&amp;list=PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_" target="_blank" rel="noopener">UC Berkeley 61C: 计算机结构 (26 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLJ9pm_Rc9HesnkwKlal_buSIHA-jTZMpO" target="_blank" rel="noopener">OOSE: 使用 UML 和 Java 进行软件开发 (21 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=UH0QYvtP7Rk&amp;index=20&amp;list=PLkFD6_40KJIwEiwQx1dACXwh-2Fuo32qr" target="_blank" rel="noopener">UC Berkeley CS 152: 计算机结构和工程 (20 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-" target="_blank" rel="noopener">MIT 6.004: 计算结构 (49 视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL5PHm2jkkXmi5CxxI7b3JCL1TWybTDtKq" target="_blank" rel="noopener">卡內基梅隆大学 - 计算机架构讲座 (39 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=HtSuA80QTyo&amp;list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&amp;nohtml5=False" target="_blank" rel="noopener">MIT 6.006: 算法介绍 (47 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=zm2VP0kHl1M&amp;list=PL6535748F59DCA484" target="_blank" rel="noopener">MIT 6.033: 计算机系统工程 (22 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLUl4u3cNGP63gFHB6xb-kVBiQHYe_4hSi" target="_blank" rel="noopener">MIT 6.034 人工智能, 2010 年秋季 (30 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=L3LMbpZIKhQ&amp;list=PLB7540DEDD482705B" target="_blank" rel="noopener">MIT 6.042J: 计算机科学数学, 2010 年秋季 (25 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=2P-yW7LQr08&amp;list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp" target="_blank" rel="noopener">MIT 6.046: 算法设计与分析 (34 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=phxsQrZQupo&amp;list=PL_2Bwul6T-A7OldmhGODImZL8KEVE38X7" target="_blank" rel="noopener">MIT 6.050J: 信息和熵, 2008 年春季 (19 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=T0yzrZL1py0&amp;list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&amp;index=1" target="_blank" rel="noopener">MIT 6.851: 高等数据结构 (22 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PL6ogFv-ieghdoGKGg2Bik3Gl1glBTEu8c" target="_blank" rel="noopener">MIT 6.854: 高等算法, 2016 年春季 (24 个视频)</a></p></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=GqmQg-cszw4&amp;index=1&amp;list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh" target="_blank" rel="noopener">MIT 6.858计算机系统安全, 2014 年秋季</a></p></li><li><p>[ ] 斯坦福: 编程范例 (17 个视频)</p><ul><li><a href="https://www.youtube.com/watch?v=jTSvthW34GU&amp;list=PLC0B8B318B7394B6F&amp;nohtml5=False" target="_blank" rel="noopener">C 和 C++ 课程</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/watch?v=2aHkqB2-46k&amp;feature=youtu.be" target="_blank" rel="noopener">密码学导论</a></p><ul><li><a href="https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg" target="_blank" rel="noopener">本系列更多内容 (不分先后顺序)</a></li></ul></li><li><p>[ ] <a href="https://www.youtube.com/playlist?list=PLLssT5z_DsK9JDLcT8T62VtzwyW9LNepV" target="_blank" rel="noopener">大数据 - 斯坦福大学 (94 个视频)</a></p></li></ul><h2 id="计算机科学课程"><a href="#计算机科学课程" class="headerlink" title="计算机科学课程"></a>计算机科学课程</h2><ul><li><a href="https://github.com/open-source-society/computer-science" target="_blank" rel="noopener"> 在线 CS 课程目录 </a></li><li><a href="https://github.com/prakhar1989/awesome-courses" target="_blank" rel="noopener">CS 课程目录 (一些是在线讲座)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这是？&quot;&gt;&lt;a href=&quot;#这是？&quot; class=&quot;headerlink&quot; title=&quot;这是？&quot;&gt;&lt;/a&gt;这是？&lt;/h2&gt;&lt;p&gt;这是我为了从 web 开发者（自学、非计算机科学学位）蜕变至 Google 软件工程师所制定的计划，其内容历时数月。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://d3j2pkmjtin6ou.cloudfront.net/coding-at-the-whiteboard-silicon-valley.png&quot; alt=&quot;白板上编程 ———— 来自 HBO 频道的剧集，“硅谷”&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一长列表是从 &lt;strong&gt;Google 的指导笔记&lt;/strong&gt; 中萃取出来并进行扩展。因此，有些事情你必须去了解一下。我在列表的底部添加了一些额外项，用于解决面试中可能会出现的问题。这些额外项大部分是来自于 Steve Yegge 的“&lt;a href=&quot;http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;得到在 Google 工作的机会&lt;/a&gt;”。而在 Google 指导笔记的逐字间，它们有时也会被反映出来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="interview" scheme="http://blog.todaycoder.cn/tags/interview/"/>
    
      <category term="coding" scheme="http://blog.todaycoder.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>[译] Git 的历史: 软件版本控制的统治之路</title>
    <link href="http://blog.todaycoder.cn/2020/03/25/btc-history-git/"/>
    <id>http://blog.todaycoder.cn/2020/03/25/btc-history-git/</id>
    <published>2020-03-25T13:23:29.000Z</published>
    <updated>2020-03-29T06:26:43.124Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.welcometothejungle.co/uploads/article/image/6172/158080/git-history-linus-torvalds.png" alt="Coder stories"></p><a id="more"></a><blockquote><ul><li>原文地址：<a href="https://www.welcometothejungle.com/en/articles/btc-history-git" target="_blank" rel="noopener">The History of Git: The Road to Domination in Software Version Control</a></li><li>原文作者：<a href="https://twitter.com/andy_favell" target="_blank" rel="noopener">Andy Favell</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/btc-history-git.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/btc-history-git.md</a></li><li>译者：<a href="https://github.com/fireairforce" target="_blank" rel="noopener">fireairforce</a></li><li>校对者：<a href="https://github.com/xionglong58" target="_blank" rel="noopener">Long Xiong</a>, <a href="http://github.com/todaycoder001" target="_blank" rel="noopener">司徒公子</a> </li></ul></blockquote><p><strong>在 2005 年，Linus Torvalds 迫切需要一个新的版本控制系统来维护 Linux 内核的开发。于是他花了一个星期的时间，从头开始编写了一个革命性的新系统，并将其命名为 Git。十五年之后，该平台成为了<a href="https://en.wikipedia.org/wiki/List_of_version-control_software" target="_blank" rel="noopener">这个竞争激烈领域里面当之无愧的领导者</a>。</strong></p><p>在全球范围内，大量的初创企业、集体企业和跨国公司，包括谷歌和微软，使用 Git 来维护它们软件项目的源代码。它们中有些公司拥有自己的 Git 项目，有些公司则通过商业托管公司使用 Git，比如 GitHub（成立于 2007 年），Bitbucket（成立于 2010 年）和 GitLab（成立于 2011 年）。其中最大的 GitHub 拥有 <a href="https://octoverse.github.com/" target="_blank" rel="noopener">4000 万注册开发者</a> 并在 2018 年<a href="https://news.microsoft.com/2018/06/04/microsoft-to-acquire-github-for-7-5-billion/" target="_blank" rel="noopener">被微软</a>以 75 亿美元的天价收购。</p><p>Git（及其竞争对手）有时被分类为版本控制系统（VCS），有时是源码管理系统（SCM），还有时是修订控制系统（RCS）。Torvalds 认为生命太短暂而不必去区分这些定义，因此我们不必纠结于此。</p><p>Git 的吸引力之一在于它是开源的（就像 Linux 和 Android 那样）。但是，还有其它开源的 VSC，其中包括协作版本系统（CVS）、SVN、Mercurial 和 Monotone，因此单凭这一点并不足以解释它的优点。</p><p>关于 Git 市场主导地位的最好体现是 <a href="https://insights.stackoverflow.com/survey/" target="_blank" rel="noopener">Stack Overflow 对开发人员的调查</a>。调查结果显示，2018 年 74289 名受访者中有 88.4% 使用了 Git（高于 2015 年的 69.3%）。最接近的竞争对手是 Subversion，普及率为 16.6%（低于 36.9%）；Team Foundation 版本控制，从 2015 年的 12.2% 降为 11.3%；Mercurial 普及率为 3.7%（低于 7.9%）。事实上，Git 的优势如此之大，以至于 Stack Overflow 的数据科学家都懒得在 2019 的调查中提出这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">开源人员使用什么来进行源码控制？</span><br><span class="line"></span><br><span class="line">|           2018         |          2015          |</span><br><span class="line">| ---------------------- | ---------------------- |</span><br><span class="line">| Git: 88.4%             | Git: 69.3%             |</span><br><span class="line">| Subversion: 16.6%      | Subversion: 36.9%      |</span><br><span class="line">| Team Foundation: 11.3% | Team Foundation: 12.2% |</span><br><span class="line">| Mercurial: 3.7%        | Mercurial: 7.9%        |</span><br><span class="line">|                        | CVS: 4.2%              |</span><br><span class="line">|                        | Perforce: 3.3%         |</span><br><span class="line"></span><br><span class="line">| 74,298 受访者       | 16,694 受访者       |</span><br><span class="line"></span><br><span class="line">数据来源：Stack Overflow 2018/2015 开发者调查报告</span><br></pre></td></tr></table></figure><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>直到 2005 年 4 月，Torvalds 一直使用 <a href="http://www.bitkeeper.org/" target="_blank" rel="noopener">BitKeeper</a>（BK）管理着一个庞大的 Linux 内核源码，这些源码来自于完全不同的志愿者开发团队，Linux 是一个越来越受欢迎的类 UNIX 开源操作系统。BK 在当时是一个私有的付费工具，但是 Linux 的开发者可以免费使用它，直到 BK 的创始人 Larry McVoy 与一个 Linux 开发人员就不恰当地使用 BK 发生了争执。</p><p>从 <a href="https://marc.info/?l=linux-kernel&amp;m=111280216717070&amp;w=2" target="_blank" rel="noopener">Torvalds 的声明</a> 到 Linux 邮件列表，都是关于他计划利用一个工作“假期”来决定如何为 Linux 找到新的 VCS，很明显，他喜欢 BK，并对 Linux 不能再使用它而感到沮丧，而且他对竞争并不敢兴趣。如之前提到的，这次假期诞生了 Git。Torvalds 将它命为 Git 的原因有很多种说法，但实际上他只是喜欢这个词，这是他从披头士的歌曲<a href="https://genius.com/The-beatles-im-so-tired-lyrics" target="_blank" rel="noopener">《I’m So Tired》</a>（第二节）中获得灵感。</p><p><strong>“搞笑的是，我所有的项目都是以我自己的名字命名，而这个项目的名字是‘Git’。Git 在<a href="https://dictionary.cambridge.org/dictionary/english/git" target="_blank" rel="noopener">英国俚语</a>里是‘愚蠢的人’的意思，”</strong> Torvalds 告诉我们。<strong>“它也有一个虚构的首字母缩写 —— Global Information Tracker。但这实际上是一个 ‘backronym’, [事后]补上的。”</strong></p><p>那么，Torvalds 对 Git 的巨大成功感到惊讶吗？<strong>“如果我说我能看到它即将成功，那绝对是在撒谎。我当然没有。但是 Git 确实把所有的基础都做对了。有什么事情可以做得更好吗？当然。但总的来说，Git 确实解决了一些与 VCS 有关的真正困难的问题。”</strong> 他说。</p><h2 id="定义-Git-的目标"><a href="#定义-Git-的目标" class="headerlink" title="定义 Git 的目标"></a>定义 Git 的目标</h2><p>传统上，版本控制是客户端服务器，因此代码位于单个存储库中，或者中央服务器的仓库中。协作版本系统（CVS），<a href="https://en.wikipedia.org/wiki/Apache_Subversion" target="_blank" rel="noopener">Subversion</a> 和 Team Foundation 版本控制（TFVC）都是客户端/服务器系统的例子。</p><p>客户机-服务器 VCS 在企业环境中运行良好，在企业环境中，开发受到严格控制，由具有良好网络连接的内部开发团队进行。如果有成百上千的开发人员进行协作，自愿、独立、远程地工作，所有人都想要往代码里面添加新的东西，这对 Linux 等开源软件（OSS）项目来说都很常见的，那么这种协作就不太好用了。</p><p>BK 首创的分布式 VCS 打破了这种模式。Git、Mercurial 和 Monotone 都遵循这个示例。对于分布式 VCS 来说，最新版本的代码副本在每个开发人员的设备上，从而使开发人员可以更轻松地独立修改代码。<strong>“BK 对使用模式的概念影响很大，确实应该得到所有的赞誉。但由于各种原因，我想让 Git 的实现逻辑与 BK 完全不同，但‘分布式 VCS’ 的概念确实是首要目标，BK 教会了我这一点的重要性，”</strong> Torvalds 说。<strong>“真正的分布式意味着 fork 不是问题，任何人都可以 fork 一个项目并进行自己的开发，然后一个月或一年后回来说，‘看看我做的这件伟大的事情。’”</strong></p><p>客户机-服务器 VCS 的另一个主要缺点，特别是对于开源项目，是在服务器上托管中央存储库的人“掌握”了源代码。然而，在分布式 VCS 中，没有中央存储库，只有许多拷贝复制，因此没有人掌握或控制代码。</p><p><strong>“[这使得] 像 GitHub 这样的网站成为可能。当没有包含源代码的中心“主”位置时，你可以突然托管一些东西，而不需要遵循“一个仓库来统治所有人”的策略。”</strong> Torvalds 说。</p><p>另一个核心目标是减少将新分支合并到主分支代码或者 “tree”（组成源代码层次结构的目录）的痛苦。关键是为每个对象分配一个加密哈希索引（唯一且安全的数字）。Git 并不是唯一使用哈希的版本控制器，将它提升到了一个新的高度，不仅将它们应用于每个新版本的文件内容，而且还使用它来确定它们之间的关系，包括 tree 和 commit 。这意味着，通过使用 “git diff” 指令，git 可以通过比较哈希的两个索引，非常快速地识别出分支新的/待提交版本与源代码之间的所有更改，甚至是整个 tree。<strong>“Git 索引的真正目的是作为合并的中间步骤，这样你就可以增量地修复冲突，”</strong> Torvalds 说。</p><p>在进行完全合并之前，这种中间步骤或暂存区的概念可进行版本之间的比较，并解决主要源代码和附加内容之间的任何问题，这个概念是革命性的。然而，这并没有得到那些习惯于其他 VCS 人的普遍认可。</p><h2 id="指定一名维护人员"><a href="#指定一名维护人员" class="headerlink" title="指定一名维护人员"></a>指定一名维护人员</h2><p>在编写了 Git 之后，Torvalds 将其开放给开源社区进行审查和贡献。在那些参与者中，有一位开发人员特别引人注目：Junio Hamano。因此，仅仅几个月后，Torvalds 就可以<a href="https://marc.info/?l=git&amp;m=112243466603239" target="_blank" rel="noopener">抽出身来</a>，专注于Linux，把维护 Git 的责任移交给 Hamano。<strong>“当涉及到代码和功能时，他有明显的、非常重要但难以具体描述的‘好品味’。”</strong>Torvalds 说，<strong>“Junio 确实应该接受所有的荣誉，作为发起人，我理应获得设计 Git 的荣誉。但作为一个项目，Junio 是维护它的人，让它成为一个非常好用的工具。”</strong> </p><p>显然，Junio 是一个不错的选择，因为 15 年后，他仍然作为一个<a href="(http://oss-watch.ac.uk/resources/benevolentdictatorgovernancemodel">仁慈的独裁者</a>)来主导并维护 Git，这意味着他控制着 Git 未来发展的方向，对代码的修改拥有最终的决定权，并且他保持着最多提交的记录。</p><h2 id="扩大-Git-的吸引力"><a href="#扩大-Git-的吸引力" class="headerlink" title="扩大 Git 的吸引力"></a>扩大 Git 的吸引力</h2><p>早期支持 Hamano 的一些志愿贡献者到现在仍然在贡献力量，尽管他们现在经常被一些依赖 Git 的公司全职雇用，并希望对其进行维护和改进。</p><p>其中一名志愿者是 Jeff King，人们叫他 Peff，他在学生时代就开始参与贡献了。他的第一次代码提交是在 2006 年，在将他的代码仓库从 CVS 迁移到 Git 时发现并修复了 <a href="https://git-scm.com/docs/git-cvsimport" target="_blank" rel="noopener">git-cvsimport</a> 中的一个错误。<strong>“当时我是计算机科学与技术专业的研究生，”</strong>他说，<strong>“所以我花了很多时间在 Git 的邮件列表上，回答问题、修复 bug —— 有时是一些困扰我的问题，有时是对其他人报告的回复。到 2008 年左右，我意外地成为了主要贡献者之一。</strong> King 从 2011 年开始受雇于 Guthub 公司，在工作的同时，也为 Git 贡献自己的一份力量。</p><p>King 特别提到了 Git 的两位贡献者的杰出工作，他们都始于 2006 年，并帮助将 Git 的影响扩展到 Linux 社区之外：感谢 Shawn Pearce 为 <a href="https://gerrit.googlesource.com/jgit/" target="_blank" rel="noopener">JGit</a> 所做的工作，为 Java 和 Android 生态系统打开了 Git 的大门；感谢 Johannes Schindelin 为 Git for Windows 所做的工作，向 Windows 社区开放了 Git。他们随后分别在谷歌和微软工作。</p><p><strong>“[Shawn Pearce] 是 Git 的早期贡献者并且实现了 <a href="https://git-scm.com/docs/git-gui" target="_blank" rel="noopener">git-gui</a>，这是 Git 的第一个图形化界面。但更重要的是他在 JGit 上的工作，JGit 是 Git 的纯 Java 实现”</strong> King 说。<strong>“这使得 Git 用户的整个其他生态系统得以实现，并允许 Eclipse 插件，这是 Android 项目选择 Git 作为其版本控制系统的关键部分。他还写了 <a href="https://www.gerritcodereview.com/" target="_blank" rel="noopener">Gerrit</a> [在 Google 工作时]，一个基于 Git 的代码审查系统，用于 Android 和许多其它项目。不幸的是，<a href="https://sfconservancy.org/blog/2018/jan/30/shawn-pearce/" target="_blank" rel="noopener">Shawn 在 2018 年去世</a>。”</strong></p><p>Schindelin 现在仍然是 Git for Windows 发行版的维护者。<strong>“由于 Git 是从内核社区中发展而来的，所以对 Windows 支持基本上是后来才想起的，”。</strong>King 说 <strong>“Git 已经被移植到很多平台上，但大多数平台都是类似于 Unix 风格。到目前为止，Windows 是最大的挑战。在 C 代码中不仅存在可移植性问题，而且还存在使用 Bourne shell、Perl 等编写的部分来发布应用程序的挑战。Git for Windows 将所有这些复杂性整合到一个单一的二进制包中，对 Windows 开发人员使用 Git 的增长产生了重大影响。”</strong></p><p>根据 <a href="https://www.somsubhra.com/github-release-stats/?username=git-for-windows&amp;repository=git" target="_blank" rel="noopener">somsubhra.com</a> 统计，Git for Windows 迄今已被下载超过 1800 万次。</p><h2 id="建立-GitHub"><a href="#建立-GitHub" class="headerlink" title="建立 GitHub"></a>建立 GitHub</h2><p>Tom Preston-Werner 是由同事 Dave Fayram 介绍给 Git的，当时他在为一家名为 <a href="https://en.wikipedia.org/wiki/Powerset_(company" target="_blank" rel="noopener">Powerset</a>) 的初创公司做辅助项目。<strong>“[用 Git ]创建分支、对其进行操作并轻松地将其合并回主分支的能力是革命性的。在这方面 Git 是惊人的。命令行界面需要适应，特别是有一个缓冲区的概念，”</strong> Preston Werner 说。提供基于 Git 的源代码托管服务的机会是显而易见的。<strong>“托管 Git 仓库没有任何好的选择，因此，这对易用性来说是一个大障碍。还缺少一个现代的 web 界面。作为一名 web 开发人员，我认为我可以通过轻松托管 Git 仓库和促进协作来改善这种情况，这是 Git 可以做到的，但并不容易，”</strong>他补充道。</p><p>Preston-Werner 与 Chris Wanstrath、Scott Chacon 和 P.J. Hyett 合作，于 2007 年底开始开发 GitHub 项目。GitHub 帮助 Git 成为主流，不仅使它更易于使用，还将其传播到 Linux 社区之外。由于 GitHub 的创始人是 Ruby 开发人员，而且 GitHub 是用 Ruby 编写的，所以这个词很快就在这个社区中传开了，并在被 <a href="https://github.com/rails/rails" target="_blank" rel="noopener">Ruby on Rails</a> 开发框架采用时大获成功。</p><p><strong>“到 2008 年年中，Ruby on Rails 转向了 GitHub，整个 Ruby 社区似乎都很快跟进。我认为，这种背书，加上 Ruby 开发人员愿意接受更新、更好的技术，这些对我们的成功都至关重要。”</strong>Preston-Werner 说。<strong>“其他项目，如 <a href="https://github.com/nodejs" target="_blank" rel="noopener">Node.js</a> 和 <a href="https://github.com/Homebrew" target="_blank" rel="noopener">Homebrew</a>，都是从 GitHub 开始的，帮助将 Git 引入了新的社区。”</strong></p><p>Preston-Werner 在 2014 年<a href="https://github.blog/2014-04-28-follow-up-to-the-investigation-results/" target="_blank" rel="noopener">辞去了 GitHub CEO 一职</a>，当时有人指控该公司存在欺凌行为和不适当的投诉程序，这些问题或许是该公司发展过快的征兆。</p><p>今天，根据 GitHub <a href="https://octoverse.github.com/" target="_blank" rel="noopener">自己的数据</a>，GitHub 有超过 4000 万注册开发者。这使得它比竞争对手 —— <a href="https://bitbucket.org/blog/celebrating-10-million-bitbucket-cloud-registered-users" target="_blank" rel="noopener">Bitbucket 拥有1000万用户</a>的规模要大得多，而 GitLab 则表示，它拥有“数百万”用户。</p><h2 id="被-Android-采用"><a href="#被-Android-采用" class="headerlink" title="被 Android 采用"></a>被 Android 采用</h2><p>许多公司使用 <a href="https://github.com/customer-stories?type=enterprise" target="_blank" rel="noopener">GitHub 企业版</a>、<a href="https://about.gitlab.com/customers/" target="_blank" rel="noopener">GitLab</a> 或 Bitbucket 来托管软件项目。但是，最大的 Git 安装往往是内部托管的 —— 因此是在公共视野之外 —— 通常进行定制的修改。</p><p>Google 是第一个 Git 的主要采用者（因此也提供了大量的支持），谷歌在 2009 年 3 月决定将 Git 用于 Android 项目，Android 是一个基于 Linux 的手机操作系统。作为开源项目，Android 需要一个允许大量开发人员克隆、使用和贡献代码的平台，并且无需购买特定的工具许可证书。</p><p>当时，Git 被认为不足以管理如此庞大的项目，因此团队构建了一个超级仓库，可以委托给子 Git 仓库。然而，谷歌表示：<strong>“超级仓库并不是要取代 Git，只是为了让 Git 更容易使用。</strong>为了帮助查看仓库和管理、审查对源代码的更改，Pearce 领导的团队 —— 创建了 <a href="https://gerrit.googlesource.com/gerrit/" target="_blank" rel="noopener">Gerrit</a>。</p><h2 id="Microsoft-改变态度"><a href="#Microsoft-改变态度" class="headerlink" title="Microsoft 改变态度"></a>Microsoft 改变态度</h2><p>考虑到开源社区和微软之间相互仇恨的历史，这个软件巨头肯定是 Git 最不可能的支持者。2001 年，当时的微软首席执行 Steve Ballmer 甚至<a href="https://www.theregister.co.uk/2001/06/02/ballmer_linux_is_a_cancer/" target="_blank" rel="noopener">称 Linux 为癌症</a>，微软也有自己的竞争对手 VCS TFVC。</p><p>Schindelin 在 Git for Windows 上工作了多年，而微软没有任何人注意到他的努力。但是，到 2015 年，当他在微软工作时，文化发生了巨大的转变。他开玩笑说：<strong>“如果你在 2007 年问我，或者在 2011 年问过我，我是否会拥有一台 Windows 机器，甚至在微软工作，我都会笑死的。</strong></p><p>这一文化转变的第一个证据出现在 2012 年，当时微软开始（实际上）为 Git 开发资源库 <a href="https://libgit2.org/" target="_blank" rel="noopener">libgit2</a>（一个 Git 开发资源库）做出贡献，以帮助加快 Git 应用程序的速度，然后将其嵌入到开发工具中。Edward Thomson，微软团队的一员，仍然是 libgit2 的维护者。</p><p>2013 年，微软宣布对其开发工具 Visual Studio（VS）提供 Git 支持，并通过 Azure DevOps（当时称为 Team Foundation Service）的云计算工具和服务套件提供 Git 托管，作为其自身 TFVC 的替代方案，这一消息震惊了科技界。</p><p>更值得注意的是，从 2014 年开始，在新的开源友好型 CEO Satya Nadella 的领导下，微软通过 One Engineering System（1ES）计划，在 Git 上逐步实现了内部软件开发的标准化。Azure DevOps 团队在 2015 年开始使用自己的 Git 服务作为自己源码的存储库，这是一个先例。</p><p>2017年，微软 Windows 产品套件的整个开发工作转移到了由 Azure 托管的 Git 上，创建了<a href="https://devblogs.microsoft.com/bharry/the-largest-git-repo-on-the-planet/" target="_blank" rel="noopener">世界上最大的 Git 存储库</a>。这包括相当大的调整以帮助 Git 扩展。Git 的<a href="https://vfsforgit.org/" target="_blank" rel="noopener">虚拟文件系统</a>（它是开源的）并没有将整个 300GB 的 Windows 存储库下载到每个客户端设备，而是确保只将适当的文件下载到每个工程师的计算机上。</p><p>正如 Schindelin 所指出的：<strong>“当像微软这样历史悠久的大公司决定 Git 可以投入企业级使用时，商业界会非常仔细地倾听。我认为这就是为什么 Git 至少在目前为止是‘赢家’的原因。</strong></p><h2 id="收购！"><a href="#收购！" class="headerlink" title="收购！"></a>收购！</h2><p>2018 年 6 月，微软<a href="https://news.microsoft.com/2018/06/04/microsoft-to-acquire-github-for-7-5-billion/" target="_blank" rel="noopener">宣布</a>将以 75 亿美元的价格收购 GitHub，这让人大吃一惊。但当你看事实的时候，也许会觉得这次收购并不是那么出乎意料。</p><p>微软从 2014 年开始参与 GitHub，当时。.Net 开发者平台是<a href="https://devblogs.microsoft.com/dotnet/net-core-is-open-source/" target="_blank" rel="noopener">开源的</a>。据 <a href="https://octoverse.github.com/" target="_blank" rel="noopener">GitHub Octoverse 2019</a> 调查显示，目前 GitHub 上贡献最多的两个项目都是微软的产品 —— <a href="https://github.com/microsoft/vscode" target="_blank" rel="noopener">Visual Studio code</a> 和 <a href="https://github.com/Azure" target="_blank" rel="noopener">Microsoft Azure</a>，而 <a href="https://solutionshub.epam.com/OSCI/" target="_blank" rel="noopener">OSCI/EPAM 在 2019 年的研究</a>显示，微软是 GitHub 上最大的企业贡献者。并且，如前所述，微软已经在 Git 上标准化了内部开发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">开源项目的贡献者数量</span><br><span class="line"></span><br><span class="line">|                项目                    |  贡献人数     |</span><br><span class="line">| -------------------------------------- | ------------- |</span><br><span class="line">| Microsoft/vscode                       | 19.1k         |</span><br><span class="line">| MicrosoftDocs/azure-docs               | 14k           |</span><br><span class="line">| flutter/flutter                        | 13k           |</span><br><span class="line">| firstcontributions/first-contributions | 11.6k         |</span><br><span class="line">| tensorflow/tensorflow                  | 9.9k          |</span><br><span class="line">| facebook/react-native                  | 9.1k          |</span><br><span class="line">| kubernetes/kubernetes                  | 6.9k          |</span><br><span class="line">| DefinitelyTyped/DefinitelyTyped        | 6.9k          |</span><br><span class="line">| ansible/ansible                        | 6.8k          |</span><br><span class="line">| home-assistant/home-assistant          | 6.3k          |</span><br><span class="line"></span><br><span class="line">来源：GitHub Octoverse 2019</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">在 GitHub 上的开源项目的公司中活跃的贡献者的数量</span><br><span class="line"></span><br><span class="line">|  公司        |     活跃贡献者        |</span><br><span class="line">| -------------| -------------------- |</span><br><span class="line">| Microsoft    | 4,859                |</span><br><span class="line">| Google       | 4,457                |</span><br><span class="line">| Red Hat      | 2,766                |</span><br><span class="line">| IBM          | 2,108                |</span><br><span class="line">| Intel        | 2,079                |</span><br><span class="line">| Facebook     | 1,114                |</span><br><span class="line">| Amazon       | 850                  |</span><br><span class="line">| Pivotal      | 767                  |</span><br><span class="line">| SAP          | 732                  |</span><br><span class="line">| GitHub       | 663                  |</span><br><span class="line"></span><br><span class="line">来源: OSCI/EPAM research January 2020</span><br></pre></td></tr></table></figure><p>尽管如此，这次收购还是引起了一些 GitHub 用户的担忧，他们还记得在开源社区的眼中刺 Ballmer 领导下的老微软。Bitbucket 和 GitLab 都声称看到了从 GitHub 迁移到他们平台的项目激增。</p><p>不过，Torvalds 并不这么认为。<strong>“我对微软的收购没有任何保留意见，部分原因是 Git 的基本分布式特性 —— 它避免了政治问题，另一方面也避免了可怕的‘托管公司控制项目’。我不担心的另一个原因是，我认为微软现在是一家不同的公司…微软根本不是开源的敌人。”</strong>他说，<strong>“在纯粹个人层面上，当我听说微软在 GitHub 上花了很多钱时，我只是说，‘现在我开始的两个项目已经变成了价值数十亿美元的产业’，没有多少人能这么说。我也不只是一个“昙花一现的人”。</strong><br><strong>“这是‘生活幸福’的一部分。我很高兴我对世界产生了积极而有意义的影响。我个人可能没有直接从 Git 上赚到任何钱，但它给了我能够做我真正的工作和激情，[Linux]。我不再是一个饥肠辘辘的学生了，我作为一个受人尊敬的程序员做得很好。所以其他人在 Git 上获得的成功绝不会让我感到沮丧。”</strong></p><p><strong>贡献者。感谢：Linus Torvalds，Git 和 Linux 的创始人；Johannes Schindelin，微软软件工程师，Git for Windows 的维护者；Jeff King， GitHub 的 OSS 开发人员；Tom Preston Werner，Chatterbug 的联合创始人，GitHub 的联合创始人；Edward Thomson，GitHub 的产品经理，以及 libgit2 的维护者；Ben Straub，Pro Git 的作者；Evan Phoenix，Rubinius 的创建者；GitLab 高级后端工程师 Christian Couder；GitLab首席营销官 Todd Barr；EPAM 交付管理总监 Patrick Stephens。</strong></p><p><strong>本文出自 Behind the Code —— 由开发者创建的服务于开发者的媒体平台。通过访问 <a href="https://www.welcometothejungle.com/collections/behind-the-code" target="_blank" rel="noopener">Behind the Code</a>，可以发现更多的文章和视频！</strong></p><p><strong>想要参与贡献？<a href="https://docs.google.com/forms/d/e/1FAIpQLSeelH8Eh0HohNrrDWnmKJGBRsFijXfMsMw1fPxOSGdMVypCyg/viewform?usp=sf_link" target="_blank" rel="noopener">出版！</a></strong></p><p><strong>在 <a href="https://twitter.com/behind_thecode" target="_blank" rel="noopener">Twitter</a> 上关注我们吧，保持关注！</strong></p><p><strong><a href="https://fr.creasenso.com/portfolio/blok" target="_blank" rel="noopener">Blok</a> 声明</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.welcometothejungle.co/uploads/article/image/6172/158080/git-history-linus-torvalds.png&quot; alt=&quot;Coder stories&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://blog.todaycoder.cn/tags/Git/"/>
    
      <category term="CSV" scheme="http://blog.todaycoder.cn/tags/CSV/"/>
    
      <category term="Linus Torvalds" scheme="http://blog.todaycoder.cn/tags/Linus-Torvalds/"/>
    
      <category term="Version Control" scheme="http://blog.todaycoder.cn/tags/Version-Control/"/>
    
  </entry>
  
  <entry>
    <title>[译] 密码哈希的方法：PBKDF2，Scrypt，Bcrypt 和 ARGON2</title>
    <link href="http://blog.todaycoder.cn/2020/03/20/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2/"/>
    <id>http://blog.todaycoder.cn/2020/03/20/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2/</id>
    <published>2020-03-20T11:17:01.000Z</published>
    <updated>2020-03-29T06:27:52.176Z</updated>
    
    <content type="html"><![CDATA[<p>关于如何安全的存储密码以及使用何种算法总是有很多的争论：MD5、SHA1，SHA256、PBKDF2，Bcrypt、Scrypt、Argon2、明文？？</p><p>因此，我试图分析并总结了最新的合理选择：Scrypt、Bcrypt 和 Argon2 是符合条件的，MD5、SHA1、SHA256 就不太适合存储密码！😉</p><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200309210312.png" alt=""></p><a id="more"></a><blockquote><ul><li>原文地址：<a href="https://medium.com/@mpreziuso/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2-e25aaf41598e" target="_blank" rel="noopener">Password Hashing: PBKDF2, Scrypt, Bcrypt and ARGON2</a></li><li>原文作者：<a href="https://medium.com/@mpreziuso" target="_blank" rel="noopener">Michele Preziuso</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/password-hashing-pbkdf2-scrypt-bcrypt-and-argon2.md</a></li><li>译者：<a href="https://github.com/todaycoder001" target="_blank" rel="noopener">司徒公子</a></li><li>校对者：<a href="https://github.com/xionglong58" target="_blank" rel="noopener">xionglong58</a>、<a href="https://github.com/GJXAIOU" target="_blank" rel="noopener">GJXAIOU</a></li></ul></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在 2015 年，我就已经发布了‘<a href="https://medium.com/@mpreziuso/password-hashing-pbkdf2-scrypt-bcrypt-1ef4bb9c19b3" target="_blank" rel="noopener">密码哈希：PBKDF2、Scrypt、Bcrypt</a>’文章，来作为对朋友问题的延伸回答。</p><p>概括的说：</p><blockquote><p>攻击者通常拥有与我们不同的、更专业（强大）的硬件</p><p>攻击者之所以使用专业的硬件，是因为它能根据某些算法进行定制，定制化的硬件允许某些算法能比非专业硬件（CPU）上运行的更快，而且 —— 总体而言 —— 某些算法还可以并行化；</p><p>我们依赖慢哈希方法来对密码进行哈希，从而实现你采用的 CPU/GPU 处理器与攻击者的 GPU/FPGA/ASIC 处理器在计算能力上处于同一水准。</p></blockquote><p><strong>以上这些都是正确的</strong>，然而，数字加密货币的竞争又上升到另一个层面：数十亿美元的市值，<br>基于软件/硬件，以最快的速度来实现一种数字加密货币的底层算法，这相比于其他矿工来说也是一种优势，因此，也是最赚钱的一个。</p><p>在比特币使用 SHA256 来作为其底层加密方法的时候（因此，可以在已经优化的硬件上对其进行极大的优化，使其对矿工来说成为一种‘不公平’的数字货币），但其他加密货币的创建者试图通过依赖内存的方法来使新的数字加密货币能被更加公平的开采：<a href="https://litecoin.org/" target="_blank" rel="noopener">莱特币</a>（<a href="https://en.wikipedia.org/wiki/Scrypt" target="_blank" rel="noopener">Scrypt</a>）  是早期的示例，<a href="https://z.cash/" target="_blank" rel="noopener">Zcash</a>（<a href="https://en.wikipedia.org/wiki/Equihash" target="_blank" rel="noopener">Equihash</a>）是最近的示例。</p><p>这意味着用于密码哈希的慢方法正在被用来保护数百万甚至数十亿美元市值的数字加密货币，这使得慢哈希方法的最快实现是有意义的，而且通常这也是<a href="https://github.com/tpruvot/ccminer" target="_blank" rel="noopener">公开可用的</a>。</p><h4 id="那么今天什么是安全的呢？"><a href="#那么今天什么是安全的呢？" class="headerlink" title="那么今天什么是安全的呢？"></a>那么今天什么是安全的呢？</h4><p>原理还是一样的：我们需要一个加密社区审核过的慢函数并且依然未被破解。</p><p><strong>PBKDF2</strong> 已经存在很长时间了，像<a href="https://medium.com/@mpreziuso/password-hashing-pbkdf2-scrypt-bcrypt-1ef4bb9c19b3" target="_blank" rel="noopener">之前文章</a>讨论的一样，它有点过时了：轻松的在多核系统（GPU）上实现并行，这对于定制系统（FPGA/ASIC）来说微不足道。所以我拒绝了它。</p><p>虽然在 1999 年 <strong>BCrypt</strong> 就产生了，并且在对抗 GPU/ASIC 方面要优于 PBKDF2，但是我还是不建议你在新系统中使用它，因为它在离线破解的威胁模型分析中表现并不突出。<br>尽管有一些数字加密货币依赖于它（即：NUD），但它并没有因此获得较大的普及，因此，FPGA/ASIC 社区也并没有足够的兴趣来构建它的硬件实现。<br>话虽如此，<a href="https://twitter.com/solardiz" target="_blank" rel="noopener">Solar Designer</a>（OpenWall）、Malvoni 和 Knezovic（萨格勒布大学）在 2014 年撰写了一篇论文，这篇文章描述了一种混合使用 ARM/FPGA 的单片系统来攻击该算法。</p><p><strong>SCrypt</strong>  在如今是一个更好的选择：比 BCrypt设计得更好（尤其是关于内存方面）并且已经在该领域工作了 10 年。另一方面，它也被用于许多加密货币，并且我们有一些硬件（包括 FPGA 和 ASIC）能实现它。<br>尽管它们专门用于采矿，也可以将其重新用于破解。</p><h2 id="Argon2"><a href="#Argon2" class="headerlink" title="Argon2"></a>Argon2</h2><p>写完<a href="https://medium.com/@mpreziuso/password-hashing-pbkdf2-scrypt-bcrypt-1ef4bb9c19b3" target="_blank" rel="noopener">我的第一篇文章</a>后不久，Argon2 在 2015 年 7 月赢得了密码哈希竞赛。</p><h4 id="密码哈希竞赛"><a href="#密码哈希竞赛" class="headerlink" title="密码哈希竞赛"></a>密码哈希竞赛</h4><p>该竞赛于 2012 年秋季启动，2013 年第一季度，竞赛委员会发布了征集参赛作品的通知，截止日期为 2014 年 3 月底。作为比赛的一部分，小组成员对提交的参赛作品进行了全面审核，并发布了一份初步的简短报告，其中描述了他们的选择标准和理由。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Argon2 有两个主要的版本：<strong>Argon2i</strong> 是对抗侧信道攻击的最安全选择，而 <strong>Argon2d</strong> 是抵抗 GPU 破解攻击的最安全选择。</p><p>源代码可以在 <a href="https://github.com/p-h-c/phc-winner-argon2" target="_blank" rel="noopener">Github</a> 上获得，使用兼容 C89 的 C 语言编写，并在知识共享许可协议下获取许可，并且可以在大多数 ARM、x86 和 x64 架构的硬件上编译。</p><h4 id="基于-AES-实现"><a href="#基于-AES-实现" class="headerlink" title="基于 AES 实现"></a>基于 AES 实现</h4><p>Argon2 基于 <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" target="_blank" rel="noopener">AES</a>  实现，现代的 x64 和 ARM 处理器已经在指令集扩展中实现了它，从而大大缩小了普通系统和攻击者系统之间的性能差距，</p><h4 id="参数调整"><a href="#参数调整" class="headerlink" title="参数调整"></a>参数调整</h4><p>两个版本的算法都可以实现参数化：</p><ul><li><strong>时间</strong>开销，它定义了执行的时间</li><li><strong>内存</strong>开销，它定义了内存的使用情况</li><li><strong>并行</strong>程度，它定义了线程的数量</li></ul><p>这意味着你可以分别调整这些参数，并根据你的用例、威胁模型和硬件规范来量身定制安全约束。</p><h4 id="权衡攻击"><a href="#权衡攻击" class="headerlink" title="权衡攻击"></a>权衡攻击</h4><p>除此之外，Argon2 尤其能抵挡<strong>排名权衡攻击</strong>，这使得在现场可编程逻辑门阵列上进行低成本攻击变得更加困难：虽然，最近的现场可编程逻辑门阵列已经嵌入 RAM 区块，但是，内存带宽仍然是一个限制，并且为了减少内存带宽要求，攻击者必须为了 Argon2 使用更多的计算资源。</p><p><a href="https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf" target="_blank" rel="noopener">规范</a>（见第 5 章）和同一作者的另外<a href="https://orbilu.uni.lu/bitstream/10993/20043/1/Tradeoff%20Cryptanalysis.pdf" target="_blank" rel="noopener">一篇文章</a>中讨论了这些攻击手段和相似的攻击手段，并将其与 scrypt 进行比较。</p><h4 id="Argon2id"><a href="#Argon2id" class="headerlink" title="Argon2id"></a>Argon2id</h4><p>以下是来自 <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-argon2/" target="_blank" rel="noopener">Argon2 互联网工程任务组草案</a>的引用/释义。</p><blockquote><p><strong>Argon2d</strong> 使用依赖数据的内存访问，这使得它很适合用于加密数字货币和工作量证明的应用程序，而不会受到侧信道定时攻击的威胁。<strong>Argon2i</strong> 使用与数据无关的内存访问，这是密码哈希的首选方法。<strong>Argon2id</strong> 在内存第一次迭代的前半部分充当 Argon2i，其余部分则充当 Argon2d。因此，基于时间 —— 空间的平衡，它既提供了侧信道攻击保护也节约了暴力开销。Argon2i 对内存进行了更多的传递，以防止权衡攻击的发生。</p></blockquote><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200309210325.png" alt="来源： news.mit.edu"></p><p>如果你担心侧信道攻击（例如：<a href="https://meltdownattack.com/" target="_blank" rel="noopener">恶意数据缓存加载/幽灵漏洞</a>，它允许通过基于缓存的侧信道读取同一硬件上其他正在运行的进程的私有内存数据），你应该使用 Argon2i，否则使用 Argon2d。<br>如果你不确定或你对混合方法感到满意，你可以使用 Argon2id 来获得两个方面的优势。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在 2019 年，我建议你以后<strong>不要使用</strong> PBKDF2 或 BCrypt，并强烈建议将 Argon2（最好是 Argon2id）用于最新系统。</p><p>Scrypt 是当 Argon2 不可用时的不二选择，但要记住，它在侧侧信道泄露方面也存在相同的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于如何安全的存储密码以及使用何种算法总是有很多的争论：MD5、SHA1，SHA256、PBKDF2，Bcrypt、Scrypt、Argon2、明文？？&lt;/p&gt;
&lt;p&gt;因此，我试图分析并总结了最新的合理选择：Scrypt、Bcrypt 和 Argon2 是符合条件的，MD5、SHA1、SHA256 就不太适合存储密码！😉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-private.oss-cn-shanghai.aliyuncs.com/20200309210312.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="hash password" scheme="http://blog.todaycoder.cn/tags/hash-password/"/>
    
      <category term="encrypt" scheme="http://blog.todaycoder.cn/tags/encrypt/"/>
    
      <category term="PBKDF2" scheme="http://blog.todaycoder.cn/tags/PBKDF2/"/>
    
      <category term="Scrypt" scheme="http://blog.todaycoder.cn/tags/Scrypt/"/>
    
      <category term="Bcrypt" scheme="http://blog.todaycoder.cn/tags/Bcrypt/"/>
    
      <category term="ARGON2" scheme="http://blog.todaycoder.cn/tags/ARGON2/"/>
    
  </entry>
  
  <entry>
    <title>[译] 2020 年要学习的 7 种编程语言和框架</title>
    <link href="http://blog.todaycoder.cn/2020/03/12/the-7-programming-languages-frameworks-to-learn-in-2020-md/"/>
    <id>http://blog.todaycoder.cn/2020/03/12/the-7-programming-languages-frameworks-to-learn-in-2020-md/</id>
    <published>2020-03-12T06:10:47.000Z</published>
    <updated>2020-03-29T06:14:35.617Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>推荐给充满激情的程序员</p></blockquote><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200301104804.jpeg" alt=""></p><a id="more"></a><blockquote><ul><li>原文地址：<a href="https://medium.com/swlh/the-7-programming-languages-frameworks-to-learn-in-2020-6f9ac923ec5d" target="_blank" rel="noopener">The 7 Programming Languages &amp; Frameworks to Learn in 2020</a></li><li>原文作者：<a href="https://medium.com/@kentscg" target="_blank" rel="noopener">Kent Sia</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/the-7-programming-languages-frameworks-to-learn-in-2020.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/the-7-programming-languages-frameworks-to-learn-in-2020.md</a></li><li>译者：<a href="http://github.com/todaycoder001" target="_blank" rel="noopener">司徒公子</a></li><li>校对者：<a href="https://github.com/GJXAIOU" target="_blank" rel="noopener">GJXAIOU</a>、<a href="https://github.com/niayyy-S" target="_blank" rel="noopener">niayyy</a></li></ul></blockquote><p>为你的应用程序选择合适的编程语言或框架不仅会影响开发速度和开发周期，而且还会影响你未来职业发展的广度。</p><p>在这里，我将分享 2020 年你最应该学习了解的 —— 7 种编程语言，并且在未来几年与你息息相关。如果你还在为前端或后端选择哪一门编程语言而苦苦挣扎或热情于此，那么这篇文章非常适合你。</p><h2 id="1-Java-Kotlin-——-Spring-框架"><a href="#1-Java-Kotlin-——-Spring-框架" class="headerlink" title="1. Java/Kotlin —— Spring 框架"></a>1. Java/Kotlin —— Spring 框架</h2><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200301104831.png" alt=""></p><p>很多人可能会问为什么是 <strong>Java</strong>？Java 依然存在？还在流行？答案是<strong>肯定的</strong>。选择学习任何一门编程语言都不仅仅是基于流行程度或者它诞生的时间。无论你喜不喜欢，Java 仍然是一门企业标准的编程语言，并且得到了广泛的运用。工作机会也是我们选择学习编程语言时要考虑的因素之一。</p><p><strong>Kotlin</strong> 是一门具有类型推断的跨平台、静态类型和通用的编程语言。Kotlin 旨在与 Java 完全互操作，并且它标准库的 JVM 版本依赖于 Java 类库，但是类型推断允许它的语法更简洁。Kotlin 由推出 IntelliJ IDEA 的 JetBrains 公司在 2010 年创立，并从 2012 年开始开放源码。</p><p><strong>Spring</strong> 框架是最流行的 Java 开源框架之一。它面向开发人员，并且提供了一个全面、灵活的框架。Spring 5.0 之后的版本为 Kotlin 提供了专门的支持，人们总是将 Kotlin 与 Java 进行比较。对于 Spring 框架来说，既然两种语言都有它的优点和缺点，为什么不把两者结合起来呢？</p><p>借助 Internet 上的扩展、资源和文档。使得开发人员可以更轻松的找到并添加与之不同类型的第三方应用程序集成所需的依赖项。</p><p>Spring 框架最受欢迎的产品：</p><ul><li><strong>Spring Boot</strong> 旨在以最少的前期配置实现尽快的运行</li><li><strong>Spring Cloud</strong> 旨在简化分布式和微服务风格的架构</li><li><strong>Spring Cloud Data Flow</strong> 是用于创建可组合数据微服务的统一服务</li></ul><p>你应该考虑使用，当：</p><ul><li>构建企业级应用程序</li><li>使用流行的云服务提供商实现微服务架构</li><li>使用代码控件构建大型项目</li><li>寻找易于扩展且具有弹性的框架</li></ul><h2 id="2-Golang"><a href="#2-Golang" class="headerlink" title="2. Golang"></a>2. Golang</h2><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200301104840.png" alt=""></p><p><strong>Go</strong>，也称为 <strong>Golang</strong>，是 Google 创建的一种开源的编程语言，它可以轻松构建简单、可靠和高效的软件。语法干净，新手易于理解。</p><p>Go 的美妙之处在于它对并发性的一流支持。Go 不仅支持<strong>多线程</strong>，它本身也是多线程的。</p><p>如果你在寻找轻量级、快速执行和快速开发的产品，Go 是最佳选择之一。与 Spring jar 文件相比，Go 的二进制文件要小的多（10 倍）。</p><p>你应该考虑使用，当：</p><ul><li>构建小型轻量级的应用程序</li><li>构建基于微服务的容器平台</li><li>快速开发，易于构建，学习曲线更平缓</li><li>构建异步和多线程服务</li></ul><h2 id="3-Python-——-Django-框架"><a href="#3-Python-——-Django-框架" class="headerlink" title="3. Python —— Django 框架"></a>3. Python —— Django 框架</h2><p><strong>Django</strong> 框架被认为是构建 web 应用程序的最佳 Python 框架之一，并且它是免费和开源的。Django 提供稳定性、包、和最好的文档，并且有良好的社区支持。</p><p>Django 广泛用于构建 CRM、CMS、预定引擎和各种 web 应用程序，它支持以<strong>最少的编码</strong>快速开发后端 API。</p><p>除其他事项外，Django 非常适合用于数据分析解决方案、复杂的计算和机器学习。它是目前开发人员首选的框架之一。</p><p>你应该考虑使用，当：</p><ul><li>构建大规模 web 应用程序</li><li>API 驱动的应用程序</li><li>不在意整体架构</li><li>数据分析解决方案和机器学习</li></ul><h2 id="4-Node-js-——-Express"><a href="#4-Node-js-——-Express" class="headerlink" title="4. Node.js —— Express"></a>4. Node.js —— Express</h2><p>JavaScript 可能是过去几年最强大和增长最快的编程语言之一。那时候，JavaScript 只用于构建 web 应用程序，但是，现在如果你精通 JavaScript，就可以开发构建 web 应用程序、后端数据库集成、桌面应用程序，甚至是移动应用程序。</p><p>如今，JavaScript 几乎无处不在。由于 JavaScript 的占比很高，并且没有竞争，因此，我们无法预见它不久的将来会走向何方。</p><p><strong>Express</strong> 以快速、无约束、极简的 Node.js web框架而闻名。它基于 JavaScript 构建，学习曲线相对较平缓。如今，大多数开发人员都选择 Express 是因为它的灵活性、简单性和可扩展性。更不用说，Express 是 MEAN（软件捆绑包）技术栈的一部分，该技术栈是基于 JavaScript 技术开发 web 应用程序的完整全栈技术的集合。</p><p>你应该考虑使用，当：</p><ul><li>构建小型 web 应用程序，例如门户网站、看板等</li><li>构建桌面应用程序</li><li>最小可行产品构建（MVP）</li><li>学习曲线更平缓</li><li>你只有一个小团队和较短的开发周期</li><li>尽量减少雇用后端开发团队的成本</li><li>你不想打扰或等待现有的后端团队 😆</li></ul><h2 id="5-Angular-——-Web-框架"><a href="#5-Angular-——-Web-框架" class="headerlink" title="5. Angular —— Web 框架"></a>5. Angular —— Web 框架</h2><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200301104848.png" alt=""></p><p>多年来，我一直关注 Angular，那时 AngularJS 曾经是最好的框架之一。<strong>Angular</strong> 是一个基于 TypeScript 的开源 web 应用框架，由谷歌构建。Angular 是谷歌的同一个 Angular 团队对 AngularJS 的完全重写。它功能强大，并且有很好的社区支持。</p><p>Angular 支持 web、手机和桌面的各种平台。学习 Angular 最主要的原因之一是因为其庞大的生态系统且蓬勃发展。Angular 团队已经向社区交付了大量的工具和库。我参加了 2019 年的 Angular 大会，非常高兴能与世界各地的所有伟大开发者会面，分享使用 Angular 的经验。</p><p>新版本的 Angular（9.0）将会成为关于 JavaScript 框架接的下一个大事件。它有更小的包大小、更快速的构建和更好用的调试工具等。</p><p>你应该考虑使用，当：</p><ul><li>构建大规模的 web 应用程序</li><li>为社区中所有的工具和库寻找一个大型的生态系统</li><li>不介意陡峭的学习曲线</li><li>你喜欢写 Typescript 而不是 JavaScript 🙄</li><li>有<strong>谷歌</strong>的支持</li></ul><h2 id="6-Vue-js-——-渐进式-JavaScript-框架"><a href="#6-Vue-js-——-渐进式-JavaScript-框架" class="headerlink" title="6. Vue.js —— 渐进式 JavaScript 框架"></a>6. Vue.js —— 渐进式 JavaScript 框架</h2><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200301104856.png" alt=""></p><p><strong>Vue</strong> 是一个非常受欢迎的 JavaScript 框架，在过去几年里发展迅猛，Vue 是尤雨溪创建的，当时他在谷歌的 AngularJS 团队工作。</p><p>为什么 Vue 会这么受欢迎？Vue 是一个构建接口的渐进式 JavaScript 框架，它从一开始就被设计成为可以逐步采用的。Vue 最主要的优势之一是，它从竞争对手（Angular 和 React）那里吸取了许多优质成分，并向其中加入了自己的特色。</p><p>我个人非常喜欢 Vue，因为它简单、灵活，最重要的是它是纯 JavaScript 编写的。然而，Vue 仍然很新，社区仍然很小，而且大多数开发人员都不会说英语。</p><p>你应该考虑使用，当：</p><ul><li>构建中型规模的 web 应用程序</li><li>寻找快速开发和较短交付周期（纯 JavaScript）</li><li>学习曲线平稳</li><li>你可以看懂中文 😉</li><li>你非常喜欢 JavaScript（这就是我！）</li></ul><h2 id="7-lonic-框架"><a href="#7-lonic-框架" class="headerlink" title="7. lonic 框架"></a>7. lonic 框架</h2><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200301104902.png" alt=""></p><p>2014年，我开始使用 AngularJS 和 Apache Cordova 对 Ionic 进行开发。它是一个用于混合移动应用程序的开源 SDK。开发人员可以使用 JavaScript 框架构建移动应用程序。Ionic 包括移动组件、排版、移动主题和交互范例来构建移动应用程序。</p><p>在最新版本的 Ionic 中，它允许用户选择任何用户界面框架，例如 Angular，React 或 Vue.js。Ionic 正在推广一个全平台（IOS/Android/Electron/PWA）的代码库。Ionic 也提供了实时更新的工具，并且使用 Appflow 来实现 DevOps 生命周期的持续集成、持续交付。</p><p>你应该考虑使用，当：</p><ul><li>你想构建小型/中型移动应用</li><li>快速开发和平稳的学习曲线</li><li>你不想学习原生编程</li><li>节省构建 Android 和 IOS 移动应用程序的时间和成本</li><li>你喜欢使用 JavaScript 框架来构建移动应用程序</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总之，学习任何编程语言都没有对错之分。还有其他好的一些编程语言可以学习，比如 iOS 的 Swift，谷歌的 Dart、数据科学的 R，Python 的 Flask 等等。从长远来看，为正确的应用场景选择最佳的编程语言非常重要。</p><p>以上的排名列表都是基于受欢迎程度、学习曲线、特性以及我的拙见选出来的。我相信，在 2020 年，只学习一门编程语言并成为这方面的专家已经不可能了。如今，每个人都在讨论全栈编程。</p><blockquote><p>真正的程序员是活到老，学到老。</p></blockquote><p>我希望你们喜欢这篇文章，如果你觉得这篇文章对你有用，请把它分享给你的朋友，并与我分享你的评论。感谢！</p><p>开心写代码！ 😊</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;推荐给充满激情的程序员&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-private.oss-cn-shanghai.aliyuncs.com/20200301104804.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="program language" scheme="http://blog.todaycoder.cn/tags/program-language/"/>
    
      <category term="program fragment" scheme="http://blog.todaycoder.cn/tags/program-fragment/"/>
    
      <category term="program" scheme="http://blog.todaycoder.cn/tags/program/"/>
    
  </entry>
  
  <entry>
    <title>[译] PHP 7.4 有什么新功能？你必须掌握的 10 大特性</title>
    <link href="http://blog.todaycoder.cn/2019/12/18/%E8%AF%91-PHP-7-4-%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B0%E5%8A%9F%E8%83%BD%EF%BC%9F%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84-10-%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.todaycoder.cn/2019/12/18/译-PHP-7-4-有什么新功能？你必须掌握的-10-大特性/</id>
    <published>2019-12-18T04:45:53.000Z</published>
    <updated>2020-03-29T05:39:43.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在短短 7 天之内，我们看到了 PHP 7.4 的发布。更新包括：减少内存的使用、性能显著提升。看下本文 PHP 7.4 的 10 大主要功能。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/12/18/16f18a0534cb73c0?w=1440&amp;h=810&amp;f=png&amp;s=2013568" alt=""></p><a id="more"></a><blockquote><ul><li>原文地址：<a href="https://medium.com/@daniel.dan/whats-new-in-php-7-4-top-10-features-that-you-need-to-know-e0acc3191f0a" target="_blank" rel="noopener">What’s new in PHP 7.4? Top 10 features that you need to know</a></li><li>原文作者：<a href="https://medium.com/@daniel.dan" target="_blank" rel="noopener">Daniel Dan</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/whats-new-in-php-7-4-top-10-features-that-you-need-to-know.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/whats-new-in-php-7-4-top-10-features-that-you-need-to-know.md</a></li><li>译者：<a href="https://github.com/todaycoder001" target="_blank" rel="noopener">司徒公子</a></li><li>校对者：<a href="http://jalan.space" target="_blank" rel="noopener">江五渣</a>、<a href="https://github.com/suhanyujie" target="_blank" rel="noopener">suhanyujie</a>h</li></ul></blockquote><p>为什么有些编程语言如此的流行，而其他编程语言却很少用于项目开发，有时甚至被遗忘。有很多原因，语法的简洁性、函数化程度、开发网络以及社区支持对于每项技术需求层级的影响。</p><p>随着全世界 IT 的不断发展，编码技术必须要通过提供、更新或者增强新特性来应对不断变化的环境。这也是一门编程语言成功最重要的因素之一。</p><p>在我们公司，由于每年都频繁的改进并优化性能，因此，我很喜欢 PHP，并且我相信在未来几年也会广受欢迎。自从 2004 年 PHP 5 发布以来，它的性能已经翻倍或许甚至翻了三倍，这就是为什么我们<a href="https://y-sbm.com/" target="_blank" rel="noopener">软件开发公司</a>会使用 PHP 语言来开发的原因之一。</p><p>毫无疑问，根据 <a href="https://insights.stackoverflow.com/survey/2019#technology" target="_blank" rel="noopener">2019 StackOverflow 开发者调查结果</a>，PHP 连续第二年成为十大最受欢迎的编程语言之一。今年，它排在第八位，比<a href="https://insights.stackoverflow.com/survey/2018#technology" target="_blank" rel="noopener">去年排名</a>高出一位。</p><p>短短的 7 天内，也就是 11 月 28 日星期四，我们会看到 PHP 新版本的发布 — PHP 7.4，它将成为有史以来功能最丰富的版本之一。这篇文章，我将列出并介绍 PHP 7.4 的更新特性概述。让我们开始吧！</p><h2 id="PHP-7-4-的新功能是什么？PHP-特性列表"><a href="#PHP-7-4-的新功能是什么？PHP-特性列表" class="headerlink" title="PHP 7.4 的新功能是什么？PHP 特性列表"></a>PHP 7.4 的新功能是什么？PHP 特性列表</h2><h4 id="1-箭头函数的支持"><a href="#1-箭头函数的支持" class="headerlink" title="1. 箭头函数的支持"></a>1. 箭头函数的支持</h4><p>由于匿名函数或闭包主要应用于 JS 中，他们在 PHP 中似乎很啰嗦，他们的实现和程序的维护也会更复杂一些。</p><p>引入对箭头函数的支持使得 PHP 开发者大大清理他们的代码并且使语法更加简洁。这样，你代码的可读性和简洁性会大大提高。看下面的例子。</p><p>因此，如果是以前的话，你必须按以下代码块写：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cube</span><span class="params">($n)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ($n * $n * $n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">$b = array_map(<span class="string">'cube'</span>, $a);</span><br><span class="line"></span><br><span class="line">print_r($b);</span><br></pre></td></tr></table></figure><p>在 PHP 7.4 发布后，你就可以按如下的方法写：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">$b = array_map(fn($n) =&gt; $n * $n * $n, $a);</span><br><span class="line"></span><br><span class="line">print_r($b);</span><br></pre></td></tr></table></figure><p>由于拥有了创建整齐、更短代码的能力。web 开发过程将会更快，也节省了你的时间。</p><h4 id="2-类型化属性的支持"><a href="#2-类型化属性的支持" class="headerlink" title="2. 类型化属性的支持"></a>2. 类型化属性的支持</h4><p>在下一个版本引入类型化属性可能被视为 PHP 最重要的特性更新之一。虽然之前不可能将声明方法用于类变量和属性（包括静态属性），但现在程序员能很轻松的进行编码，而无需创建特定的 getter 和 setter 方法。</p><p>由于声明类型（不包括 void 和 callable），你可以使用可为空（Nullable）类型，即 int、float、array、string、object、iterable、self、bool 和 parent。</p><p>如果一位 web 开发者尝试从类型中分配一个不相关的值，例如，声明 name 变量为字符串类型，他或她就会接收到 TypeError 的报错。</p><p>像箭头函数一样，类型化属性也能让 PHP 工程师写出更简短和清晰的代码。</p><h4 id="3-预加载"><a href="#3-预加载" class="headerlink" title="3. 预加载"></a>3. 预加载</h4><p>这个很酷新特性的主要目的是提升 PHP 7.4 的性能。简而言之，预加载是在 <a href="https://www.php.net/manual/en/book.opcache.php" target="_blank" rel="noopener">OPcache</a> 中加载文件、框架和库的过程，绝对是新版本的最佳补充。例如，如果你使用框架，则必须为每个请求下载并重新编译其文件。</p><p>在配置 OPcache 的时候，这些代码文件首次参与请求处理，然后每次都检查它们的更改。预加载使服务器可以将指定的代码文件加载到共享内存中。请务必注意，它们将始终可用于后续所有的请求，而无需检查其他文件的改变。</p><p>还值得一提的是，在预加载期间，PHP 还消除了不必要的包含，并解决了类依赖以及具有 Traits 和 Interfaces 等的链接。</p><h4 id="4-协变量返回和协变量参数"><a href="#4-协变量返回和协变量参数" class="headerlink" title="4. 协变量返回和协变量参数"></a>4. 协变量返回和协变量参数</h4><p>目前，PHP 中大多数是不变的参数类型和不变的返回类型，这带来了一些约束。随着协变量（类型从更具体到更通用）返回和协变量（类型从更通用到更具体）参数的引入，PHP 开发者们将能够将参数类型更改为超类型之一。</p><h4 id="5-弱引用"><a href="#5-弱引用" class="headerlink" title="5. 弱引用"></a>5. 弱引用</h4><p>在 PHP 7.4 中，弱引用类允许 web 开发者们将链接保存到不阻止其销毁的对象中。请勿将弱引用类和弱引用扩展混淆。由于这些特性，它们更容易实现类似缓存的结构。</p><p>请参考使用此类的示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> stdClass;</span><br><span class="line"></span><br><span class="line">$weakref = WeakReference::create($obj);</span><br><span class="line"></span><br><span class="line">var_dump($weakref-&gt;get());</span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>($obj);</span><br><span class="line"></span><br><span class="line">var_dump($weakref-&gt;get());</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>另外，请注意，你无法序列化弱引用。</p><h4 id="6-合并分配运算符"><a href="#6-合并分配运算符" class="headerlink" title="6. 合并分配运算符"></a>6. 合并分配运算符</h4><p>合并运算符是 PHP 7.4 提供的另一个新功能。当你需要将三元运算符和 isset 方法一起使用时非常有用。如果它存在且不为空，那么就会返回第一个操作数，否则就会返回第二个操作数。</p><p>Here is an example:<br>这就是个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">// 获取 $_GET[&apos;user&apos;] 的值，如果它不存在则返回 nobody</span><br><span class="line"></span><br><span class="line">$username = $_GET[&apos;user&apos;] ?? &apos;nobody&apos;;</span><br><span class="line"></span><br><span class="line">// 这等价于：</span><br><span class="line"></span><br><span class="line">$username = isset($_GET[&apos;user&apos;]) ? $_GET[&apos;user&apos;] : &apos;nobody&apos;;</span><br><span class="line"></span><br><span class="line">// 链式合并：将返回 $_GET[&apos;user&apos;]、$_POST[&apos;user&apos;] 以及 noboody 中第一个不为 NULL 的值</span><br><span class="line"></span><br><span class="line">$username = $_GET[&apos;user&apos;] ?? $_POST[&apos;user&apos;] ?? &apos;nobody&apos;;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h4 id="7-数组表达式中的展开运算符"><a href="#7-数组表达式中的展开运算符" class="headerlink" title="7. 数组表达式中的展开运算符"></a>7. 数组表达式中的展开运算符</h4><p>与 array_merge 相比，在 PHP 7.4 中，工程师们能在数组中使用展开运算符。有两个主要原因，首先，展开运算符被认为是一种语言结构，而 array_merge 是一个函数，其次是针对常量数组的编译时长优化。因此 PHP 7.4 的性能将会提升。</p><p>看一下数组表达式中的参数解压缩示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$parts = [&apos;apple&apos;, &apos;pear&apos;];</span><br><span class="line"></span><br><span class="line">$fruits = [&apos;banana&apos;, &apos;orange&apos;, ...$parts, &apos;watermelon&apos;];</span><br><span class="line"></span><br><span class="line">var_dump($fruits);</span><br></pre></td></tr></table></figure><p>同样，它也有可能扩展同一数组多次。此外，由于可以在扩展运算符的前后添加普通元素，因此 PHP 开发人员将能够在数组中使用其语法。</p><h4 id="8-新的自定义对象序列化机制"><a href="#8-新的自定义对象序列化机制" class="headerlink" title="8. 新的自定义对象序列化机制"></a>8. 新的自定义对象序列化机制</h4><p>在 PHP 新的版本中，有两种新的可用方法 <strong>serialize 和 </strong>unserialize。将 Serializable 接口的多功能性与实现 <strong>sleep 和 </strong>wakeup 方法结合起来，这种序列化机制使得 PHP 开发者可以避免与已存在的方法产生一些自定义的问题。发现<a href="https://wiki.php.net/rfc/custom_object_serialization" target="_blank" rel="noopener">有关 PHP 特性的更多信息</a>。</p><h4 id="9-为引用提供的反射"><a href="#9-为引用提供的反射" class="headerlink" title="9. 为引用提供的反射"></a>9. 为引用提供的反射</h4><p>类似于 symfony/var-dumper 之类的库，严重依赖 Reflection API 来准确罗列变量。原来，对于引用反射没有很好的支持，这迫使这些库只能依靠 hack 的方式来检测引用。在 PHP 7.4 中添加了 ReflectionReference 类来解决此问题。</p><h4 id="10-支持从-toString-方法抛出异常"><a href="#10-支持从-toString-方法抛出异常" class="headerlink" title="10. 支持从 __toString() 方法抛出异常"></a>10. 支持从 __toString() 方法抛出异常</h4><p>之前无法从 __toString 方法中抛出异常。原因是标准库中的许多函数都执行从对象到字符串的转化，它们当中并非所有的都准备好正确的“处理”异常。作为该 RFC 的一部分，对代码库中的字符串转换进行了全面的审核，并取消了此限制。</p><h2 id="最后的思考"><a href="#最后的思考" class="headerlink" title="最后的思考"></a>最后的思考</h2><p>在短短的一周之内，PHP 7.4 将发布。有许多新的 PHP 特性会减少内存的使用并且大大提升 PHP 7.4 的性能。你将能够避免此编程语言之前的某些限制，编写更加简洁的代码，并更快的创建 web 解决方案。</p><p>Beta 3 版本已经可以下载并用于测试服务器的测试了。然而，我并不建议你在产品环境或者正在开发的项目中使用它。如果你对于 PHP 7.4 或者 PHP 开发还有疑惑，或者仅仅只是喜欢这篇文章，欢迎在下方留下你的评论。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在短短 7 天之内，我们看到了 PHP 7.4 的发布。更新包括：减少内存的使用、性能显著提升。看下本文 PHP 7.4 的 10 大主要功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/18/16f18a0534cb73c0?w=1440&amp;amp;h=810&amp;amp;f=png&amp;amp;s=2013568&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://blog.todaycoder.cn/tags/PHP/"/>
    
      <category term="Php Development" scheme="http://blog.todaycoder.cn/tags/Php-Development/"/>
    
      <category term="Software Development" scheme="http://blog.todaycoder.cn/tags/Software-Development/"/>
    
      <category term="Web Development" scheme="http://blog.todaycoder.cn/tags/Web-Development/"/>
    
  </entry>
  
  <entry>
    <title>[译] 如何确定团队工作的优先级 </title>
    <link href="http://blog.todaycoder.cn/2019/12/02/%E8%AF%91-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%9B%A2%E9%98%9F%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://blog.todaycoder.cn/2019/12/02/译-如何确定团队工作的优先级/</id>
    <published>2019-12-02T04:37:43.000Z</published>
    <updated>2020-03-29T05:35:47.064Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先了解你公司的目标以及你团队的目标</p></blockquote><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200329133510.png" alt=""></p><a id="more"></a><blockquote><ul><li>原文地址：<a href="https://medium.com/better-programming/how-to-prioritize-your-teams-work-9e68f5e571c" target="_blank" rel="noopener">How To Prioritize Your Team’s Work</a></li><li>原文作者：<a href="https://medium.com/@mariavalerocam" target="_blank" rel="noopener">Maria Valcam</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/how-to-prioritize-your-teams-work.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/how-to-prioritize-your-teams-work.md</a></li><li>译者：<a href="https://github.com/todaycoder001" target="_blank" rel="noopener">司徒公子</a></li><li>校对者：<a href="https://github.com/sunbufu" target="_blank" rel="noopener">sunbufu</a>, <a href="https://github.com/Baddyo" target="_blank" rel="noopener">Baddyo</a></li></ul></blockquote><hr><h2 id="日常工作"><a href="#日常工作" class="headerlink" title="日常工作"></a>日常工作</h2><p>对于每家公司，我们可以将工作分为三大类：</p><ul><li><strong>产品相关的工作</strong> —— 这就是用户能看到的。通常由产品负责人定义，它包含一些功能以及程序漏洞。</li><li><strong>内部 IT 相关的工作</strong> —— 改善基础架构或日常运营，它包括创建新环境、编写自动化脚本、改进 CI/CD 以及更新依赖项等。</li><li><p><strong>计划外的工作以及重新放回的任务</strong> —— 突发情况和问题。这无法计划，所以在本文的剩余部分中我将忽略它。</p></li><li><p>注意：我参考了《DevOps 手册》中的四种工作类型，并对它们做了一些更改：将业务项目重命名为产品工作（所有的项目都是业务相关的项目）并且将内部 IT 项目和更新合并为一个。</p></li></ul><p>但是，我们如何确定工作的优先级呢？要回答这个问题，我们需要知道公司的目标是什么，我们团队的目标是什么。</p><p>更重要的是：</p><p>为什么你每天上班？</p><hr><h2 id="从大局出发"><a href="#从大局出发" class="headerlink" title="从大局出发"></a>从大局出发</h2><p>为了更大的愿景，需要将公司的目标和团队的目标传达给每一个人，<strong>OKR</strong> 是一个框架，它可以帮助在组织的上下级中实现目标。</p><p>注意：OKR 广泛用于一些科技公司：Google、Intuit、Microsoft、Amazon、Intel、Facebook、Netflix、Samsung、Spotify、Slack、Twitter、Salesforce.com、Deloitte、Dropbox 等。</p><h4 id="OKR（目标-关键成果）是什么？"><a href="#OKR（目标-关键成果）是什么？" class="headerlink" title="OKR（目标 + 关键成果）是什么？"></a>OKR（目标 + 关键成果）是什么？</h4><p>OKRs 有两个部分：</p><ul><li><p><strong>目标</strong> — 需要实现的目标。它们必须是有意义的、具体的、行动导向的并且（理想情况下）鼓舞人心的。</p></li><li><p><strong>关键成果</strong> — 我们如何实现它。它们一定要遵循 <a href="https://corporatefinanceinstitute.com/resources/knowledge/other/smart-goal/" target="_blank" rel="noopener">SMART</a> 原则（明确、可衡量、可达成、实际、及时）。</p></li></ul><p>约翰·杜尔在他的著作《衡量事项》中定义了它们。观看此视频以进行快速总结。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/2/16ec6883a68a7bb6?w=1280&amp;h=720&amp;f=png&amp;s=820257" alt=""></p><hr><h2 id="设定团队的-OKR"><a href="#设定团队的-OKR" class="headerlink" title="设定团队的 OKR"></a>设定团队的 OKR</h2><p>确定我们 OKR 的第一步是设定公司的目标，然后设定团队的目标，公司目标（和公司战略）由董事定义。</p><ol><li><p>了解公司的 OKR </p></li><li><p>为团队设定明确的 OKR</p></li></ol><p>通常，团队的目标仅由产品负责人确定。他们据此创建他们的产品待办需求。对他们来说，这很容易，因为他们了解业务方面，但是这种方法存在许多问题：</p><ul><li>缺少对于业务发展至关重要的内部 IT OKR，如果仅以产品工作为目标，那么服务的速度、质量和稳定性将受到伤害。</li><li>开发人员不会理解他们工作的意义，团队中的每个人都应该参与目标的设定，以便他们了解全局并可以在日常工作中进行权衡。正如《哈佛商业评论》文章“<a href="https://hbr.org/2019/09/dont-let-metrics-undermine-your-business" target="_blank" rel="noopener">不要让指标破坏你的业务</a>”中所描述，开发人员需要明白指标是真实目标的代理。</li></ul><p>解决方案？团队中的每个人都应该参与定义团队的 OKR。</p><p>在每个人都了解业务目标之后，它们可以坐在一起，就团队应该专注于哪些方面来帮助实现这些目标进行讨论。最终，他们应该定义关键成果来保证目标的可追溯性。</p><hr><h2 id="技术-OKR"><a href="#技术-OKR" class="headerlink" title="技术 OKR"></a>技术 OKR</h2><p>你觉不觉得和 PM 达成一致是一件困难的事情？提醒他们，内部工作也能为客户带来价值，所以错过它们对公司来说也是致命的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/2/16ec6883a74bd50f?w=4000&amp;h=2666&amp;f=jpeg&amp;s=3651027" alt=""></p><p>您可以添加以下目标：</p><ul><li><strong>改善交付</strong> —— <a href="https://services.google.com/fh/files/misc/state-of-devops-2019.pdf" target="_blank" rel="noopener">DevOps 状态报告</a>显示了 31000 份来自在职专业人员的调查反馈的结论。它始终指向的是反应开发和交付过程中有效性相同的四个指标。它们分别是交付周期、部署频率、更改失败、可用性和恢复时间。这些指标将高绩效者和低绩效者区分开。</li><li><strong>降低风险因素</strong> —— 首先，你应该确定你的风险（使用便利贴与你的团队一起做），根据相关性对它们进行排序，设定它们发生的可能性（低、中、高）。然后，你的团队应该在表格上记录下 OKR。</li></ul><p>注意：你应该每年检查一次风险因素。</p><ul><li><strong>降低成本</strong> —— 你还在为一个应用花费太多？新项目还没有成果？那笔钱本可以花在你公司的其他地方，我们需要通过减少不必要的开支来考虑这种机会成本。</li></ul><p>注意：对于某些低成本的公司而言，减少成本的工作可能是至关重要的。</p><hr><h2 id="放在一起"><a href="#放在一起" class="headerlink" title="放在一起"></a>放在一起</h2><p>一旦你的团队有了目标，每个新项目都应该与 OKR 关联起来。如果一个项目没有对 OKR 作出贡献，那它就是在浪费团队的时间。</p><p>提示：</p><ul><li><strong>项目应被视为假设</strong>，假设它可能无法实现你的目标。例子1：如果我们允许用户使用 PayPal 支付，我们将获得更多的用户。例子2：如果我们使用微服务，我们将缩短交付周期。所以，你需要验证关键成果是否正在改善。如果不能，请删除该项目并创建一个新的假设。</li><li>目标可以存在一年或更长的时间，但是关键成果会随着工作的进展而演变。所以，你应该至少每年一次<strong>检查你的目标是否仍有意义</strong>，并且每个月或者每个季度至少检查一次关键成果。</li><li>在整个组织中 <strong>OKR 应该是透明的</strong>。这可以激发部门之间的沟通，避免重复工作，因此致力于同一目标的团队可以齐心协力。</li><li>在谷歌，<strong>每一位员工都有自己的 OKR</strong>。其中，六到八个来自于团队，还有两个由他们自己设置（20% 的时间）。他们这样做是为了改善创新并促进人们为公司增添他们的远见（Gmail 就是在 Google 中的那 20% 的项目）。</li><li>OKR 有两种类型：承诺型和进取型。承诺型 OKR 必须为团队实现目标，进取型 OKR 旨在引导团队朝着同一个方向前进，但预计不会实现。实际上，<strong>实现所有的 OKR 是一个不够野心勃勃的信号</strong>（参考 “<a href="https://www.wired.com/2013/01/ff-qa-larry-page/" target="_blank" rel="noopener">Google’s Larry Page on Why Moon Shots Matter</a>”）。</li></ul><hr><h2 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h2><p>我希望这些技巧能使你更好的安排工作的优先级。</p><p>你设置了不同的优先级吗？在评论中让我看到！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;先了解你公司的目标以及你团队的目标&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-private.oss-cn-shanghai.aliyuncs.com/20200329133510.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="http://blog.todaycoder.cn/tags/Programming/"/>
    
      <category term="Business" scheme="http://blog.todaycoder.cn/tags/Business/"/>
    
      <category term="Software Engineering" scheme="http://blog.todaycoder.cn/tags/Software-Engineering/"/>
    
      <category term="Product Management" scheme="http://blog.todaycoder.cn/tags/Product-Management/"/>
    
      <category term="Startup" scheme="http://blog.todaycoder.cn/tags/Startup/"/>
    
  </entry>
  
  <entry>
    <title>[译] 如何计划你的一天 —— 这里有一份攻略请查收</title>
    <link href="http://blog.todaycoder.cn/2019/10/24/%E8%AF%91-%E5%A6%82%E4%BD%95%E8%AE%A1%E5%88%92%E4%BD%A0%E7%9A%84%E4%B8%80%E5%A4%A9-%E2%80%94%E2%80%94-%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%80%E4%BB%BD%E6%94%BB%E7%95%A5%E8%AF%B7%E6%9F%A5%E6%94%B6/"/>
    <id>http://blog.todaycoder.cn/2019/10/24/译-如何计划你的一天-——-这里有一份攻略请查收/</id>
    <published>2019-10-24T04:26:17.000Z</published>
    <updated>2020-03-29T05:27:58.440Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在忙碌的日子里消除焦虑和不知所措"><a href="#在忙碌的日子里消除焦虑和不知所措" class="headerlink" title="在忙碌的日子里消除焦虑和不知所措"></a>在忙碌的日子里消除焦虑和不知所措</h4><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200329132727.jpeg" alt="Photo by Oli Dale"></p><a id="more"></a><blockquote><ul><li>原文地址：<a href="https://medium.com/swlh/this-is-how-to-plan-a-day-94dc24135e1f" target="_blank" rel="noopener">This Is How To Plan A Day.</a></li><li>原文作者：<a href="https://medium.com/@knobelman" target="_blank" rel="noopener">Deb Knobelman, PhD</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/this-is-how-to-plan-a-day.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/this-is-how-to-plan-a-day.md</a></li><li>译者：<a href="https://github.com/todaycoder001" target="_blank" rel="noopener">司徒公子</a></li><li>校对者：<a href="https://github.com/scarqin" target="_blank" rel="noopener">秦圆圆</a>、<a href="https://github.com/sunbufu" target="_blank" rel="noopener">孙不服</a></li></ul></blockquote><p>明天我要和我的家人出城。</p><p>在上飞机之前，我还有许多事情要完成。</p><p>我醒来时脑子里重复着：工作、写作、差事、小孩、三餐、打扫、小狗，这些是我今天想要或需要做的所有事情。一遍又一遍，我知道我被这一天压垮了。</p><p>所以我需要把它们计划好。</p><p>现在我知道，我今天早上有一个半小时来写作。同时晚些时候给重读和编辑预留了机动时间。我准确地知道什么时间该做什么事情，而且，那些琐碎的小事情完全不必今天做完</p><p>计划中最好的一部分是：<strong>我不会带有焦虑地浪费任何时间去担心—我到底什么时间才能把这些做完</strong>，因为我已经知道了。</p><p>这是我的方法：</p><h4 id="做一个列表"><a href="#做一个列表" class="headerlink" title="做一个列表"></a>做一个列表</h4><p>我写下了脑海中所有疯狂的东西，实际上不像我想的那么多。当你一遍又一遍的思考同样的事情，感觉就像是《绿野仙踪》中的龙卷风。当你把这些写下来的时候，十二级龙卷风就变成了六级强风。</p><p>这是关键：<strong>清单只花了我一两分钟的时间。</strong></p><p>几分钟后我确实回来了，以确保我没有漏掉任何事情。但是列出清单根本不会花费什么时间，因为它已经记在我的脑海中了。</p><h4 id="判断每件事情会花费多久"><a href="#判断每件事情会花费多久" class="headerlink" title="判断每件事情会花费多久"></a>判断每件事情会花费多久</h4><p>你列表中的某些事情可能会花费 15 分钟或者更短的时间，我把那些事情放在一起。在我看来，诸如我们外出时邮件搁置之类零星的事情，我将这些归为一类。</p><p>然后还有花费更长的时间的事情，比如写作，完成咨询项目的最后一部分。这些每个不说几个小时，至少花费一个小时。因为只剩下一个项目，我知道我可以将整个“工作”时间都花费在一件事情上，这很有帮助。</p><p>因此，我在<strong>清单中写下了每件事情需要花费的时间</strong>，并把我能在同一地点花费时间较短的事情组合在一起。</p><p>同样，这步只花费了我几分钟。</p><h4 id="确定当天的空档时间"><a href="#确定当天的空档时间" class="headerlink" title="确定当天的空档时间"></a>确定当天的空档时间</h4><p>此刻，我有几个小时的空档时间。在下午 4 点，我必须去营地接孩子。我们通常在放学或者结束营地后闲逛，然后在下午 5:30 - 6:00 吃完饭。大约晚上 9 点，孩子睡觉的时候已经很晚了。但是晚饭后我的丈夫通常会陪他们做一些事情，例如扔棒球。因此，我知道下午 4:00 - 7:00 并不是一个执行任务的好时机，因为我会和家人在一起。但是晚上 7 点之后，对于一些尚未完成的事情，我有一些“机动时间”。</p><p>这意味着从现在到下午 3:45 之间我需要完成大部分的活动（因为我需要离开家去营地接送孩子）</p><p><strong>那仍然给了我 6 个小时来完成所有的事情</strong></p><p>6 个小时听起来好像很长。</p><p>再一次，这步也只花了我几分钟。</p><h4 id="安排每个活动"><a href="#安排每个活动" class="headerlink" title="安排每个活动"></a>安排每个活动</h4><p>最后，我找出每个活动的最佳时间段。</p><p>对我来说，我首先要安排好最紧迫或最有必要的事情。今天，这是我要做的所有的小事。其中大多数涉及计算机任务和拨打电话。所以我会先做，总共大约需一个小时。所以，我会计划 1 小时 15 分，以防万一，你永远不知道我需要等多久。</p><p>接下来，我想完成这个工作项目，它实际上要到下周才到期，但我知道我不想在假期工作。因此，我今天将花两个小时完成它，以绝后顾之忧。</p><p>我计划二十分钟吃午饭。</p><p>之后，我会写一些东西，我希望我能享受和家人在一起的时光，因此，我不确定下周的写作频率。我今天想完成一部分，我会花 1.5 小时来写作。然后，如果需要，今晚七点之后重新阅读、修改和编辑，以今晚或者明天发布为目标。</p><p>为了写作，我还需要设置一个计时器，写作使我处于 “流动” 的深层状态，我参与其中并失去时间，因此，我在手机上设置一个计时器然后继续写作，我不必一直看时钟，我知道我的手机会告诉我何时需要转到下一个任务。</p><p>最后是所有把我带出屋子的差事，我大约还有一个小时的时间，可以在回家的路上接我的孩子。</p><p>当我把时间表放在一起时，我意识到一个小时可能不够我完成所有的任务，所以，打算先做那些在没有孩子情况下应该做的事情。对于像去塔吉特旅行这样的差事，我会在接到孩子们后带他们去。我们应该还是五点回家，有足够的晚餐时间。</p><p>这使我想起，我今天没有时间做晚餐，不过我了解这种情况。所以，在一天快要结束的时候晚餐不会打乱我的计划。我需要计划挑点东西或找到一个不错的订单选项。</p><p>这部分花了我一些时间，这有一点点像拼图。</p><p>但是，<strong>这仍然不超过 15 分钟</strong>。</p><h4 id="深呼吸，然后执行"><a href="#深呼吸，然后执行" class="headerlink" title="深呼吸，然后执行"></a>深呼吸，然后执行</h4><p>还有我的一天。从头到尾，<strong>整天要安排大约 20 分钟</strong>，现在我不必花时间担心它。</p><p>我确切的知道我能做什么和我不能做什么以及何时做，我知道有时间完成所有的工作，任何未列入此清单的任务都可以等到放假后。</p><p><strong>最重要的是，这一天不再让我不知所措</strong>，我的脑子没有在转，我可以专注于执行。</p><hr><p>对我来说，<strong>安排一天是缓解焦虑的最重要方法</strong>。开始这样做之后，我意识到我每天都会在担心上浪费时间，考虑在没有任何实际进展的情况下完成工作，担心可能浪费大量的时间。</p><p>我喜欢每天早上安排时间，一天一次，在普通纸上，在便利贴上或者在笔记本中。</p><p>我尝试做个优秀的规划者，并提前一周规划，<strong>那触发了我的完美主义</strong>。如果我提前完成了这些事情，我会觉得遵守了这周的计划，感觉很拘束，没有放松。如果我错过了计划安排中的一件事情，整周的计划都会变成垃圾。</p><p>但是每个人都不一样，我有焦虑和完美主义，所以太多的结构化会让人感到痛苦。</p><p>关键是要以此为指导，找到适合自己的方法。我们都有很多事情要做，继续尝试不同的事情，你会有办法的。</p><hr><p><strong>有了正确的框架辅以正确的心态，一切皆有可能</strong></p><p><strong>我在我的个人通讯中提供有关生产力和焦虑管理的实现和具体见解。详见<a href="http://www.debknobelman.com" target="_blank" rel="noopener">www.debknobelman.com</a>。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在忙碌的日子里消除焦虑和不知所措&quot;&gt;&lt;a href=&quot;#在忙碌的日子里消除焦虑和不知所措&quot; class=&quot;headerlink&quot; title=&quot;在忙碌的日子里消除焦虑和不知所措&quot;&gt;&lt;/a&gt;在忙碌的日子里消除焦虑和不知所措&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://blog-private.oss-cn-shanghai.aliyuncs.com/20200329132727.jpeg&quot; alt=&quot;Photo by Oli Dale&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Productivity" scheme="http://blog.todaycoder.cn/tags/Productivity/"/>
    
      <category term="Time Management" scheme="http://blog.todaycoder.cn/tags/Time-Management/"/>
    
      <category term="Mental Health" scheme="http://blog.todaycoder.cn/tags/Mental-Health/"/>
    
      <category term="Self Improvement" scheme="http://blog.todaycoder.cn/tags/Self-Improvement/"/>
    
      <category term="Entrepreneurship" scheme="http://blog.todaycoder.cn/tags/Entrepreneurship/"/>
    
  </entry>
  
  <entry>
    <title>[译]如何提升你的数据结构、算法以及解决问题的能力</title>
    <link href="http://blog.todaycoder.cn/2019/09/17/%E8%AF%91-%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%83%BD%E5%8A%9B/"/>
    <id>http://blog.todaycoder.cn/2019/09/17/译-如何提升你的数据结构、算法以及解决问题的能力/</id>
    <published>2019-09-17T04:16:50.000Z</published>
    <updated>2020-03-29T05:26:21.734Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/20200329132305.jpeg" alt=""></p><a id="more"></a><blockquote><ul><li>原文地址：<a href="https://medium.com/@fabianterh/how-to-improve-your-data-structures-algorithms-and-problem-solving-skills-af50971cba60" target="_blank" rel="noopener">How to improve your data structures, algorithms, and problem-solving skills</a></li><li>原文作者：<a href="https://medium.com/@fabianterh" target="_blank" rel="noopener">Fabian Terh</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/how-to-improve-your-data-structures-algorithms-and-problem-solving-skills.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/how-to-improve-your-data-structures-algorithms-and-problem-solving-skills.md</a></li><li>译者：<a href="https://github.com/todaycoder001" target="_blank" rel="noopener">todaycoder001</a></li><li>校对者：<a href="http://jalan.space" target="_blank" rel="noopener">江五渣</a>、<a href="https://github.com/xurui1995" target="_blank" rel="noopener">xurui1995</a></li></ul></blockquote><p>这篇文章借鉴了我过去在学校一个学期的个人经历和挑战，当我进入学校的时候，我对任何 DSA（数据结构和算法）和解决问题的策略几乎一无所知。作为一名自学成才的程序员，我对一般编程会更加熟悉和舒适，例如面向对象编程，而不是 DSA 问题所需要的解决问题的能力。</p><p>这篇文章反映了我整个学期的经历，并包含了为了快速提高数据结构、算法和解决问题的能力而求助的资源。</p><h2 id="面临问题：你知道原理，但是你被实际应用卡住了"><a href="#面临问题：你知道原理，但是你被实际应用卡住了" class="headerlink" title="面临问题：你知道原理，但是你被实际应用卡住了"></a>面临问题：你知道原理，但是你被实际应用卡住了</h2><p>我在学期初期的时候遇到这个问题，当时<strong>我不明白我哪里不懂</strong>，这是一个特别严重的问题。我对这个理论很了解，例如，什么是链表，它是如何工作的，它的各种操作和时间复杂度，它支持的 ADT（抽象数据类型），以及如何实现 ADT 操作。</p><p>但是，由于我不明白我哪里不懂，所以我无法确定我对它的理解和在实际应用中解决问题的差距。</p><h4 id="不同类型的问题"><a href="#不同类型的问题" class="headerlink" title="不同类型的问题"></a>不同类型的问题</h4><p>一个数据结构问题的例子：描述如何在链表中插入一个节点并说明时间复杂度。</p><p>这是一个算法问题：在旋转数组中查找元素并说明时间复杂度。</p><p>最后是解决问题的疑虑，我认为比之前两个问题的级别更高，这可能需要简要描述一个场景，并且列出问题的要求。在考试中，可能会要求你对解决方案进行描述。在编程比赛中，可能会要求你在不明确提供任何的数据结构和算法的情况下提交可运行的代码。换句话说，它们希望你能使用最适合的数据结构和算法来尽可能有效地解决问题。</p><h2 id="如何提升你的数据结构、算法和解决问题的能力。"><a href="#如何提升你的数据结构、算法和解决问题的能力。" class="headerlink" title="如何提升你的数据结构、算法和解决问题的能力。"></a>如何提升你的数据结构、算法和解决问题的能力。</h2><p>我主要使用三个网站来练习：<a href="https://www.hackerrank.com" target="_blank" rel="noopener">HackerRank</a>、<a href="https://leetcode.com" target="_blank" rel="noopener">LeetCode</a> 和 <a href="https://open.kattis.com" target="_blank" rel="noopener">Kattis</a>。它们非常相似，特别是前两个，但不完全相同。我发现每个网站的侧重点略有不同，每个网站都以自己的方式为用户提供最大化的帮助。</p><p>我将解决问题所需的技能大致分为：</p><ol><li>数据结构知识</li><li>算法知识</li><li>数据结构和算法知识的应用</li></ol><p>前两个被视为”基元“或构建块，第三点就涉及如何将数据结构和算法应用于特定的场景。</p><h4 id="数据结构知识"><a href="#数据结构知识" class="headerlink" title="数据结构知识"></a>数据结构知识</h4><p>在这方面，我发现 HackerRank 是一个宝贵的资源，它有一个专门用于数据结构的部分，你可以按类型过滤，比如数组、链表、（平衡）树、堆 ……</p><p>这些问题与其说是关于如何解决问题，不如说是如何处理数据结构。例如：</p><ol><li>数组：<a href="https://www.hackerrank.com/challenges/array-left-rotation/problem" target="_blank" rel="noopener">数组旋转</a>、<a href="https://www.hackerrank.com/challenges/crush/problem" target="_blank" rel="noopener">数组操作</a></li><li>链表：<a href="https://www.hackerrank.com/challenges/reverse-a-linked-list/problem" target="_blank" rel="noopener">反转链表</a>、<a href="https://www.hackerrank.com/challenges/detect-whether-a-linked-list-contains-a-cycle/problem" target="_blank" rel="noopener">循环检测</a></li><li>树：<a href="https://www.hackerrank.com/challenges/swap-nodes-algo/problem" target="_blank" rel="noopener">节点交换</a>、<a href="https://www.hackerrank.com/challenges/is-binary-search-tree/problem" target="_blank" rel="noopener">二叉搜索树的验证</a></li></ol><p>你明白了，有些问题可能永远都不会直接适用于解决问题。但它们非常适合概念性理解，这在任何情况下都是非常重要的。</p><p>HackerRank 没有可自由访问的”模型解决方案“，尽管讨论部分时常充满了提示、线索、甚至是可用的代码片段。到目前为止，我发现这些是足够的，虽然你可能需要在集成开发环境中一行一行地执行代码才能真正地理解某些内容。</p><h4 id="算法知识"><a href="#算法知识" class="headerlink" title="算法知识"></a>算法知识</h4><p>HackerRank 也有一个<a href="https://www.hackerrank.com/domains/algorithms" target="_blank" rel="noopener">算法部分</a>，尽管我更喜欢用 <a href="https://leetcode.com/problemset/all/" target="_blank" rel="noopener">LeetCode</a>。我发现 LeetCode 上的问题涉及范围更广，并且我真正喜欢的是，许多问题的解决方案中都带有详解甚至是时间复杂度的说明。</p><p>从 LeetCode 上<a href="https://leetcode.com/problemset/top-100-liked-questions/" target="_blank" rel="noopener">点赞前 100 的问题</a>开始学习是一个很好地开始。以下是一些我认为很好的问题：</p><ul><li><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">账户合并</a></li><li><a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">最长连续递增序列</a></li><li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></li></ul><p>与数据结构问题不同，这里的侧重点并不是处理或操作数据结构，而是如何<strong>做一些事</strong>。例如：“账户合并”问题主要就是并查集算法的应用。“搜索旋转排序数组”问题提出了二分查找的变形。有时你会学习一种全新的解决问题的技巧。例如：“<a href="https://www.geeksforgeeks.org/window-sliding-technique/" target="_blank" rel="noopener">滑窗窗口</a>”解决方案用于“最长连续递增序列”问题。</p><h4 id="数据结构和算法知识的应用"><a href="#数据结构和算法知识的应用" class="headerlink" title="数据结构和算法知识的应用"></a>数据结构和算法知识的应用</h4><p>最后，我使用 Kattis 来提升我解决问题的能力。<a href="https://open.kattis.com/" target="_blank" rel="noopener">Kattis 问题归档</a>中有许多来自不同渠道的编程问题，比如来自全世界的一些编程比赛。</p><p>由于没有官方的解决方案和讨论区（不像 HackerRank 和 LeetCode 一样），Kattis 令人非常沮丧。此外，测试用例也是私有的。我有一些少数待解决的 Kattis 问题，我无法解决它并不是因为我不知道解决方案，而是因为我无法找出 bug。</p><p>这是三个练习和学习网站中我最不喜欢的，我也并没有花太多的时间在上面。</p><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p><a href="https://www.geeksforgeeks.org" target="_blank" rel="noopener">Geeksforgeeks</a> 是另一个对于学习数据结构和算法非常有价值的资源。我喜欢它提供各种语言的代码片段，通常是 C++、Java 以及 Python，你可以将其复制然后粘贴到集成开发环境中以逐行执行。</p><p>最后，还有值得信赖的老谷歌，它会让你在大多数时间里都能看到 GeeksForGeeks 和提供可视化解题的 Youtube。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>然而，归根到底，这条路没有捷径可走。你只需要一头扎进去，开始写代码、调试代码并且阅读其他人的正确代码，找出你错在哪、怎么错、为什么会错。这很艰难，但每次尝试都会变得更好，随着你变得更好，它也将会变容易。</p><p>我远没有达到我想要的水平，但我知道，当我启程时便注定路远迢迢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://blog-private.oss-cn-shanghai.aliyuncs.com/20200329132305.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="algorithm" scheme="http://blog.todaycoder.cn/tags/algorithm/"/>
    
      <category term="data struct" scheme="http://blog.todaycoder.cn/tags/data-struct/"/>
    
      <category term="skill" scheme="http://blog.todaycoder.cn/tags/skill/"/>
    
  </entry>
  
  <entry>
    <title>[译] 为什么你要学习 Go？</title>
    <link href="http://blog.todaycoder.cn/2019/09/03/%E8%AF%91-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E8%A6%81%E5%AD%A6%E4%B9%A0-Go%EF%BC%9F/"/>
    <id>http://blog.todaycoder.cn/2019/09/03/译-为什么你要学习-Go？/</id>
    <published>2019-09-02T16:22:03.000Z</published>
    <updated>2020-03-29T05:17:06.749Z</updated>
    
    <content type="html"><![CDATA[<p><strong>掘金翻译计划</strong>上翻译的第一篇文章，感谢两位校对者的认证校对。</p><p><img src="https://raw.githubusercontent.com/todaycoder001/public-images/master/img/20190902123731.png" alt="Image from: [http://kirael-art.deviantart.com/art/Go-lang-Mascot-458285682](http://kirael-art.deviantart.com/art/Go-lang-Mascot-458285682)"></p><blockquote><p>“<a href="https://twitter.com/tobi/status/326086379207536640" target="_blank" rel="noopener">Go will be the server language of the future.</a>” — Tobias Lütke, Shopify</p></blockquote><a id="more"></a> <blockquote><ul><li>原文地址：<a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65" target="_blank" rel="noopener">Why should you learn Go?</a></li><li>原文作者：<a href="https://medium.com/@kevalpatel2106" target="_blank" rel="noopener">Keval Patel</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/why-should-you-learn-go.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/why-should-you-learn-go.md</a></li><li>译者：<a href="https://github.com/todaycoder001" target="_blank" rel="noopener">司徒公子</a></li><li>校对者：<a href="https://github.com/TokenJan" target="_blank" rel="noopener">TokenJan</a>，<a href="https://github.com/JackEggie" target="_blank" rel="noopener">JackEggie</a></li></ul></blockquote><p>在过去几年，有一门崛起的新语言：<a href="https://golang.org/" target="_blank" rel="noopener"><strong>Go 或者 GoLang</strong></a>。没有什么比一门新的编程语言更令开发者兴奋了，不是么? 因此，我在 4、5 个月之前开始学习 Go。在这里我将告诉你，你为什么也要学习这门新语言。</p><p>在这篇文章中，我不打算教你怎样写 “Hello World!!”。网上有许多其他的文章会教你。<strong>我将阐述软硬件发展的现状以及为什么我们要学习像 Go 这样的新语言？</strong> 因为如果没有任何问题，我们就不需要解决方案，不是么？</p><h2 id="硬件的局限性"><a href="#硬件的局限性" class="headerlink" title="硬件的局限性"></a>硬件的局限性</h2><p><strong><a href="http://www.investopedia.com/terms/m/mooreslaw.asp" target="_blank" rel="noopener">摩尔定律</a>正在失效。</strong></p><p>英特尔公司在 <a href="http://www.informit.com/articles/article.aspx?p=339073" target="_blank" rel="noopener">2004 年推出</a>了第一款具有 3.0 GHz时钟速度的奔腾 4 处理器。如今，我的 <a href="http://www.apple.com/macbook-pro/specs/" target="_blank" rel="noopener">2016款 MacBook Pro</a> 的时钟速度为 2.9 GHz。因此，差不多十年，原始处理能力都没有太多的增加。你可以在下图中看到处理能力的增长与时间的关系。</p><p><img src="https://raw.githubusercontent.com/todaycoder001/public-images/master/img/20190902125732.png" alt=""></p><p>从上面的图表可以看出，单线程的性能和处理器的频率在近十年几乎保持稳定。如果你认为添加更多的晶体管是一种解决问题的方法，那你就错了。这是因为在微观尺度上，量子特性开始显现（例如：量子隧道穿越），放更多的晶体管代价也会越多(<a href="https://www.quora.com/What-is-Quantum-Tunneling-Limit-How-does-it-limit-the-size-of-a-transistor" target="_blank" rel="noopener">为什么？</a>)，而且，每美元可以添加晶体管的数量也开始下降。</p><p>所以，针对上述问题的解决方案如下：</p><ul><li>厂商开始向处理器添加越来越多的内核。如今，我们已经有四核和八核的 CPU 可用。</li><li>我们还引入了超线程技术。</li><li>为处理器添加更多的缓存以提升性能。</li></ul><p>但是，以上方案也有它们自身的限制。我们无法向处理器添加更多的缓存以提升性能，因为缓存具有物理限制：缓存越大，速度越慢。添加更多的内核到处理器也有它的成本。而且，这也无法无限扩展。这些多核处理器能同时运行多个线程，同时也能带来并发能力。我们稍后会讨论它。</p><p>因此，如果我们不能依赖于硬件的改进，唯一的出路就是找到一个高效的软件来提升性能，但遗憾的是，现代编程语言都不是那么高效。</p><blockquote><p>“现代处理器就像一辆有氮氧加速系统的直线竞速赛车，它们在直线竞速赛中表现优异。不幸的是，现代编程语言却像蒙特卡罗赛道，它们有大量的弯道。” - <a href="https://en.wikipedia.org/wiki/David_Ungar" target="_blank" rel="noopener">David Ungar</a></p></blockquote><h2 id="Go-有-goroutine！！"><a href="#Go-有-goroutine！！" class="headerlink" title="Go 有 goroutine！！"></a>Go 有 goroutine！！</h2><p>如上所述，硬件提供商正在向处理器添加更多的内核以提升性能。所有的数据中心都在这些处理器上运行，我们应该期待在未来几年内核数量的增长。更重要的是，如今的应用程序都是使用多个微服务来维持数据库的连接、消息队列和缓存的维护。因此，我们开发的软件和编程语言可以更容易的支持并发，并且它们应该随着内核数量的增长而可扩展。</p><p>但是大多数现代编程语言（如 Java、Python 等）都来自于 90 年代的单线程环境。这些语言大多数都支持多线程。但真正的问题是并发执行，线程锁、竞争条件和死锁。这些问题都使得很难在这些语言上创建一个多线程的应用程序。</p><p>例如，在 Java 中创建新的线程会消耗大量内存。因为每一个线程都会消耗大约 1 MB 大小的堆内存，如果你运行上千个线程，他们会对堆造成巨大的压力，最终会由于内存不足而宕机。此外，你想要在两个或者多个线程之间通信也是非常困难的。</p><p>另一方面，Go 于 2009 年发布，那时多核处理器已经上市了。这也是为什么 Go 是在考虑并发的基础上构建的。Go 用 goroutine 来替代线程，它们从堆中消耗了大约 2 KB 的内存。因此你可以随时启动上百万个 goroutine。</p><p><img src="https://raw.githubusercontent.com/todaycoder001/public-images/master/img/20190902125813.png" alt="Goroutine 是怎样工作的呢？参考：[http://golangtutorials.blogspot.in/2011/06/goroutines.html](http://golangtutorials.blogspot.in/2011/06/goroutines.html)"></p><p><strong>其他的好处：</strong></p><ul><li>Goroutine 具有可增长的分段堆栈，这意味着它只会在需要的时候才会使用更多的内存。</li><li>Goroutine 比线程启动的更快。</li><li>Goroutine 带有内置原语，可以在它们（通道）之间安全的进行通信。</li><li>Goroutine 允许你在共享数据结构时避免使用互斥锁。</li><li>此外，goroutine 和系统线程没有 1:1 的映射。单个 goroutine 能在多个线程上运行。Goroutine 也能被复用到少量的系统线程上。</li></ul><blockquote><p>你能在 Rob Pike 的优秀演讲<a href="https://blog.golang.org/concurrency-is-not-parallelism" target="_blank" rel="noopener">并发不是并行</a>中获取更深刻理解。</p></blockquote><p>以上这些点，能使 Go 能像 Java、C 或者 C++ 一样拥有强大的并发处理能力，同时在保证并发执行代码严谨性的基础上，像 Erlang 一样优美。</p><p><img src="https://raw.githubusercontent.com/todaycoder001/public-images/master/img/20190902125953.png" alt="Go takes good of both the worlds. Easy to write concurrent and efficient to manage concurrency"></p><h2 id="Go-直接在底层硬件上运行"><a href="#Go-直接在底层硬件上运行" class="headerlink" title="Go 直接在底层硬件上运行"></a>Go 直接在底层硬件上运行</h2><p>与其他现代高级语言（如 Java/Python）相比，使用 C、C++ 的最大好处就是它的性能，因为 C/C++ 是编译型语言而不是解释型语言。</p><p>处理器能理解二进制文件。通常来说，当你编译一个用 Java 或者其他基于 JVM 的语言构建的应用程序，它将人类可读的代码编译为字节代码，这可以被 JVM 或者在底层操作系统之上运行的其他虚拟机所理解。当执行的时候，虚拟机解释这些字节码并且将他们转化为处理器能理解的二进制文件。</p><p><img src="https://raw.githubusercontent.com/todaycoder001/public-images/master/img/20190902130150.png" alt="基于虚拟机语言的执行步骤"></p><p>而另一个方面，C/C++ 不会在 VM 上执行，并且从执行周期中删除（编译为字节代码）这一步提高性能。它直接将人类可读的代码编译为二进制文件。</p><p><img src="https://raw.githubusercontent.com/todaycoder001/public-images/master/img/20190902130237.png" alt=""></p><p>但是，在这些语言中释放和分配变量是一件极其痛苦的事情。虽然大部分编程语言都使用垃圾回收器或者引用计数的算法来处理对象的分配和移除。</p><p>Go 做到了两全其美，Go 像一些低级别的语言（如： C/C++ ）一样是一门编译型语言，这意味着它的性能几乎接近于低级别语言，它还用垃圾回收来分配和删除对象。因此，不再需要 malloc() 和 free() 声明了！！！这太酷了！！！</p><h2 id="用-Go-编写的代码易于维护"><a href="#用-Go-编写的代码易于维护" class="headerlink" title="用 Go 编写的代码易于维护"></a>用 Go 编写的代码易于维护</h2><p>我告诉你一件事，Go 没有像其他语言一样疯狂于编程语法，它的语法非常整洁。</p><p>Go 的的设计者在谷歌创建这门语言的时候就考虑到了这一点，由于谷歌拥有非常强大的代码库，成千上万的开发者都工作在相同的代码库上，代码应该易于其他开发者理解，一段代码应该对另一段代码有最小的影响。这些都会使得代码易于维护，易于修改。</p><p>Go 有意的忽视了许多现代面向对象语言的一些特性。</p><ul><li><strong>没有类。</strong> 所有代码都仅用 package 分开，Go 只有结构体而不是类。</li><li><strong>不支持继承。</strong> 这将使得代码易于修改。在其他语言中，如： Java/Python，如果类 ABC 继承类 XYZ 并且你在类 XYZ 中做了一些改动，那么这可能会在继承类 XYZ 的其他类中产生一些副作用。通过移除继承，Go 也使得理解代码变得很容易 <strong>（因为当你在看一段代码时不需要同时查看父类）</strong>。</li><li>没有构造方法。</li><li>没有注解。</li><li>没有泛型。</li><li>没有异常。</li></ul><p>以上这些改变使得 Go 与其他语言截然不同，这使得用 Go 编程与其他语言很不一样。你可能不喜欢以上的一些观点。但是，并不是说没有上述这些特性，你就无法对你的应用程序编码。你要做的就是多写几行代码，但从积极的一面，它将使你的代码更加清晰，为代码添加更多的清晰度。</p><p><img src="https://raw.githubusercontent.com/todaycoder001/public-images/master/img/20190902130259.png" alt="代码的可读性和效率的对比"></p><p>如上图所示，Go 几乎与 C/C++ 一样高效，同时像 Ruby、Python 以及其他一些语言一样保持代码语法的简洁，对于人类和处理器来说，这是一个双赢的局面！！！</p><p><a href="https://www.quora.com/Is-Swifts-syntax-still-changing" target="_blank" rel="noopener">与 Swift 等这些新的语言不一样</a>，Go 的语法非常稳定。自从 2012 年首次公开发布 1.0 版本以来，它保持不变并且向后兼容。</p><h2 id="Go-由谷歌背书"><a href="#Go-由谷歌背书" class="headerlink" title="Go 由谷歌背书"></a>Go 由谷歌背书</h2><ul><li>我知道这不是一个直接的技术优势，但 Go 是由谷歌设计并支持的，谷歌拥有世界上最大的云基础设施之一，并且规模庞大。谷歌设计 Go 以解决可扩展性和有效性问题。这些是创建我们自己的服务器时都会遇到的问题。</li><li>Go 更多的也是被一些大公司所使用，如 Adobe、BBC、IBM，因特尔甚至是 <a href="https://medium.engineering/how-medium-goes-social-b7dbefa6d413#.r8nqjxjpk" target="_blank" rel="noopener">Medium</a>。<strong>(来源：<a href="https://github.com/golang/go/wiki/GoUsers" target="_blank" rel="noopener">https://github.com/golang/go/wiki/GoUsers</a>)</strong></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>尽管 Go 与其他面向对象的语言非常不同，但他同样产生了巨大的影响。Go 提供了像 C/C++ 一样的高性能，像 Java 一样高效的并发处理以及像 Python/Perl 一样的编码乐趣。</li><li>如果你没有任何学习 Go 的计划，我将仍然会说硬件的限制会给我们带来压力，软件开发者应该写超高效的代码。开发者应该理解硬件并相应的优化他们的程序。<strong>优化的软件能运行在更廉价或者更慢的机器上（例如<a href="https://en.wikipedia.org/wiki/Internet_of_things" target="_blank" rel="noopener">物联网</a>设备），并且整体上对最终用户体验有更好的影响。</strong></li></ul><hr><p><strong>~如果你喜欢这篇文章，点击下方的💚以便于更多的人看到它！此外，你也可以在 <a href="http://bit.ly/2h9p8o2" target="_blank" rel="noopener">Medium</a> 或者<a href="http://bit.ly/2iTjfui" target="_blank" rel="noopener">我的博客</a>关注我，以便于你及时获取 Go 的更新的文章！！~</strong></p><p><img src="https://raw.githubusercontent.com/todaycoder001/public-images/master/img/20190902130516.png" alt=""></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><strong>GoLang 或者开发者的未来</strong> 来自于 <a href="https://medium.com/@edoardo849" target="_blank" rel="noopener">Edoardo Paolo Scalafiotti</a></li><li><a href="https://www.youtube.com/watch?v=5bYO60-qYOI" target="_blank" rel="noopener">用 Go 编写下一代服务器</a></li><li><a href="https://vimeo.com/49718712" target="_blank" rel="noopener">并发不是并行</a> by Rob Pike</li><li><a href="https://nathany.com/why-go/" target="_blank" rel="noopener">为什么是 Go？</a></li></ul><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;掘金翻译计划&lt;/strong&gt;上翻译的第一篇文章，感谢两位校对者的认证校对。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/todaycoder001/public-images/master/img/20190902123731.png&quot; alt=&quot;Image from: [http://kirael-art.deviantart.com/art/Go-lang-Mascot-458285682](http://kirael-art.deviantart.com/art/Go-lang-Mascot-458285682)&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“&lt;a href=&quot;https://twitter.com/tobi/status/326086379207536640&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go will be the server language of the future.&lt;/a&gt;” — Tobias Lütke, Shopify&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://blog.todaycoder.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="GoLang" scheme="http://blog.todaycoder.cn/tags/GoLang/"/>
    
      <category term="后端" scheme="http://blog.todaycoder.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 最佳实践</title>
    <link href="http://blog.todaycoder.cn/2019/08/25/Laravel-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://blog.todaycoder.cn/2019/08/25/Laravel-最佳实践/</id>
    <published>2019-08-25T15:41:00.000Z</published>
    <updated>2019-08-25T15:43:21.546Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类和一个方法应该只有一个责任。</p><a id="more"></a><p>例如:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFullNameAttribute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (auth()-&gt;user() &amp;&amp; auth()-&gt;user()-&gt;hasRole(<span class="string">'client'</span>) &amp;&amp; auth()-&gt;user()-&gt;isVerified()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Mr. '</span> . <span class="keyword">$this</span>-&gt;first_name . <span class="string">' '</span> . <span class="keyword">$this</span>-&gt;middle_name . <span class="string">' '</span> . <span class="keyword">$this</span>-&gt;last_name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;first_name[<span class="number">0</span>] . <span class="string">'. '</span> . <span class="keyword">$this</span>-&gt;last_name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFullNameAttribute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;isVerifiedClient() ? <span class="keyword">$this</span>-&gt;getFullNameLong() : <span class="keyword">$this</span>-&gt;getFullNameShort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isVerifiedClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> auth()-&gt;user() &amp;&amp; auth()-&gt;user()-&gt;hasRole(<span class="string">'client'</span>) &amp;&amp; auth()-&gt;user()-&gt;isVerified();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFullNameLong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Mr. '</span> . <span class="keyword">$this</span>-&gt;first_name . <span class="string">' '</span> . <span class="keyword">$this</span>-&gt;middle_name . <span class="string">' '</span> . <span class="keyword">$this</span>-&gt;last_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getFullNameShort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;first_name[<span class="number">0</span>] . <span class="string">'. '</span> . <span class="keyword">$this</span>-&gt;last_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保持控制器的简洁"><a href="#保持控制器的简洁" class="headerlink" title="保持控制器的简洁"></a><strong>保持控制器的简洁</strong></h3><p>如果您使用的是查询生成器或原始SQL查询，请将所有与数据库相关的逻辑放入Eloquent模型或Repository类中。</p><p>例如:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $clients = Client::verified()</span><br><span class="line">        -&gt;with([<span class="string">'orders'</span> =&gt; <span class="function"><span class="keyword">function</span> <span class="params">($q)</span> </span>&#123;</span><br><span class="line">            $q-&gt;where(<span class="string">'created_at'</span>, <span class="string">'&gt;'</span>, Carbon::today()-&gt;subWeek());</span><br><span class="line">        &#125;])</span><br><span class="line">        -&gt;get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view(<span class="string">'index'</span>, [<span class="string">'clients'</span> =&gt; $clients]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> view(<span class="string">'index'</span>, [<span class="string">'clients'</span> =&gt; <span class="keyword">$this</span>-&gt;client-&gt;getWithNewOrders()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getWithNewOrders</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;verified()</span><br><span class="line">            -&gt;with([<span class="string">'orders'</span> =&gt; <span class="function"><span class="keyword">function</span> <span class="params">($q)</span> </span>&#123;</span><br><span class="line">                $q-&gt;where(<span class="string">'created_at'</span>, <span class="string">'&gt;'</span>, Carbon::today()-&gt;subWeek());</span><br><span class="line">            &#125;])</span><br><span class="line">            -&gt;get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用自定义Request类来进行验证"><a href="#使用自定义Request类来进行验证" class="headerlink" title="使用自定义Request类来进行验证"></a><strong>使用自定义Request类来进行验证</strong></h3><p>把验证规则放到 Request 类中.</p><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $request-&gt;validate([</span><br><span class="line">        <span class="string">'title'</span> =&gt; <span class="string">'required|unique:posts|max:255'</span>,</span><br><span class="line">        <span class="string">'body'</span> =&gt; <span class="string">'required'</span>,</span><br><span class="line">        <span class="string">'publish_at'</span> =&gt; <span class="string">'nullable|date'</span>,</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(PostRequest $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostRequest</span> <span class="keyword">extends</span> <span class="title">Request</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rules</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">'title'</span> =&gt; <span class="string">'required|unique:posts|max:255'</span>,</span><br><span class="line">            <span class="string">'body'</span> =&gt; <span class="string">'required'</span>,</span><br><span class="line">            <span class="string">'publish_at'</span> =&gt; <span class="string">'nullable|date'</span>,</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务代码要放到服务层中"><a href="#业务代码要放到服务层中" class="headerlink" title="业务代码要放到服务层中"></a><strong>业务代码要放到服务层中</strong></h3><p>控制器必须遵循单一职责原则，因此最好将业务代码从控制器移动到服务层中。</p><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($request-&gt;hasFile(<span class="string">'image'</span>)) &#123;</span><br><span class="line">        $request-&gt;file(<span class="string">'image'</span>)-&gt;move(public_path(<span class="string">'images'</span>) . <span class="string">'temp'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;articleService-&gt;handleUploadedImage($request-&gt;file(<span class="string">'image'</span>));</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handleUploadedImage</span><span class="params">($image)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_null($image)) &#123;</span><br><span class="line">            $image-&gt;move(public_path(<span class="string">'images'</span>) . <span class="string">'temp'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DRY原则-不要重复自己"><a href="#DRY原则-不要重复自己" class="headerlink" title="DRY原则 不要重复自己"></a><strong>DRY原则 不要重复自己</strong></h3><p>尽可能重用代码，SRP可以帮助您避免重复造轮子。 此外尽量重复使用Blade模板，使用Eloquent的 scopes 方法来实现代码。</p><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getActive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;where(<span class="string">'verified'</span>, <span class="number">1</span>)-&gt;whereNotNull(<span class="string">'deleted_at'</span>)-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getArticles</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;whereHas(<span class="string">'user'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($q)</span> </span>&#123;</span><br><span class="line">            $q-&gt;where(<span class="string">'verified'</span>, <span class="number">1</span>)-&gt;whereNotNull(<span class="string">'deleted_at'</span>);</span><br><span class="line">        &#125;)-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">scopeActive</span><span class="params">($q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $q-&gt;where(<span class="string">'verified'</span>, <span class="number">1</span>)-&gt;whereNotNull(<span class="string">'deleted_at'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getActive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;active()-&gt;get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getArticles</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;whereHas(<span class="string">'user'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($q)</span> </span>&#123;</span><br><span class="line">            $q-&gt;active();</span><br><span class="line">        &#125;)-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用ORM而不是纯sql语句，使用集合而不是数组"><a href="#使用ORM而不是纯sql语句，使用集合而不是数组" class="headerlink" title="使用ORM而不是纯sql语句，使用集合而不是数组"></a><strong>使用ORM而不是纯sql语句，使用集合而不是数组</strong></h3><p>使用Eloquent可以帮您编写可读和可维护的代码。 此外Eloquent还有非常优雅的内置工具，如软删除，事件，范围等。</p><p>例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`articles`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> *</span><br><span class="line">              <span class="keyword">FROM</span> <span class="string">`users`</span></span><br><span class="line">              <span class="keyword">WHERE</span> <span class="string">`articles`</span>.<span class="string">`user_id`</span> = <span class="string">`users`</span>.<span class="string">`id`</span></span><br><span class="line">              <span class="keyword">AND</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> *</span><br><span class="line">                          <span class="keyword">FROM</span> <span class="string">`profiles`</span></span><br><span class="line">                          <span class="keyword">WHERE</span> <span class="string">`profiles`</span>.<span class="string">`user_id`</span> = <span class="string">`users`</span>.<span class="string">`id`</span>) </span><br><span class="line">              <span class="keyword">AND</span> <span class="string">`users`</span>.<span class="string">`deleted_at`</span> <span class="keyword">IS</span> <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">AND</span> <span class="string">`verified`</span> = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">AND</span> <span class="string">`active`</span> = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`created_at`</span> <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Article::has(<span class="string">'user.profile'</span>)-&gt;verified()-&gt;latest()-&gt;get();</span><br></pre></td></tr></table></figure><h3 id="集中处理数据"><a href="#集中处理数据" class="headerlink" title="集中处理数据"></a><strong>集中处理数据</strong></h3><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$article = <span class="keyword">new</span> Article;</span><br><span class="line">$article-&gt;title = $request-&gt;title;</span><br><span class="line">$article-&gt;content = $request-&gt;content;</span><br><span class="line">$article-&gt;verified = $request-&gt;verified;</span><br><span class="line"><span class="comment">// Add category to article</span></span><br><span class="line">$article-&gt;category_id = $category-&gt;id;</span><br><span class="line">$article-&gt;save();</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$category-&gt;article()-&gt;create($request-&gt;validated());</span><br></pre></td></tr></table></figure><h3 id="不要在模板中查询，尽量使用惰性加载"><a href="#不要在模板中查询，尽量使用惰性加载" class="headerlink" title="不要在模板中查询，尽量使用惰性加载"></a><strong>不要在模板中查询，尽量使用惰性加载</strong></h3><p>例子 (对于100个用户，将执行101次DB查询):</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">foreach</span> (User::all() <span class="keyword">as</span> $user)</span><br><span class="line">    &#123;&#123; $user-&gt;profile-&gt;name &#125;&#125;</span><br><span class="line">@<span class="keyword">endforeach</span></span><br></pre></td></tr></table></figure><p>更优的写法 (对于100个用户，使用以下写法只需执行2次DB查询):</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$users = User::with(<span class="string">'profile'</span>)-&gt;get();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@<span class="keyword">foreach</span> ($users <span class="keyword">as</span> $user)</span><br><span class="line">    &#123;&#123; $user-&gt;profile-&gt;name &#125;&#125;</span><br><span class="line">@<span class="keyword">endforeach</span></span><br></pre></td></tr></table></figure><h3 id="注释你的代码，但是更优雅的做法是使用描述性的语言来编写你的代码"><a href="#注释你的代码，但是更优雅的做法是使用描述性的语言来编写你的代码" class="headerlink" title="注释你的代码，但是更优雅的做法是使用描述性的语言来编写你的代码"></a><strong>注释你的代码，但是更优雅的做法是使用描述性的语言来编写你的代码</strong></h3><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count((<span class="keyword">array</span>) $builder-&gt;getQuery()-&gt;joins) &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>加上注释:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确定是否有任何连接</span></span><br><span class="line"><span class="keyword">if</span> (count((<span class="keyword">array</span>) $builder-&gt;getQuery()-&gt;joins) &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;hasJoins())</span><br></pre></td></tr></table></figure><h3 id="不要把-JS-和-CSS-放到-Blade-模板中，也不要把任何-HTML-代码放到-PHP-代码里"><a href="#不要把-JS-和-CSS-放到-Blade-模板中，也不要把任何-HTML-代码放到-PHP-代码里" class="headerlink" title="不要把 JS 和 CSS 放到 Blade 模板中，也不要把任何 HTML 代码放到 PHP 代码里"></a><strong>不要把 JS 和 CSS 放到 Blade 模板中，也不要把任何 HTML 代码放到 PHP 代码里</strong></h3><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let article = `&#123;&#123; json_encode($article) &#125;&#125;`;</span><br></pre></td></tr></table></figure><p>更好的写法:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"article"</span> type=<span class="string">"hidden"</span> value=<span class="string">"@json($article)"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Or</span></span><br><span class="line"></span><br><span class="line">&lt;button class="js-fav-article" data-article="@json($article)"&gt;&#123;&#123; $article-&gt;name &#125;&#125;&lt;button&gt;</span><br></pre></td></tr></table></figure><p>在Javascript文件中加上:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> article = $(<span class="string">'#article'</span>).val();</span><br></pre></td></tr></table></figure><p>当然最好的办法还是使用专业的PHP的JS包传输数据。</p><h3 id="在代码中使用配置、语言包和常量，而不是使用硬编码"><a href="#在代码中使用配置、语言包和常量，而不是使用硬编码" class="headerlink" title="在代码中使用配置、语言包和常量，而不是使用硬编码"></a><strong>在代码中使用配置、语言包和常量，而不是使用硬编码</strong></h3><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isNormal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $article-&gt;type === <span class="string">'normal'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> back()-&gt;with(<span class="string">'message'</span>, <span class="string">'Your article has been added!'</span>);</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isNormal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $article-&gt;type === Article::TYPE_NORMAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> back()-&gt;with(<span class="string">'message'</span>, __(<span class="string">'app.article_added'</span>));</span><br></pre></td></tr></table></figure><h3 id="使用社区认可的标准Laravel工具"><a href="#使用社区认可的标准Laravel工具" class="headerlink" title="使用社区认可的标准Laravel工具"></a><strong>使用社区认可的标准Laravel工具</strong></h3><p>强力推荐使用内置的Laravel功能和扩展包，而不是使用第三方的扩展包和工具。<br>如果你的项目被其他开发人员接手了，他们将不得不重新学习这些第三方工具的使用教程。<br>此外，当您使用第三方扩展包或工具时，你很难从Laravel社区获得什么帮助。 不要让你的客户为额外的问题付钱。</p><table><thead><tr><th>想要实现的功能</th><th>标准工具</th><th>第三方工具</th></tr></thead><tbody><tr><td>权限</td><td>Policies</td><td>Entrust, Sentinel 或者其他扩展包</td></tr><tr><td>资源编译工具</td><td>Laravel Mix</td><td>Grunt, Gulp, 或者其他第三方包</td></tr><tr><td>开发环境</td><td>Homestead</td><td>Docker</td></tr><tr><td>部署</td><td>Laravel Forge</td><td>Deployer 或者其他解决方案</td></tr><tr><td>自动化测试</td><td>PHPUnit, Mockery</td><td>Phpspec</td></tr><tr><td>页面预览测试</td><td>Laravel Dusk</td><td>Codeception</td></tr><tr><td>DB操纵</td><td>Eloquent</td><td>SQL, Doctrine</td></tr><tr><td>模板</td><td>Blade</td><td>Twig</td></tr><tr><td>数据操纵</td><td>Laravel集合</td><td>数组</td></tr><tr><td>表单验证</td><td>Request classes</td><td>他第三方包,甚至在控制器中做验证</td></tr><tr><td>权限</td><td>Built-in</td><td>他第三方包或者你自己解决</td></tr><tr><td>API身份验证</td><td>Laravel Passport</td><td>第三方的JWT或者 OAuth 扩展包</td></tr><tr><td>创建 API</td><td>Built-in</td><td>Dingo API 或者类似的扩展包</td></tr><tr><td>创建数据库结构</td><td>Migrations</td><td>直接用 DB 语句创建</td></tr><tr><td>本土化</td><td>Built-in</td><td>第三方包</td></tr><tr><td>实时消息队列</td><td>Laravel Echo, Pusher</td><td>使用第三方包或者直接使用WebSockets</td></tr><tr><td>创建测试数据</td><td>Seeder classes, Model Factories, Faker</td><td>手动创建测试数据</td></tr><tr><td>任务调度</td><td>Laravel Task Scheduler</td><td>脚本和第三方包</td></tr><tr><td>数据库</td><td>MySQL, PostgreSQL, SQLite, SQL Server</td><td>MongoDB</td></tr></tbody></table><h3 id="遵循laravel命名约定"><a href="#遵循laravel命名约定" class="headerlink" title="遵循laravel命名约定"></a><strong>遵循laravel命名约定</strong></h3><p>来源 <a href="http://www.php-fig.org/psr/psr-2/" target="_blank" rel="noopener">PSR standards</a>.</p><p>另外，遵循Laravel社区认可的命名约定：</p><table><thead><tr><th>对象</th><th>规则</th><th>更优的写法</th><th>应避免的写法</th></tr></thead><tbody><tr><td>控制器</td><td>单数</td><td>ArticleController</td><td><del>ArticlesController</del></td></tr><tr><td>路由</td><td>复数</td><td>articles/1</td><td><del>article/1</del></td></tr><tr><td>路由命名</td><td>带点符号的蛇形命名</td><td>users.show_active</td><td><del>users.show-active, show-active-users</del></td></tr><tr><td>模型</td><td>单数</td><td>User</td><td><del>Users</del></td></tr><tr><td>hasOne或belongsTo关系</td><td>单数</td><td>articleComment</td><td><del>articleComments, article_comment</del></td></tr><tr><td>所有其他关系</td><td>复数</td><td>articleComments</td><td><del>articleComment, article_comments</del></td></tr><tr><td>表单</td><td>复数</td><td>article_comments</td><td><del>article_comment, articleComments</del></td></tr><tr><td>透视表</td><td>按字母顺序排列模型</td><td>article_user</td><td><del>user_article, articles_users</del></td></tr><tr><td>数据表字段</td><td>使用蛇形并且不要带表名</td><td>meta_title</td><td><del>MetaTitle; article_meta_title</del></td></tr><tr><td>模型参数</td><td>蛇形命名</td><td>$model-&gt;created_at</td><td><del>$model-&gt;createdAt</del></td></tr><tr><td>外键</td><td>带有_id后缀的单数模型名称</td><td>article_id</td><td><del>ArticleId, id_article, articles_id</del></td></tr><tr><td>主键</td><td>-</td><td>id</td><td><del>custom_id</del></td></tr><tr><td>迁移</td><td>-</td><td>2017_01_01_000000_create_articles_table</td><td><del>2017_01_01_000000_articles</del></td></tr><tr><td>方法</td><td>驼峰命名</td><td>getAll</td><td><del>get_all</del></td></tr><tr><td>资源控制器</td><td><a href="https://laravel.com/docs/master/controllers#resource-controllers" target="_blank" rel="noopener">table</a></td><td>store</td><td><del>saveArticle</del></td></tr><tr><td>测试类</td><td>驼峰命名</td><td>testGuestCannotSeeArticle</td><td><del>test_guest_cannot_see_article</del></td></tr><tr><td>变量</td><td>驼峰命名</td><td>$articlesWithAuthor</td><td><del>$articles_with_author</del></td></tr><tr><td>集合</td><td>描述性的, 复数的</td><td>$activeUsers = User::active()-&gt;get()</td><td><del>$active, $data</del></td></tr><tr><td>对象</td><td>描述性的, 单数的</td><td>$activeUser = User::active()-&gt;first()</td><td><del>$users, $obj</del></td></tr><tr><td>配置和语言文件索引</td><td>蛇形命名</td><td>articles_enabled</td><td><del>ArticlesEnabled; articles-enabled</del></td></tr><tr><td>视图</td><td>短横线命名</td><td>show-filtered.blade.php</td><td><del>showFiltered.blade.php, show_filtered.blade.php</del></td></tr><tr><td>配置</td><td>蛇形命名</td><td>google_calendar.php</td><td><del>googleCalendar.php, google-calendar.php</del></td></tr><tr><td>内容 (interface)</td><td>形容词或名词</td><td>Authenticatable</td><td><del>AuthenticationInterface, IAuthentication</del></td></tr><tr><td>Trait</td><td>使用形容词</td><td>Notifiable</td><td><del>NotificationTrait</del></td></tr></tbody></table><h3 id="尽可能使用简短且可读性更好的语法"><a href="#尽可能使用简短且可读性更好的语法" class="headerlink" title="尽可能使用简短且可读性更好的语法"></a><strong>尽可能使用简短且可读性更好的语法</strong></h3><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$request-&gt;session()-&gt;get(<span class="string">'cart'</span>);</span><br><span class="line">$request-&gt;input(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session(<span class="string">'cart'</span>);</span><br><span class="line">$request-&gt;name;</span><br></pre></td></tr></table></figure><p>更多示例:</p><table><thead><tr><th>常规写法</th><th>更优雅的写法</th></tr></thead><tbody><tr><td><code>Session::get(&#39;cart&#39;)</code></td><td><code>session(&#39;cart&#39;)</code></td></tr><tr><td><code>$request-&gt;session()-&gt;get(&#39;cart&#39;)</code></td><td><code>session(&#39;cart&#39;)</code></td></tr><tr><td><code>Session::put(&#39;cart&#39;, $data)</code></td><td><code>session([&#39;cart&#39; =&gt; $data])</code></td></tr><tr><td><code>$request-&gt;input(&#39;name&#39;), Request::get(&#39;name&#39;)</code></td><td><code>$request-&gt;name, request(&#39;name&#39;)</code></td></tr><tr><td><code>return Redirect::back()</code></td><td><code>return back()</code></td></tr><tr><td><code>is_null($object-&gt;relation) ? null : $object-&gt;relation-&gt;id</code></td><td><code>optional($object-&gt;relation)-&gt;id</code></td></tr><tr><td><code>return view(&#39;index&#39;)-&gt;with(&#39;title&#39;, $title)-&gt;with(&#39;client&#39;, $client)</code></td><td><code>return view(&#39;index&#39;, compact(&#39;title&#39;, &#39;client&#39;))</code></td></tr><tr><td><code>$request-&gt;has(&#39;value&#39;) ? $request-&gt;value : &#39;default&#39;;</code></td><td><code>$request-&gt;get(&#39;value&#39;, &#39;default&#39;)</code></td></tr><tr><td><code>Carbon::now(), Carbon::today()</code></td><td><code>now(), today()</code></td></tr><tr><td><code>App::make(&#39;Class&#39;)</code></td><td><code>app(&#39;Class&#39;)</code></td></tr><tr><td><code>-&gt;where(&#39;column&#39;, &#39;=&#39;, 1)</code></td><td><code>-&gt;where(&#39;column&#39;, 1)</code></td></tr><tr><td><code>-&gt;orderBy(&#39;created_at&#39;, &#39;desc&#39;)</code></td><td><code>-&gt;latest()</code></td></tr><tr><td><code>-&gt;orderBy(&#39;age&#39;, &#39;desc&#39;)</code></td><td><code>-&gt;latest(&#39;age&#39;)</code></td></tr><tr><td><code>-&gt;orderBy(&#39;created_at&#39;, &#39;asc&#39;)</code></td><td><code>-&gt;oldest()</code></td></tr><tr><td><code>-&gt;select(&#39;id&#39;, &#39;name&#39;)-&gt;get()</code></td><td><code>-&gt;get([&#39;id&#39;, &#39;name&#39;])</code></td></tr><tr><td><code>-&gt;first()-&gt;name</code></td><td><code>-&gt;value(&#39;name&#39;)</code></td></tr></tbody></table><h3 id="使用IOC容器来创建实例-而不是直接new一个实例"><a href="#使用IOC容器来创建实例-而不是直接new一个实例" class="headerlink" title="使用IOC容器来创建实例 而不是直接new一个实例"></a><strong>使用IOC容器来创建实例 而不是直接new一个实例</strong></h3><p>创建新的类会让类之间的更加耦合，使得测试越发复杂。请改用IoC容器或注入来实现。</p><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user = <span class="keyword">new</span> User;</span><br><span class="line">$user-&gt;create($request-&gt;validated());</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(User $user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;user = $user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">$this</span>-&gt;user-&gt;create($request-&gt;validated());</span><br></pre></td></tr></table></figure><h3 id="避免直接从-env-文件里获取数据"><a href="#避免直接从-env-文件里获取数据" class="headerlink" title="避免直接从 .env 文件里获取数据"></a><strong>避免直接从 <code>.env</code> 文件里获取数据</strong></h3><p>将数据传递给配置文件，然后使用<code>config（）</code>帮助函数来调用数据</p><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$apiKey = env(<span class="string">'API_KEY'</span>);</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/api.php</span></span><br><span class="line"><span class="string">'key'</span> =&gt; env(<span class="string">'API_KEY'</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the data</span></span><br><span class="line">$apiKey = config(<span class="string">'api.key'</span>);</span><br></pre></td></tr></table></figure><h3 id="使用标准格式来存储日期，用访问器和修改器来修改日期格式"><a href="#使用标准格式来存储日期，用访问器和修改器来修改日期格式" class="headerlink" title="使用标准格式来存储日期，用访问器和修改器来修改日期格式"></a><strong>使用标准格式来存储日期，用访问器和修改器来修改日期格式</strong></h3><p>例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; Carbon::createFromFormat(<span class="string">'Y-d-m H-i'</span>, $object-&gt;ordered_at)-&gt;toDateString() &#125;&#125;</span><br><span class="line">&#123;&#123; Carbon::createFromFormat(<span class="string">'Y-d-m H-i'</span>, $object-&gt;ordered_at)-&gt;format(<span class="string">'m-d'</span>) &#125;&#125;</span><br></pre></td></tr></table></figure><p>更优的写法:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Model</span></span><br><span class="line"><span class="keyword">protected</span> $dates = [<span class="string">'ordered_at'</span>, <span class="string">'created_at'</span>, <span class="string">'updated_at'</span>];</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getSomeDateAttribute</span><span class="params">($date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $date-&gt;format(<span class="string">'m-d'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// View</span></span><br><span class="line">&#123;&#123; $object-&gt;ordered_at-&gt;toDateString() &#125;&#125;</span><br><span class="line">&#123;&#123; $object-&gt;ordered_at-&gt;some_date &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="其他的一些好建议"><a href="#其他的一些好建议" class="headerlink" title="其他的一些好建议"></a><strong>其他的一些好建议</strong></h3><p>永远不要在路由文件中放任何的逻辑代码。</p><p>尽量不要在Blade模板中写原始 PHP 代码。</p><blockquote><p>原文作者：<a href="https://github.com/ikidnapmyself" target="_blank" rel="noopener">ikidnapmyself</a></p><p>原文链接：<a href="https://github.com/alexeymezenin/laravel-best-practices/" target="_blank" rel="noopener">https://github.com/alexeymezenin/laravel-best-practices/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单一职责原则&quot;&gt;&lt;a href=&quot;#单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则&quot;&gt;&lt;/a&gt;单一职责原则&lt;/h3&gt;&lt;p&gt;一个类和一个方法应该只有一个责任。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://blog.todaycoder.cn/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://blog.todaycoder.cn/tags/Laravel/"/>
    
      <category term="最佳实践" scheme="http://blog.todaycoder.cn/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>日志文件写入失败（permission denied）</title>
    <link href="http://blog.todaycoder.cn/2019/08/19/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E5%A4%B1%E8%B4%A5%EF%BC%88permission-denied%EF%BC%89/"/>
    <id>http://blog.todaycoder.cn/2019/08/19/日志文件写入失败（permission-denied）/</id>
    <published>2019-08-19T11:58:07.000Z</published>
    <updated>2019-08-19T11:59:18.021Z</updated>
    
    <content type="html"><![CDATA[<p>用过Laravel的小伙伴一开始安装完框架后可能都遇到过daily 日志文件写入失败的问题，接下来我们就来详细说下日志文件写入失败的原因以及对应的解决方案。</p><p>在讲这个问题之前可能需要简单介绍下Linux系统下的文件的Ownership和Permission。</p><a id="more"></a><ul><li><p><strong>Ownership</strong></p><ul><li><p>User</p><p>User是文件的所有者，默认情况下，用户创建了一个文件，该文件的所有者就是该用户。</p></li><li><p>Group</p><p>一个用户组能包含多个用户，所有属于这个组的用户都有相同的权限来访问文件。假设你有一个项目，很多用户都需要访问这个项目文件的权限，你不需要手动赋予这些用户所有权限，你只需要把这些用户加到一个组里面，赋予这些组有访问文件的权限，这样一来就仅仅只有组里面的成员能对文件进行读写操作。</p></li><li><p>Other</p><p>任何其他的用户都能访问文件，因此，给Other用户赋予权限，相当于所有用户都拥有这个权限。</p></li></ul></li><li><p><strong>Permission</strong></p><p>在 UNIX/Linux 系统中每一个文件和目录都有3中权限，以下就是对三个所有者的讨论。</p><ul><li><strong>Read：</strong>这个权限赋予你打开和读取文件的权限。拥有目录的读权限，你能列出其内容。</li><li><strong>Write：</strong>拥有了读权限，你能修改文件的内容。拥有了目录的写权限，你能添加、移除以及重命名该目录下的文件。考虑一种场景，当你拥有文件的写权限，但是没有文件存储目录的写权限，你还是能修改文件的内容，但不能重命名、移动以及移除目录下的文件。</li><li><strong>Execute：</strong>在Windows系统中，一个可执行的程序通常都有.exe后缀，你能很方便的运行它。在 UNIX/Linux 中，除非被赋予可执行权限，否则你将不能运行该程序。如果未授权可执行权限，你让然可以看并修改程序代码（被授予读和写权限），但是无法运行它。</li></ul></li></ul><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/Untitled-0ff10785-6df4-4ace-97d3-7431e04390b3.png" alt=""></p><div style="text-align:center;font-size:12px">linux下文件信息的显示截图</div><p><img src="https://blog-private.oss-cn-shanghai.aliyuncs.com/Untitled-273708b9-71aa-4d9c-b101-afc569a87b97.png" alt=""></p><div style="text-align:center;font-size:12px">linux下目录的信息显示截图</div><p>以上的截图显示了一个文件和文件夹的信息，我们可以看到：</p><ul><li><code>r</code> 代表可读， <code>w</code> 代表可写， <code>x</code> 代表可执行。</li><li>第一位文件显示 <code>-</code> ，文件显示 <code>d</code> 。</li><li>上面第一张图片， <code>rw-rw-r-—</code> 中。第一组 <code>rw-</code> 表示文件的所有者对文件有可读、可写、不可执行的权限。第二组 <code>rw-</code> 表示文件所属的组内用户对该文件有可读、可写、不可执行的权限。第三组 <code>r-—</code> 表示其他任何用户对该文件有可读、不可写、不可执行的权限。</li><li><code>rw-rw-r--</code> 用二进制表示为 <code>664</code> ，每一位如有权限则为 <code>1</code> ，否则为 <code>0</code> ，第一个三位 <code>rw-</code> 用二进制表示为 <code>110</code> 转化为十进制就是 <code>6</code>，后面两组依次类推，最后得到 <code>664</code> 。</li><li>上面第一张图片的 <code>dior www-data</code> 表示该文件的所有者是 <code>dior</code> 用户，文件属于 <code>www-data</code> 组。</li></ul><p>我们知道很多应用系统中的日志是写文件的，且是以日期来命名文件的。所以第一次创建日志的用户就显得尤为重要，如果文件创建的 <code>Onwer</code>和 <code>Group</code> 不对，其他的用户触发写入日志文件就会失败。</p><p>接下来我们讨论下有多少种不同的用户可能创建日志文件：</p><ul><li><code>Crontab</code>中执行的定时任务，跟创建 <code>Crontab</code> 的用户有关，此时创建的文件 <code>Owner</code> 和 <code>Group</code> 值分别是该用户以及默认的 <code>Group</code> 。</li><li>一些常驻的后台进程，比如Laravel中的 <code>queue work</code> ，此时创建的日志文件 <code>Owner</code> 和 <code>Group</code> 值分别是执行该进程的用户以及所属的默认 <code>Group</code> 。</li><li>正常用户访问网站产生的日志文件，此时创建的日志文件的 <code>Owner</code> 和 <code>Group</code> 都是 <code>www-data</code> ， <code>www-data</code> 用户是web服务器默认的用户。</li></ul><p>由以上的分析，我们大概已经找到了解决问题的方法。</p><ul><li>执行用户创建日志文件的权限为 <code>664</code> 比较恰当，这就需要当前用户的umask为 <code>0002</code> 。</li><li>当前执行用户的默认 <code>Group</code> 应该设置为 <code>www-data</code> 。</li></ul><h3 id="下面就说下我的具体解决方案："><a href="#下面就说下我的具体解决方案：" class="headerlink" title="下面就说下我的具体解决方案："></a>下面就说下我的具体解决方案：</h3><p><strong>指定www-data用户执行crontab：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo crontab -u www-data -e</span><br></pre></td></tr></table></figure><p><strong>Laravel中修改创建日志文件的权限：</strong></p><p>编辑 <code>confog/logging.php</code> 文件</p><p>添加 <code>&#39;permission&#39; =&gt; 0664</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;daily&apos; =&gt; [</span><br><span class="line">&apos;driver&apos; =&gt; &apos;daily&apos;,</span><br><span class="line">&apos;path&apos; =&gt; storage_path(&apos;logs/laravel.log&apos;),</span><br><span class="line">&apos;level&apos; =&gt; &apos;debug&apos;,</span><br><span class="line">&apos;days&apos; =&gt; 14,</span><br><span class="line">&apos;permission&apos; =&gt; 0664,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p><strong>你有什么更好的方法么？欢迎留言！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用过Laravel的小伙伴一开始安装完框架后可能都遇到过daily 日志文件写入失败的问题，接下来我们就来详细说下日志文件写入失败的原因以及对应的解决方案。&lt;/p&gt;
&lt;p&gt;在讲这个问题之前可能需要简单介绍下Linux系统下的文件的Ownership和Permission。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Laravel" scheme="http://blog.todaycoder.cn/tags/Laravel/"/>
    
      <category term="Linux" scheme="http://blog.todaycoder.cn/tags/Linux/"/>
    
      <category term="日志文件" scheme="http://blog.todaycoder.cn/tags/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>关于定时发短信业务的讨论</title>
    <link href="http://blog.todaycoder.cn/2019/08/10/%E5%85%B3%E4%BA%8E%E5%AE%9A%E6%97%B6%E5%8F%91%E7%9F%AD%E4%BF%A1%E4%B8%9A%E5%8A%A1%E7%9A%84%E8%AE%A8%E8%AE%BA/"/>
    <id>http://blog.todaycoder.cn/2019/08/10/关于定时发短信业务的讨论/</id>
    <published>2019-08-10T01:54:08.000Z</published>
    <updated>2019-08-10T02:01:17.065Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你有关于消息队列的应用么？欢迎留言！</p></blockquote><h2 id="事情的起因"><a href="#事情的起因" class="headerlink" title="事情的起因"></a>事情的起因</h2><p>需求：在每次线下活动的开始的前一天晚上七点给报名参加价值研习社的用户发一条通知短信用户记得准时参加活动。</p><p>备注：因为我们的业务并发不是很大，所以很多场景并没有考虑到并发情况下的一些问题，这个需求正好通过crontab执行，并且加上服务器的自动弹性伸缩，所以相当于模拟了一次并发的业务场景。</p><a id="more"></a><p>先简单介绍一下数据库的表结构：</p><p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5spg58t6fj30qq09s0t9.jpg" alt="image-20190808234028254"></p><p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5spg5eap0j30qq0f275f.jpg" alt="image-20190808234108517"></p><p><img src="http://tva1.sinaimg.cn/large/0060lm7Tly1g5spg61skij30qw0degmp.jpg" alt="image-20190808234134634"></p><p>这几个方案都依赖每天晚上七点执行一次corntab。</p><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>根据开讲时间查询活动表是否有满足条件的线下活动，如果有的话，再通过活动id关联到签到表过滤出send_sms字段为0的uid并关联用户表拿出手机号等信息。发送完成后再统一更新send_sms字段。</p><p>缺点：在并发业务场景下，可能会产生脏读的情况，造成发送多次短信的情况。</p><h2 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h2><p>与方案1很相似，唯一的区别就是查询的时候开启事务用<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html" target="_blank" rel="noopener">SELECT … FOR UPDATE</a> ，这种查询语句的区别就是在<code>SELECT</code>的时候把结果行上锁，从而就能避免脏读，然后再同一个事务中<code>UPDATE</code> send_sms字段，最后<code>commit</code> 。</p><p>缺点：由于发短信不是数据库操作，不可回滚。所以如果执行的过程中发生回滚，就会出现短信已经发出去了，但是数据库发生回滚，send_sms字段置为了0，这就产生了矛盾。而且如果是个耗时的任务可能会出现死锁的问题。</p><h3 id="以下就是执行的逻辑"><a href="#以下就是执行的逻辑" class="headerlink" title="以下就是执行的逻辑"></a>以下就是执行的逻辑</h3><pre><code>BEGIN;SELECT ... FOR UPDATE;UPDATE ... SET send_sms = 1;COMMIT;</code></pre><h2 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h2><p>与方案2很相似，唯一的区别就是一条一条的取数据上锁，然后更新<code>send_sms</code>字段。</p><p>缺点：要写一个循环一直去查询满足条件但还未发送短信的用户。处理不好容易产生死循环以及死锁的问题。</p><h2 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h2><p>这是我目前能想到的最佳方案，直接用<code>SELECT</code>语句选出所有满足条件的手机号码以及短信内容，放入<code>Queue</code>中，然后实现对<code>Queue</code>的处理。处理如下：先用<code>SELECT ... FOR UPDATE</code> 判断<code>send_sms</code>字段的值，如果为0，那就执行发短信，然后更新<code>send_sms</code>字段为1，最后<code>COMMIT</code> 。这样就可以避免多次执行发短信。</p><p>总结：对于这种对实时性要求没那么高的业务场景用<code>Queue</code> 还是非常便利的，让<code>Queue</code> 一条一条的处理，在复杂的系统中还起到了削峰和解耦的作用。大家在工作中有哪些对<code>Queue</code>的应用呢？欢迎留言，一起讨论！</p><p>大家对上面的这些方案有什么建议呢？欢迎留言讨论！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你有关于消息队列的应用么？欢迎留言！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;事情的起因&quot;&gt;&lt;a href=&quot;#事情的起因&quot; class=&quot;headerlink&quot; title=&quot;事情的起因&quot;&gt;&lt;/a&gt;事情的起因&lt;/h2&gt;&lt;p&gt;需求：在每次线下活动的开始的前一天晚上七点给报名参加价值研习社的用户发一条通知短信用户记得准时参加活动。&lt;/p&gt;
&lt;p&gt;备注：因为我们的业务并发不是很大，所以很多场景并没有考虑到并发情况下的一些问题，这个需求正好通过crontab执行，并且加上服务器的自动弹性伸缩，所以相当于模拟了一次并发的业务场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="消息队列" scheme="http://blog.todaycoder.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="数据库" scheme="http://blog.todaycoder.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="业务讨论" scheme="http://blog.todaycoder.cn/tags/%E4%B8%9A%E5%8A%A1%E8%AE%A8%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引的类型</title>
    <link href="http://blog.todaycoder.cn/2019/03/31/MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.todaycoder.cn/2019/03/31/MySQL索引的类型/</id>
    <published>2019-03-31T09:34:10.000Z</published>
    <updated>2019-03-31T12:26:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MySQL索引是面试中最常见的问题，笔者前几天接到一个HR小姐姐的面试电话，小姐姐说公司实行996，问我能不能接受😳，我没996过，我哪里知道996是什么感觉呀啊，我就敷衍的说了一句应该可以吧，然后我回到家仔细想了想，还是委婉的拒绝了面试的邀请。</p><a id="more"></a><p>最有趣的是第一次接受HR小姐姐的技术面试，问了我一堆MySQL索引的问题，这是要闹哪样？被一个HR面试了一堆技术问题，我表示不服(开个玩笑)，侧面也反映了公司估计确实很忙，HR需要通过技术问题过滤掉一部分简历，这样就可以减少开发的时间成本。</p><p>然鹅，上周突然github上的一个996-icu的repository突然就火了，截止到目前已经11K的star了。就是抗议现在很多的公司实行的996政策，很多公司被口诛笔伐，我也看了许多关于996的讨论，我总结的关键点是：开发觉得强制996让他们不爽，把996当成了理所应当让他们不爽。他们觉得如果公司忙可以接受加班，而且大部分的开发如果事情没做完，都会自觉加班。我个人表示赞同这些观点。</p><p>额，说了那么多废话，现在就开始介绍些MySQL索引的类型，其中部分内容参考了《MySQL高性能》。</p><h3 id="MySQL索引的类型"><a href="#MySQL索引的类型" class="headerlink" title="MySQL索引的类型"></a>MySQL索引的类型</h3><p>索引的类型有多种，可以为不同的场景提供更好的性能。在MySQL中，<strong>索引是在存储引擎层工作的</strong>。所以没有统一的索引标准，不同的索引工作方式是不同的，也不是所有的引擎都支持所有的索引类型。以下五种是很常用的索引类型，我们就来分析他们的优点和缺点。</p><blockquote><p>索引优化应该是对查询性能优化最有效的手段了。</p></blockquote><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>  当人们讨论索引的时候，如果没有特殊说明指的就是B-Tree索引，大多数MySQL引擎都是支持这种索引的。不同的MySQL引擎实现B-Tree索引的方法略有不同，各有优势。例如，MyISAM使用前缀压缩技术使得索引的空间更小，但InnoDB则是按照原数据进行存储。再比如MyISAM索引是通过数据的物理地址引用被索引的行，而InnoDB则是通过主键字段引用被索引的行。</p><p>  <strong>B-Tree索引能大大加快查询的效率</strong>。因为查询过程不需要要全表扫描所有的行，只需要从根节点向下搜索，比改节点小的就向左子节点查询，否则就向右子节点查询，最终就能快速的找到要查询的值。</p><p>  假设有如下数据表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</span><br><span class="line">  last_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  first_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  dob <span class="built_in">date</span> <span class="literal">null</span>,</span><br><span class="line">  gender enum(<span class="string">'m'</span>, <span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">key</span>(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>  对于表中的每一行数据，索引包含了<code>last_name</code>, <code>first_name</code>, <code>dob</code>列的值，如下是该索引的存储结构图。</p><div align="center"><img src="http://blog-private.oss-cn-shanghai.aliyuncs.com/2019/03/31/3cbcdd78e6448ecc2b62a5e606c14978.jpg" alt="索引树中部分条目示例"><div style="color:rgb(125,125,125);font-size:12px;">索引树中部分条目示例</div></div><p>需要注意的是对于多列索引，是根据CREATE TABLE时定义索引的顺序来决定的，例如我们上面创建的索引，在节点上是按照<strong>先<code>last_name</code>然后<code>first_name</code>最后<code>dob</code>字段来存储的</strong>，上图右下角当<code>last_name</code>和<code>first_name</code>相等时，是按照生日的日期来排序的。</p><p><strong>可以使用B-Tree索引的查询类型</strong></p><ul><li><p>全值查询</p><p>全值查询是指匹配所有的索引列。例如前面提到的索引可以用于查找姓名为Cuba Allen、出生于1960-01-01的人。</p></li><li><p>匹配最左前缀查询</p><p>匹配最左前缀查询是指按照从左到右的顺序匹配索引字段，例如前面提到的索引用于查询姓为Allen的人。</p></li><li><p>匹配列前缀查询</p><p>匹配列前缀，就是匹配某个列最开头的部分。例如前面提到的索引可用于查找所有以Ja开头的姓。具体查询语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> People <span class="keyword">WHERE</span> last_name <span class="keyword">Like</span> <span class="string">'Ja%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>匹配范围查询</p><p>范围查询顾名思义就是查询一段范围，例如前面提到的索引可用于查询姓<code>Allen</code>到<code>Astaire</code>之间的所有人。</p></li><li><p>匹配某一列并范围匹配到另一列</p><p>前面提到的索引也可以查找所有姓为<code>Allen</code>，并且名字以字母K开头（例如Kim、Karl等）。即第一列<code>lsit_name</code>全匹配，第二列<code>first_name</code>列前缀匹配。</p></li><li><p>只访问索引的查询</p><p>B-Tree支持“只访问索引的查询”，即查询的时候只需要访问索引，无需访问数据行。这种查询方式叫“<strong>覆盖索引</strong>”，简单来说覆盖索引避免了回表查询数据行的开销，提高了查询效率，感兴趣的同学可以自行搜索“覆盖索引“的相关知识。</p></li></ul><p><strong>关于B-Tree索引使用的一些限制</strong></p><ul><li><p>B-Tree索引<strong>如果不是从最左边的列开始查询，则无法使用索引</strong>。例如前面例子中索引无法查询名字为Kim的人，以及也无法查询某个特定生日的人，因为这两列不是最左列。类似也无法查找姓氏以某个字母结尾的人。</p></li><li><p>不能跳过索引的列，前面提到的索引无法查询姓为<code>Allen</code>且生日为1960-01-01的所有人，如果是这样的查询语句，只能用到索引的第一列。</p></li><li><p>如果查询中有某个列用到了范围查询，则其右边的所有列均不能用到索引优化查询。例如这个查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> People <span class="keyword">WHERE</span> last_name=<span class="string">'Allen'</span> <span class="keyword">AND</span> first_name <span class="keyword">like</span> <span class="string">'K%'</span> <span class="keyword">AND</span> dob=<span class="string">'1930-07-12'</span>;</span><br></pre></td></tr></table></figure></li></ul><p>上面的查询语句只能用到索引的前两列，因为第二个查询条件是一个范围查询。如果范围查询的条件是有限的，可以通过多个等值条件查询来代替。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h5><p>  通过上面一系列的讲解，我们可以发现，创建索引的顺序简直太重要了，查询条件的顺序也是非常的重要。我们在工作中创建MySQL表的时候一定要注意避开这些坑。我们会发现，由于业务的变化，我们其实需要回头对原来创建表的结构进行优化，这些优化就包括对索引结构的优化，</p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>  哈希索引（hash index）是基于哈希表实现的，只有精确等值匹配索引所有列的查询才是有效的。在MySQL中只有Memory引擎支持哈希索引，这也是Memory引擎默认的索引类型，下面看一个例子。假设有如下表：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> testhash(</span><br><span class="line">  fname <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  lname <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="keyword">USING</span> <span class="keyword">HASH</span>(fname)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">MEMORY</span>;</span><br></pre></td></tr></table></figure></p><p>  插入数据：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testhash(fname, lname) <span class="keyword">values</span>(<span class="string">'Arjen'</span>, <span class="string">'Lentz'</span>),(<span class="string">'Baron'</span>, <span class="string">'Schwartz'</span>),(<span class="string">'Peter'</span>, <span class="string">'Zitsevo'</span>), (<span class="string">'Vadim'</span>, <span class="string">'Tachenkoe'</span>);</span><br></pre></td></tr></table></figure></p><p>  表数据如下</p><table><thead><tr><th style="text-align:center">fname</th><th style="text-align:center">lname</th></tr></thead><tbody><tr><td style="text-align:center">Arjen</td><td style="text-align:center">Lentz</td></tr><tr><td style="text-align:center">Baron</td><td style="text-align:center">Schwartz</td></tr><tr><td style="text-align:center">Peter</td><td style="text-align:center">Zaitsev</td></tr><tr><td style="text-align:center">Vadim</td><td style="text-align:center">Tkachenko</td></tr></tbody></table><p>  假设有哈希函数f()，他返回如下数据（哈希值都是示例数据）：</p><p>  f(‘Arjen’) = 2098<br>  f(‘Baron’) = 4920<br>  f(‘Peter’) = 8372<br>  f(‘Vadim’) = 5293</p><p>  哈希索引的存储结构如下：</p><table><thead><tr><th style="text-align:center">槽（Slot）</th><th style="text-align:center">值（value）</th></tr></thead><tbody><tr><td style="text-align:center">2098</td><td style="text-align:center">指向第1行</td></tr><tr><td style="text-align:center">4920</td><td style="text-align:center">指向第2行</td></tr><tr><td style="text-align:center">5293</td><td style="text-align:center">指向第4行</td></tr><tr><td style="text-align:center">8372</td><td style="text-align:center">指向第3行</td></tr></tbody></table><p>  现在我们来看如下查询：<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> testhash <span class="keyword">WHERE</span> fname=<span class="string">'Peter'</span>;</span><br></pre></td></tr></table></figure></p><p>  上面的查询语句MySQL先计算’Peter’的哈希值，并使用该值寻找到对应的指针记录，最后一步就是要比较查询的结果是否为’Peter’。哈希索引只需要存储对应的哈希值，所以哈希索引结构比较紧凑，这也使得哈希索引的查询速度非常的快。然而哈希索引也有一些限制：</p><ul><li>哈希索引存储的是行指针，而没有存储行数据，所以每次查询无法避免读取行。</li><li>哈希索引不是按照索引顺序存储的，所以无法用于排序。</li><li>哈希索引不支持部分索引列匹配查询，因为哈希索引存储是全部索引列来计算哈希值的。</li><li>哈希索引只能用于等值查询，不支持任何的范围查询。</li><li><p>如果哈希冲突很多的话，一些索引的维护成本就会很高。</p><p>因为以上这些限制，哈希索引只适用于某些特定的应用场景，而一旦使用哈希索引，则它带来的性能提升是非常明显的。</p></li></ul><h4 id="空间数据索引-R-Tree"><a href="#空间数据索引-R-Tree" class="headerlink" title="空间数据索引(R-Tree)"></a>空间数据索引(R-Tree)</h4><p>  MyISAM表支持空间索引，可以用于地理数据的存储。和B-Tree索引不同，这类索引无需前缀查询。空间索引会从各个维度来索引数据。查询时，可以有效的使用任意维度的组合来查询。必须使用MySQL的GIS相关的的函数，如MBRCONTAINS()等来维护数据。MySQL的GIS函数还不够完善，所以大部分人都不会使用这个特性。开源数据库中对GIS的解决方案做的比较好的是PostgreSQL的PostGIS。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>  全文索引是一种特殊的索引方式，他查找的是文本中的关键词，一般用户关键词检索的业务场景，全文索引更像是类似于搜索引擎做的事。全文索引在实际工作中用的非常的少，一般数据量稍大一点的关键词检索都用elasticsearch这种专门提供搜索引擎的框架。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;MySQL索引是面试中最常见的问题，笔者前几天接到一个HR小姐姐的面试电话，小姐姐说公司实行996，问我能不能接受😳，我没996过，我哪里知道996是什么感觉呀啊，我就敷衍的说了一句应该可以吧，然后我回到家仔细想了想，还是委婉的拒绝了面试的邀请。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://blog.todaycoder.cn/tags/MySQL/"/>
    
      <category term="Text index" scheme="http://blog.todaycoder.cn/tags/Text-index/"/>
    
      <category term="B-Tree index" scheme="http://blog.todaycoder.cn/tags/B-Tree-index/"/>
    
      <category term="Hash index" scheme="http://blog.todaycoder.cn/tags/Hash-index/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务的隔离级别</title>
    <link href="http://blog.todaycoder.cn/2019/03/24/MySQL%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://blog.todaycoder.cn/2019/03/24/MySQL事务的隔离级别/</id>
    <published>2019-03-24T10:22:47.000Z</published>
    <updated>2019-03-27T11:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说道事务，你肯定不陌生，和数据库打交道免不了要用事务。事务最常见的应用就是转账，比如公司发工资，如果当公司的账户转账给员工的瞬间服务器坏了，公司的账户钱变少了，而员工的账户的钱并没有相应的增多，这就很尴尬了。事务的出现就是用来解决这种问题的。</p><p>我们知道MySQL是支持不同的数据库引擎的，在MySQL5.5.5之前，MySQL的默认引擎都是MyISAM，到了5.5.5之后MySQL默认的数据库引擎改为InnoDB，这两个数据库引擎有个最大的区别就是MyISAM引擎是不支持事务的，这就使得MyISAM引擎很难支撑复杂的业务场景，包括金融交易等。</p><a id="more"></a><p>简单来说事务就是保证MySQL的一组操作，要么全部成功，要么全部失败。想下，如果上面转账的例子，引入事务的概念，保证公司账户转出钱和员工账户转入钱要么全部成功，要么全部失败，就可以完美解决问题了。</p><p>提到事务，大家肯定会想到ACID（Atomicity、Consistency、Isolation、Durability即原子性、一致性、隔离性、持久性），下面我们就来对其中之一的隔离性（Isolation）做一些介绍。</p><h3 id="隔离级别（ISOLATION-LEVEL）"><a href="#隔离级别（ISOLATION-LEVEL）" class="headerlink" title="隔离级别（ISOLATION LEVEL）"></a>隔离级别（ISOLATION LEVEL）</h3><p>隔离性其实比想象要复杂。在SQL中定义了四种隔离的级别，每一种隔离级别都规定了一个事务中的修改，哪些是在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常来说能承受更高的并发，系统的开销也会更小。</p><p>下面简单的介绍一下这四种事务的隔离级别，并添加一些实践。</p><h4 id="READ-UNCOMMITTED（未提交读）"><a href="#READ-UNCOMMITTED（未提交读）" class="headerlink" title="READ UNCOMMITTED（未提交读）"></a>READ UNCOMMITTED（未提交读）</h4><p>在READ UNCOMMITTED级别，事务的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个级别的隔离会导致很多问题，虽然在性能方面是最优的，但是缺乏其他级别的很多好处，所以这种隔离的级别很少在实际中应用。</p><ul><li><p>CREATE TABLE</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`point`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>INSERT INTO</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(point) <span class="keyword">VALUES</span>(<span class="number">90</span>);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>READ UNCOMMITTED实践<br>开启两个MySQL SESSION，并将MySQL的默认隔离级别设置为READ UNCOMMITTED</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> UNCOMMITTED;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/3/24/169af28aead94fbc?w=1146&amp;h=120&amp;f=png&amp;s=26732" alt="READ UNCOMMITTED PNG"></p></li></ul><p>  <img src="https://user-gold-cdn.xitu.io/2019/3/24/169af28aecdf58af?w=700&amp;h=350&amp;f=gif&amp;s=3543646" alt="READ UNCOMMITTED GIF"><br>  以上的一段GIF图显示了具体的实践过程，左边部分是SESSION A，右边是SESSION B从上面的实践中我们可以看到，当隔离级别设置为READ COMMITTED：</p><ul><li><strong>SESSION A第一次查询point的值为90</strong></li><li><strong>SESSION B更新point为100</strong></li><li><strong>此时SESSION B的更改并未提交</strong></li><li><strong>SESSION A第二次查询point的值为100</strong>。</li></ul><h4 id="READ-COMMITTED（读已提交）"><a href="#READ-COMMITTED（读已提交）" class="headerlink" title="READ COMMITTED（读已提交）"></a>READ COMMITTED（读已提交）</h4><p>大多数数据库系统默认的隔离级别都是READ COMMITTED(<strong>但MySQL不是</strong>)，”读已提交”简单的定义：一个事务只能看见已经提交的事务的修改结果。换句话说，一个事务从开启事务到提交事务之前，对其他事务都是不可见的，因此在同一个事务中的两次相同查询结果可能不一样。故这种隔离级别有时候也叫不可重复读（NONREPEATABLE READ）。</p><ul><li><p>READ COMMITTED 实践<br><img src="https://user-gold-cdn.xitu.io/2019/3/24/169af28aed1c0f5c?w=1370&amp;h=116&amp;f=png&amp;s=26212" alt="READ COMMITTED PNG"></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/24/169af28aecfb4ab5?w=700&amp;h=380&amp;f=gif&amp;s=4267718" alt="READ COMMMITED GIF"><br>以上的一段GIF图显示了”读已提交”隔离级别下的实践。我们将隔离级别设置为READ COMMITTED，从执行过程我们可以看到：</p><ul><li>第一次<strong>SESSION A查询point为90</strong></li><li><strong>SESSION B更新point为100</strong></li><li>第二次<strong>SESSION A查询point为90</strong></li><li><strong>SESSION B提交事务</strong></li><li>第三次<strong>SESSION A查询point为100</strong></li></ul><p>从实践中我们可以看到当SESSION B的事务提交后，SESSION A就能读取到SESSION B修改的数据。</p></li></ul><h4 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE READ（可重复读）"></a>REPEATABLE READ（可重复读）</h4><p>  “可重复读”是MySQL的默认事务隔离级别。REPEATABLE READ解决了脏读的问题，<strong>该级别保证了在同一次事务中多次查询相同的语句结果是一致的</strong>。但是”可重复读”隔离级别无法避免产生幻行（Phantom Row）的问题，MySQL的InnoDB引擎通过多版本并发控制（MVCC，Multiversion Concurrency Controller）解决了幻读的问题。</p><ul><li><p>REPEATABLE READ 产生幻行的实践<br><img src="https://user-gold-cdn.xitu.io/2019/3/24/169af28aecd45aba?w=700&amp;h=380&amp;f=gif&amp;s=5942106" alt="Phantom_rows"><br>从上面GIF图显示的过程我们可以看到，最后SESSION A查询语句的结果只有一条id为1的数据，但是我们在插入id=2的数据的时候产生了报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1062 (23000): Duplicate entry '2' for key 'PRIMARY'</span><br></pre></td></tr></table></figure><p>从报错中很容易就能看到是因为id=2的行已经存在了，前面读取行数据的结果就是幻读。</p></li><li><p>REPEATABLE READ 实践<br><img src="https://user-gold-cdn.xitu.io/2019/3/24/169af28aeea6f6be?w=1402&amp;h=116&amp;f=png&amp;s=26751" alt="REPEATABLE READ PNG"></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/24/169af28b17fd8de7?w=700&amp;h=379&amp;f=gif&amp;s=3854609" alt="REPEATABLE READ GIF"><br>上面的图片显示了在”可重复读”隔离界别下的实践，我们将隔离界别设置为REPEATABLE READ，我们可以看到：</p><ul><li>第一次<strong>SESSION A查询point为90</strong></li><li><strong>SESSION B更新point为100</strong></li><li>第二次<strong>SESSION A查询point为90</strong></li><li><strong>SESSION B提交事务</strong></li><li>第三次<strong>SESSION A查询point为90</strong></li></ul><p>我们从实践中可以看到无论SESSION B怎么改变，SESSION A在事务开启后同一查询语句查询的结果都是一致的。</p></li></ul><h4 id="SERIALIZABLE（可串行化）"><a href="#SERIALIZABLE（可串行化）" class="headerlink" title="SERIALIZABLE（可串行化）"></a>SERIALIZABLE（可串行化）</h4><p>  SERIALIZABLE是最高的隔离级别，它通常通过强制事务串行，避免了前面说的幻读问题。简单来说，”可串行化”会在读取的每一行数据上都加锁，所以可能会导致大量的锁等待和超时问题，所以在实际的生产环境中也很少会用到这个隔离级别，只有在非常需要确保数据的一致性切可以接受没有并发的情况下，才会考虑使用这个隔离级别。</p><ul><li><p>SERIALIZABLE实践<br><img src="https://user-gold-cdn.xitu.io/2019/3/24/169af28aeea6f6be?w=1402&amp;h=116&amp;f=png&amp;s=26751" alt="REPEATABLE READ PNG"></p><p><img src="https://user-gold-cdn.xitu.io/2019/3/24/169af28b1ab2ae59?w=700&amp;h=385&amp;f=gif&amp;s=4627081" alt="SERIALIZABLE GIF"><br>上面的GIF显示了在”可串行化”隔离级别下的实践。我们将隔离级别设置为SERVILAZABLE，从执行的过程中我们可以看到：</p><ul><li>第一次<strong>SESSION A查询结果只有id=1</strong></li><li><strong>SESSION B 插入id=2的数据</strong>，因为SESSION A的事务还未提交，此时锁等待。</li><li>第二次<strong>SESSION A查询结果仍然是只有一行id=1</strong></li><li><strong>SESSION A提交事务，在提交事务的瞬间SESSION A释放锁，SESSION B锁等待结束</strong></li><li><strong>SESSION B提交事务</strong></li><li>第三次<strong>SEESION A查询结果出现了id=1和id=2这两条记录</strong></li></ul></li></ul><p>  从上面的过程我们可以看到，”可串行化”是通过对每一行数据都加锁的方式来避免幻行问题，这种方式效率非常的低，很容易造成较长时间的锁等待。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章介绍了事务以及四种隔离级别，隔离级别越高对于锁的要求就越高，性能就会相对越差。每一种事务的隔离级别都有对应的应用场景，这些隔离级别没有好坏之分，只是对应不同的业务场景可能需要用到不同的隔离级别。突然想到最近网上很流行的一句话：<strong>小孩子才分对错，成年人只谈利弊</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;说道事务，你肯定不陌生，和数据库打交道免不了要用事务。事务最常见的应用就是转账，比如公司发工资，如果当公司的账户转账给员工的瞬间服务器坏了，公司的账户钱变少了，而员工的账户的钱并没有相应的增多，这就很尴尬了。事务的出现就是用来解决这种问题的。&lt;/p&gt;
&lt;p&gt;我们知道MySQL是支持不同的数据库引擎的，在MySQL5.5.5之前，MySQL的默认引擎都是MyISAM，到了5.5.5之后MySQL默认的数据库引擎改为InnoDB，这两个数据库引擎有个最大的区别就是MyISAM引擎是不支持事务的，这就使得MyISAM引擎很难支撑复杂的业务场景，包括金融交易等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://blog.todaycoder.cn/tags/MySQL/"/>
    
      <category term="隔离级别" scheme="http://blog.todaycoder.cn/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
      <category term="isolation level" scheme="http://blog.todaycoder.cn/tags/isolation-level/"/>
    
  </entry>
  
  <entry>
    <title>一条更新的SQL语句是如何执行的？</title>
    <link href="http://blog.todaycoder.cn/2019/03/16/%E4%B8%80%E6%9D%A1%E6%9B%B4%E6%96%B0%E7%9A%84SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/"/>
    <id>http://blog.todaycoder.cn/2019/03/16/一条更新的SQL语句是如何执行的？/</id>
    <published>2019-03-16T07:09:41.000Z</published>
    <updated>2019-03-16T08:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一条更新SQL语句的执行过程</p></blockquote><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p><code>UPDATE student SET score = score + 1 WHERE uid = 666;</code><br>以上就是一条最简单的SQL更新语句，想要知道上面这句SQL语句是怎么执行的先要了解MySQL数据库的逻辑架构。</p><a id="more"></a><div align="center"><br><img src="https://blog-1252574663.cos.ap-shanghai.myqcloud.com/mysql%E7%BB%93%E6%9E%84%E5%9B%BE.png" width="500px"></div><br>UPDATE语句也不例外的执行这个流程，先连接数据库（连接器），然后将SQL语句进行词法分析，并检测SQL语法（分析器），然后优化对应的查询操作（优化器），最后真正的去执行这个语句（执行器）。<br><br>具体到上面的UPDATE语句，先取出uid=666的所有行，然后将这些行的score字段的值加1，并写入内存中。接下来的过程与查询语句的查询流程就不一样了，查询语句只需要返回查询结果即可，但是更新语句需要去真的修改数据库中的数据，所以更新语句相对来讲要复杂一些。<br><br>说到SQL的更新语句就不得不提到<strong>重做日志(redo log)</strong> 和<strong>归档日志(binlog)</strong>，这两个日志在MySQL中起到了巨大的作用，这两个日志的相互配合也是很有意思的设计，接下来就要详细给大家讲下这两种日志的作用、它们是如何工作的、以及它们之间的相互配合。<br><br>### redo log<br><br>redo log是为了<strong>解决crash-safe问题</strong>而产生的，是一种物理日志，我们知道数据库是用来存储数据的，crash-safe问题对于数据库来说是非常重要的，在开启redo log之后MySQL的异常重启之前提交的数据都不会丢失，这样就能保证异常crash后数据不会丢失。<br><br>redo log是<strong>InnoDB引擎层</strong>的一种日志，是用来记录这个页”做了什么改动”。在MySQL中经常会说道<strong>WAL</strong>技术，WAL的全称是<strong>Write Ahead Logging</strong>，WAL的核心思想就是日志先行，举个例子，执行一条更新语句，InnoDB就会先把记录写到redo log里面，然后更新到内存，等到系统比较空闲的时候再写入磁盘。redo log的文件大小是固定的，是通过循环写的<br>实现的。<br><br>有了redo log就能保证InnoDB即使发生异常重启也不会丢失数据，这种能力也叫做crash-safe的能力<br><br>### binlog<br><br>binlog是一种逻辑日志，是<strong>Server层</strong>的一种日志，记录了所有的sql语句，主要是用来配合备份来恢复数据库的，只要我们有最近一次的备份和这期间完整的binlog就能够恢复数据库了。<br>下面我们来简单看下binlog文件，我是ubuntu系统，这个文件是放在<code>/var/log/mysql/</code>文件夹下面的，<br><div align="center"><br><img src="https://blog-1252574663.cos.ap-shanghai.myqcloud.com/binlog1.png" width="500px"></div><p>从上面的图片我们能看到文件名字是依次增加的，与redo log的循环写不同，binlog是追加写的。<br>我们执行下面的命令行就能看到binlog记录的sql语句是什么样的，还有一些binlog文件内容的参照 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlbinlog-row-events.html" target="_blank" rel="noopener">官方文档</a>操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysqlbinlog /var/log/mysql/mysql-bin.000002 --base64-output=DECODE-ROWS --verbose —verbose</span><br></pre></td></tr></table></figure><p>执行的结果如下图所示：</p><div align="center"><br>  <img src="https://blog-1252574663.cos.ap-shanghai.myqcloud.com/mysqlbinlog.png" width="500px"><br></div><p>从上图来看很清晰的能看懂这个update语句执行的含义。</p><p>上面讲了这么多这两种日志的含义，下面简单总结下这两种日志的一些区别：</p><ul><li>redo log是一种物理日志，记录是这个页<strong>做了什么改动</strong>，而binlog是逻辑日志，记录是sql语句的原始逻辑。</li><li>redo log的文件大小是固定的，会循环写入文件，所以会覆盖之前的日志。而binlog是追加写，不会覆盖之前的日志。</li><li>redo log是InnoDB引擎层的日志，而binlog是server层的日志。</li></ul><p><strong>有同学会问，为什么要搞两个日志呀？</strong></p><p>我们知道MySQL最开始默认的引擎是MyASIM引擎，根本就不存在crash-safe的问题，binlog只是用来做归档的。在MySQL5.5.5之后将InnoDB作为默认的存储引擎，这样InnoDB就拥有了crash-safe的能力，在MySQL的架构中，引擎是以插件的形式存在的，InnoDB引擎不是MySQL数据库必须的，所以也就好理解redo log也不是MySQL数据库必须的日志。</p><p>这也就好理解为什么要搞两个日志，一个是server层，一个是引擎层，他们负责不同的功能，相互合作。</p><p>那具体这两个日志是怎么合作的呢？他们怎么保证数据的一致性呢？</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>先说下两阶段提交的具体过程：</p><ul><li>UPDATE语句的结果写入内存，同时将这个操作写入redo log，此时redo log处于prepare状态，并告知执行器随时可以提交事物。</li><li>执行器生成这个操作的binlog，并写入binlog日志。</li><li>执行器通知将之前处于prepare状态改为commit状态，更新完成。</li></ul><p>两个阶段提交保证了redo log和binlog的一致性。<br>下面来分析下如果不是两个阶段提交会发生什么？</p><h4 id="先写redo-log后写binlog"><a href="#先写redo-log后写binlog" class="headerlink" title="先写redo log后写binlog"></a>先写redo log后写binlog</h4><p>如果先写redo log再写binlog的话，当redo log写完的时候发生了crash，此时binlog里面是没有记录的。这时候发生重启，redo log会恢复crash的语句，但是如果用这产生时的binlog去恢复数据库就会丢失这条记录，此时两个日志恢复的数据库数据就产生了差异。</p><h4 id="先写binlog后写redo-log"><a href="#先写binlog后写redo-log" class="headerlink" title="先写binlog后写redo log"></a>先写binlog后写redo log</h4><p>如果是先写binlog后写redo log，当写完binlog的时候发生了crash。这时候发生重启，redo log中还没写，此时异常重启后这个事务是无效的，所以无法恢复，但是binlog中有这条数据，当用此时的binlog文件去恢复数据库的时候，就会比当前的数据库数据多一条记录。</p><p><strong>从上面就可以明白，如果不用两阶段提交就有可能出现两个日志状态不一致。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一条更新SQL语句的执行过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;提出问题&quot;&gt;&lt;a href=&quot;#提出问题&quot; class=&quot;headerlink&quot; title=&quot;提出问题&quot;&gt;&lt;/a&gt;提出问题&lt;/h3&gt;&lt;p&gt;&lt;code&gt;UPDATE student SET score = score + 1 WHERE uid = 666;&lt;/code&gt;&lt;br&gt;以上就是一条最简单的SQL更新语句，想要知道上面这句SQL语句是怎么执行的先要了解MySQL数据库的逻辑架构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://blog.todaycoder.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>01 | 基础架构：一条SQL查询语句是如何执行的？</title>
    <link href="http://blog.todaycoder.cn/2019/03/04/how-to-execute-a-select-query-with-mysql/"/>
    <id>http://blog.todaycoder.cn/2019/03/04/how-to-execute-a-select-query-with-mysql/</id>
    <published>2019-03-04T04:32:07.000Z</published>
    <updated>2020-03-29T09:22:38.716Z</updated>
    
    <content type="html"><![CDATA[<p>学习笔记：</p><h3 id="MySQL基本架构图"><a href="#MySQL基本架构图" class="headerlink" title="MySQL基本架构图"></a>MySQL基本架构图</h3><blockquote><p>其实一条SQL的查询语句的执行并不是很复杂！</p></blockquote><p>我们就从最简单的一条查询语句来入手分析这个问题。<br>比如一条<code>SELECT * FROM T WHERE ID=10;</code>这样的语句它的整个执行的流程是怎么样的呢？</p><a id="more"></a><p><img src="https://blog-1252574663.cos.ap-shanghai.myqcloud.com/mysql%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="img"></p><p>上图就是MySQL的结构图，从结构上我们能看到MySQL的结构主要分为两层：</p><ul><li>server层<br>主要包括：连接器、查询缓存、分析器、优化器、执行器等</li><li>引擎层<br>引擎层主要是负责数据的存储和读取</li></ul><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器主要是负责连接MySQL客户端并获取权限以及维持连接状态。我们想要执行MySQL语句之前先要连接MySQL客户端，执行语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h $hostname -P $port -u $user -p</span><br></pre></td></tr></table></figure><p>执行上面语句的时候会出现以下两种情况：</p><ul><li>如果用户名或者密码不正确则会出现报错<code>ERROR 1045 (28000): Access denied for user &#39;test&#39;@&#39;localhost&#39; (using password: NO)</code>，相信这个报错大多数用过MySQL的人都遇到过，从字面上也很好理解，访问拒绝对于test这个用户，然后程序结束。</li><li>如果用户名和密码正确则会进入MySQL客户端界面。在进入之前，MySQL会根据用户名查询出该用户拥有的权限，这个连接中的所有权限校验都是依赖于之前查询的权限。</li></ul><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><blockquote><p><strong>NOTE</strong><br>The query cache is deprecated as of MySQL 5.7.20, and is removed in MySQL 8.0</p></blockquote><p>查询缓存是指输入查询语句，MySQL会优先执行查询缓存，如果命中缓存则直接返回查询结果。在MySQL中对于每次查询的结果会有缓存，每次有对于数据库表结构或者数据的修改，缓存就会失效。如果没有命中缓存就会继续往下执行。<br>所以在大多数情况下缓存的命中率是很低的，除非是一张更新频率非常低的静态表，否则缓存的命中率会非常的低。MySQL官方也是在MySQL8.0中放弃了对于查询缓存的支持。所以在大多数情况下是不建议使用查询缓存的。<br>关于查询缓存的配置请参考官方文档操作：<a href="https://dev.mysql.com/doc/refman/5.7/en/query-cache-configuration.html" target="_blank" rel="noopener">Query Cache Configuration</a></p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>没有命中缓存，就要开始执行真正的执行语句了。分析器的工作主要是对输入的SQL语句做解析。<br>首先会做”词法分析”，当你输入一窜SQL语句的时候，系统要先能识别T是一个表名，ID是字段名，WHERE和SELECT是一个MySQL的关键字…等。<br>做完了这些之后就会进行”语法分析”，语法分析就是判断这些关键字是否合法，如果你输入的SQL语句语法不正确就是有提示，比如WHERE关键字少个W</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM T HERE ID = 10;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;ID = 10&apos; at line 1</span><br></pre></td></tr></table></figure><p>通过以上的输出，我们能看到语法的检测是在分析器阶段执行的，如果遇到syntax error，只需要关注<code>use near</code>关键字后面的部分。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器顾名思义就是对SQL语句做优化的步骤，那就有同学有问题了，SQL语句都写好了，MySQL系统还能对其做优化？答案是：当然能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t1 JOIN t2 ON `id` WHERE t1.a = 10 AND t2.b = 20;</span><br></pre></td></tr></table></figure><p>上面是一条简单的SQL语句，系统的执行顺序可以如下：</p><ul><li>可以先查询t1表中a字段等于10的数据,然后根据查询结果通过ID关联t2表，判断t2表中的b字段是否等于20。</li><li>也可以先查询t2表中b字段等于20的数据，然后根据插叙结果通过ID关联到t1表，判断t1表a字段是否等于10。</li></ul><p>还有一些是关于数据库索引的优化，这个部分比较复杂，后面会单独讲到。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>当前面几个步骤完成的时候就开始进入到执行器阶段，执行器首先会做权限校验，判断当前用户是否有该SQL语句的操作权限，如果没有则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM t;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): DELETE command denied to user &apos;test&apos;@&apos;localhost&apos; for table &apos;t&apos;</span><br></pre></td></tr></table></figure><p>如果权限校验也通过就会真正的执行查询，查询是通过调用引擎提供的API。</p><h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>引擎层是通过插件的形式存在的，存储引擎负责MySQL中数据的储存和提取。服务器通过API与储存引擎行进通信，这些API屏蔽了不同引擎之间的差异，使得引擎的差异对服务层没有影响。不同的数据存储引擎之间也是不通信的，互相之间不会影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习笔记：&lt;/p&gt;
&lt;h3 id=&quot;MySQL基本架构图&quot;&gt;&lt;a href=&quot;#MySQL基本架构图&quot; class=&quot;headerlink&quot; title=&quot;MySQL基本架构图&quot;&gt;&lt;/a&gt;MySQL基本架构图&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;其实一条SQL的查询语句的执行并不是很复杂！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们就从最简单的一条查询语句来入手分析这个问题。&lt;br&gt;比如一条&lt;code&gt;SELECT * FROM T WHERE ID=10;&lt;/code&gt;这样的语句它的整个执行的流程是怎么样的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://blog.todaycoder.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>编程中常见英文汇总（赶紧收藏!!!）</title>
    <link href="http://blog.todaycoder.cn/2018/11/20/%E7%BC%96%E7%A8%8B%E4%B8%AD%E5%B8%B8%E8%A7%81%E8%8B%B1%E6%96%87%E6%B1%87%E6%80%BB%EF%BC%88%E8%B5%B6%E7%B4%A7%E6%94%B6%E8%97%8F%EF%BC%89/"/>
    <id>http://blog.todaycoder.cn/2018/11/20/编程中常见英文汇总（赶紧收藏）/</id>
    <published>2018-11-20T14:53:51.000Z</published>
    <updated>2018-11-20T14:58:31.189Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>A<br>abstract 抽象的<br>abstract base class (ABC)抽象基类<br>abstract class 抽象类<br>abstraction 抽象、抽象物、抽象性<br>access 存取、访问<br>access function 访问函数<br>access level访问级别<br>account 账户<br>action 动作<br>activate 激活<br>active 活动的<br>actual parameter 实参</p><a id="more"></a><p>adapter 适配器<br>add-in 插件<br>address 地址<br>address space 地址空间<br>ADO(ActiveX Data Object)ActiveX数据对象<br>advanced 高级的<br>aggregation 聚合、聚集<br>algorithm 算法<br>alias 别名<br>align 排列、对齐<br>allocate 分配、配置<br>allocator分配器、配置器<br>angle bracket 尖括号<br>annotation 注解、评注<br>API (Application Programming Interface) 应用(程序)编程接口<br>appearance 外观<br>append 附加<br>application 应用、应用程序<br>application framework 应用程序框架<br>Approximate String Matching 模糊匹配<br>architecture 架构、体系结构<br>archive file 归档文件、存档文件<br>argument参数。<br>array 数组<br>arrow operator 箭头操作符<br>assert(ion) 断言<br>assign 赋值<br>assignment 赋值、分配<br>assignment operator 赋值操作符<br>associated 相关的、相关联的<br>asynchronous 异步的<br>attribute 特性、属性<br>authentication service 验证服务<br>authorization 授权</p></li><li><p>B<br>background 背景、后台(进程)<br>backup 备份<br>backup device备份设备<br>backup file 备份文件<br>backward compatible 向后兼容、向下兼容<br>base class 基类<br>base type 基类型<br>batch 批处理<br>BCL (base class library)基类库<br>Bin Packing 装箱问题<br>binary 二进制<br>binding 绑定<br>bit 位<br>bitmap 位图<br>block 块、区块、语句块<br>boolean 布林值(真假值，true或false)<br>border 边框<br>bounds checking 边界检查<br>boxing 装箱、装箱转换<br>brace (curly brace) 大括号、花括号<br>bracket (square brakcet) 中括号、方括号<br>breakpoint 断点<br>browser applications 浏览器应用(程序)<br>browser-accessible application 可经由浏览器访问的应用程序<br>bug 缺陷错误<br>build 编连(专指编译和连接)<br>built-in 内建、内置<br>bus 总线<br>business 业务、商务(看场合)<br>business Logic 业务逻辑<br>business rules 业务规则<br>buttons 按钮<br>by/through 通过<br>byte 位元组(由8 bits组成)</p></li><li>C<br>cache 高速缓存<br>calendar 日历<br>Calendrical Calculations 日期<br>call 调用<br>call operator 调用操作符<br>callback 回调<br>candidate key 候选键 (for database)<br>cascading delete 级联删除 (for database)<br>cascading update 级联更新 (for database)<br>casting 转型、造型转换<br>catalog 目录<br>chain 链(function calls)<br>character 字符<br>character format 字符格式<br>character set 字符集<br>check box 复选框<br>check button 复选按钮<br>CHECK constraints CHECK约束 (for database)<br>checkpoint 检查点 (for database)<br>child class 子类<br>CIL (common intermediate language)通用中间语言、通用中介语言<br>class 类<br>class declaration 类声明<br>class definition 类定义<br>class derivation list 类继承列表<br>class factory 类厂<br>class hierarchy 类层次结构<br>class library 类库<br>class loader 类装载器<br>class template 类模板<br>class template partial specializations 类模板部分特化<br>class template specializations 类模板特化<br>classification 分类<br>clause 子句<br>cleanup 清理、清除<br>CLI (Common Language Infrastructure) 通用语言基础设施<br>client 客户、客户端<br>client application 客户端应用程序<br>client area 客户区<br>client cursor 客户端游标 (for database)<br>client-server 客户机/服务器、客户端/服务器<br>clipboard 剪贴板<br>clone 克隆<br>CLS (common language specification) 通用语言规范<br>code access security 代码访问安全<br>code page 代码页<br>COFF (Common Object File Format) 通用对象文件格式<br>collection 集合<br>COM (Component Object Model) 组件对象模型<br>combo box 组合框<br>command line 命令行<br>comment 注释<br>commit 提交 (for database)<br>communication 通讯<br>compatible 兼容<br>compile time 编译期、编译时<br>compiler 编译器<br>component组件<br>composite index 复合索引、组合索引 (for database)<br>composite key 复合键、组合键 (for database)<br>composition 复合、组合<br>concept 概念<br>concrete具体的<br>concrete class 具体类<br>concurrency 并发、并发机制<br>configuration 配置、组态<br>Connected Components 连通分支<br>connection 连接 (for database)<br>connection pooling 连接池<br>console 控制台<br>constant 常量<br>Constrained and Unconstrained Optimization 最值问题<br>constraint 约束 (for database)<br>construct 构件、成分、概念、构造（for language）<br>constructor (ctor) 构造函数、构造器<br>container 容器<br>containment包容<br>context 环境、上下文<br>control 控件<br>cookie<br>copy 拷贝<br>CORBA 通用对象请求中介架构(Common Object Request Broker Architecture)<br>cover 覆盖、涵盖<br>create/creation 创建、生成<br>crosstab query 交叉表查询 (for database)<br>Cryptography 密码<br>CTS (common type system)通用类型系统<br>cube 多维数据集 (for database)<br>cursor 光标<br>cursor 游标 (for database)<br>custom 定制、自定义</li><li>D<br>data 数据<br>data connection 数据连接 (for database)<br>data dictionary 数据字典 (for database)<br>data file 数据文件 (for database)<br>data integrity 数据完整性 (for database)<br>data manipulation language (DML)数据操作语言(DML) (for database)<br>data member 数据成员、成员变量<br>data source 数据源 (for database)<br>Data source name (DSN) 数据源名称(DSN) (for database)<br>data structure数据结构<br>Data Structures 基本数据结构<br>data table 数据表 (for database)<br>data-bound 数据绑定 (for database)<br>database 数据库 (for database)<br>database catalog 数据库目录 (for database)<br>database diagram 数据关系图 (for database)<br>database file 数据库文件 (for database)<br>database object 数据库对象 (for database)<br>database owner 数据库所有者 (for database)<br>database project 数据库工程 (for database)<br>database role 数据库角色 (for database)<br>database schema 数据库模式、数据库架构 (for database)<br>database script 数据库脚本 (for database)<br>datagram 数据报文<br>dataset 数据集 (for database)<br>dataset 数据集 (for database)<br>DBMS (database management system)数据库管理系统 (for database)<br>DCOM (distributed COM)分布式COM<br>dead lock 死锁 (for database)<br>deallocate 归还<br>debug 调试<br>debugger 调试器<br>decay 退化<br>declaration 声明<br>default 缺省、默认值<br>DEFAULT constraint默认约束 (for database)<br>default database 默认数据库 (for database)<br>default instance 默认实例 (for database)<br>default result set 默认结果集 (for database)<br>defer 推迟<br>definition 定义<br>delegate 委托<br>delegation 委托<br>deploy 部署<br>derived class 派生类<br>design pattern 设计模式<br>destroy 销毁<br>destructor(dtor)析构函数、析构器<br>device 设备<br>DHTML (dynamic HyperText Markup Language)动态超文本标记语言<br>dialog 对话框<br>Dictionaries 字典<br>digest 摘要<br>digital 数字的<br>directive (编译)指示符<br>directory 目录<br>disassembler 反汇编器<br>DISCO (Discovery of Web Services)Web Services的查找<br>dispatch 调度、分派、派发<br>distributed computing 分布式计算<br>distributed query 分布式查询 (for database)<br>DNA (Distributed interNet Application) 分布式网间应用程序<br>document 文档<br>DOM (Document Object Model)文档对象模型<br>dot operator (圆)点操作符<br>double-byte character set (DBCS)双字节字符集(DBCS)<br>driver 驱动(程序)<br>DTD (document type definition) 文档类型定义<br>dump 转储<br>dump file 转储文件</li><li>E<br>e-business 电子商务<br>efficiency 效率<br>efficient 高效<br>encapsulation 封装<br>end user 最终用户<br>end-to-end authentication 端对端身份验证<br>engine 引擎<br>entity 实体<br>enum (enumeration) 枚举<br>enumerators 枚举成员、枚举器<br>equal 相等<br>equality 相等性<br>equality operator 等号操作符<br>error log 错误日志 (for database)<br>escape character 转义符、转义字符<br>escape code 转义码<br>evaluate 评估<br>event 事件<br>event driven 事件驱动的<br>event handler 事件处理器<br>evidence 证据<br>exception 异常<br>exception declaration 异常声明<br>exception handling 异常处理、异常处理机制<br>exception specification 异常规范<br>exception-safe 异常安全的<br>exit 退出<br>explicit 显式<br>explicit specialization 显式特化<br>explicit transaction 显式事务 (for database)<br>export 导出<br>expression 表达式</li><li>F<br>fat client 胖客户端<br>feature 特性、特征<br>fetch 提取<br>field 字段 (for database)<br>field 字段(java)<br>field length 字段长度 (for database)<br>file 文件<br>filter 筛选 (for database)<br>finalization 终结<br>finalizer 终结器<br>firewall 防火墙<br>flag 标记<br>flash memory 闪存<br>flush 刷新<br>font 字体<br>foreign key (FK) 外键(FK) (for database)<br>form 窗体<br>formal parameter 形参<br>forward declaration 前置声明<br>forward-only 只向前的<br>forward-only cursor 只向前游标 (for database)<br>framework 框架<br>full specialization 完全特化<br>function 函数<br>function call operator (即operator ()) 函数调用操作符<br>function object 函数对象<br>function template函数模板<br>functionality 功能<br>functor 仿函数</li><li>G<br>GC (Garbage collection) 垃圾回收(机制)、垃圾收集(机制)<br>generate 生成<br>generic 泛化的、一般化的、通用的<br>generic algorithm通用算法<br>genericity 泛型<br>getter (相对于 setter)取值函数<br>global 全局的<br>global object 全局对象<br>grant 授权 (for database)<br>group 组、群<br>group box 分组框<br>GUI 图形界面<br>GUID (Globally Unique Identifier) 全球唯一标识符</li><li>H<br>handle 句柄<br>handler 处理器<br>hard disk 硬盘<br>hard-coded 硬编码的<br>hard-copy 截屏图<br>hardware 硬件<br>hash table 散列表、哈希表<br>header file头文件<br>heap 堆<br>help file 帮助文件<br>hierarchical data 阶层式数据、层次式数据<br>hierarchy 层次结构、继承体系<br>high level 高阶、高层<br>hook 钩子<br>Host (application)宿主(应用程序)<br>hot key 热键<br>HTML (HyperText Markup Language) 超文本标记语言<br>HTTP (HyperText Transfer Protocol) 超文本传输协议<br>HTTP pipeline HTTP管道<br>hyperlink 超链接</li><li>I<br>icon 图标<br>IDE (Integrated Development Environment)集成开发环境<br>identifier 标识符<br>IDL (Interface Definition Language) 接口定义语言<br>idle time 空闲时间<br>if and only if当且仅当<br>IL (Intermediate Language) 中间语言、中介语言<br>image 图象<br>IME 输入法<br>immediate base 直接基类<br>immediate derived 直接派生类<br>immediate updating 即时更新 (for database)<br>implement 实现<br>implementation 实现、实现品<br>implicit 隐式<br>implicit transaction隐式事务 (for database)<br>import 导入<br>incremental update 增量更新 (for database)<br>Independent Set 独立集<br>index 索引 (for database)<br>infinite loop 无限循环<br>infinite recursive 无限递归<br>information 信息<br>inheritance 继承、继承机制<br>initialization 初始化<br>initialization list 初始化列表、初始值列表<br>initialize 初始化<br>inline 内联<br>inline expansion 内联展开<br>inner join 内联接 (for database)<br>instance 实例<br>instantiated 具现化、实体化(常应用于template)<br>instantiation 具现体、具现化实体(常应用于template)<br>integrate 集成、整合<br>integrity 完整性、一致性<br>integrity constraint完整性约束 (for database)<br>interacts 交互<br>interface 接口<br>interoperability 互操作性、互操作能力<br>interpreter 解释器<br>introspection 自省<br>invariants 不变性<br>invoke 调用<br>isolation level 隔离级别 (for database)<br>item 项、条款、项目<br>iterate 迭代<br>iteration 迭代(回圈每次轮回称为一个iteration)<br>iterative 反复的、迭代的<br>iterator 迭代器</li><li>J<br>JIT compilation JIT编译即时编译<br>Job Scheduling 工程安排</li><li>K<br>key 键 (for database)<br>key column 键列 (for database)</li><li>L<br>left outer join 左向外联接 (for database)<br>level 阶、层例<br>library 库<br>lifetime 生命期、寿命<br>Linear Programming 线性规划<br>link 连接、链接<br>linkage 连接、链接<br>linker 连接器、链接器<br>list 列表、表、链表<br>list box 列表框<br>literal constant 字面常数<br>livelock 活锁 (for database)<br>load 装载、加载<br>load balancing 负载平衡<br>loader 装载器、载入器<br>local 局部的<br>local object 局部对象<br>lock 锁<br>log 日志<br>login 登录<br>login security mode登录安全模式 (for database)<br>lookup table 查找表 (for database)<br>loop 循环<br>loose coupling 松散耦合<br>lvalue 左值</li><li>M<br>machine code 机器码、机器代码<br>macro 宏<br>maintain 维护<br>managed code 受控代码、托管代码<br>Managed Extensions 受控扩充件、托管扩展<br>managed object 受控对象、托管对象<br>manifest 清单<br>many-to-many relationship 多对多关系 (for database)<br>many-to-one relationship 多对一关系 (for database)<br>marshal 列集<br>Matching 匹配<br>member 成员<br>member access operator 成员取用运算子(有dot和arrow两种)<br>member function 成员函数<br>member initialization list成员初始值列表<br>memory 内存<br>memory leak 内存泄漏<br>menu 菜单<br>message 消息<br>message based 基于消息的<br>message loop 消息环<br>message queuing消息队列<br>metadata 元数据<br>metaprogramming元编程<br>method 方法<br>micro 微<br>middle tier 中间层<br>middleware 中间件<br>modeling 建模<br>modeling language 建模语言<br>modem 调制解调器<br>modifier 修饰字、修饰符<br>module 模块<br>most derived class最底层的派生类<br>mouse 鼠标<br>multi-tasking 多任务<br>multi-thread 多线程<br>multicast delegate 组播委托、多点委托<br>multithreaded server application 多线程服务器应用程序<br>multiuser 多用户<br>mutable 可变的<br>mutex 互斥元、互斥体</li><li>N<br>named parameter 命名参数<br>named pipe 命名管道<br>namespace 名字空间、命名空间<br>native 原生的、本地的<br>native code 本地码、本机码<br>nested class 嵌套类<br>nested query 嵌套查询 (for database)<br>nested table 嵌套表 (for database)<br>network 网络<br>network card 网卡<br>Network Flow 网络流</li><li>O<br>object 对象<br>object based 基于对象的<br>object model 对象模型<br>object oriented 面向对象的<br>ODBC data source ODBC数据源 (for database)<br>ODBC driver ODBC驱动程序 (for database)<br>one-to-many relationship 一对多关系 (for database)<br>one-to-one relationship 一对一关系 (for database)<br>operating system (OS) 操作系统<br>operation 操作<br>operator 操作符、运算符<br>option 选项<br>outer join 外联接 (for database)<br>overflow 上限溢位(相对于underflow)<br>overload 重载<br>override 覆写、重载、重新定义</li><li>P<br>package 包<br>packaging 打包<br>palette 调色板<br>parallel 并行<br>parameter 参数、形式参数、形参<br>parameter list 参数列表<br>parameterize 参数化<br>parent class 父类<br>parentheses 圆括弧、圆括号<br>parse 解析<br>parser 解析器<br>part 零件、部件<br>partial specialization 局部特化<br>pass by reference 引用传递<br>pass by value 值传递<br>pattern 模式<br>persistence 持久性<br>pixel 像素<br>placeholder 占位符<br>platform 平台<br>Point Location 位置查询<br>pointer 指针<br>polymorphism 多态<br>pooling 池化<br>pop up 弹出式<br>port 端口<br>postfix 后缀<br>precedence 优先序(通常用于运算子的优先执行次序)<br>prefix 前缀<br>preprocessor 预处理器<br>primary key (PK)主键(PK) (for database)<br>primary table 主表 (for database)<br>primitive type 原始类型<br>print 打印<br>printer 打印机<br>procedure 过程<br>process 进程<br>program 程序<br>programmer 程序员<br>programming编程、程序设计<br>progress bar 进度指示器<br>project 项目、工程<br>property 属性<br>protocol 协议<br>pseudo code伪码</li><li>Q<br>qualified 合格的<br>qualifier 修饰符<br>quality 质量<br>queue 队列</li><li>R<br>radio button 单选按钮<br>random number 随机数<br>Random Number Generation 随机数生成<br>range 范围、区间<br>rank 等级<br>raw 未经处理的<br>re-direction 重定向<br>readOnly只读<br>record 记录 (for database)<br>recordset 记录集 (for database<br>recursion —— 递归<br>recursive 递归<br>refactoring 重构<br>refer 引用、参考<br>reference 引用、参考<br>reflection 反射<br>refresh data 刷新数据 (for database)<br>register 寄存器<br>regular expression 正则表达式<br>relational database 关系数据库<br>remote 远程<br>remote request 远程请求<br>represent 表述，表现<br>resolution 解析过程<br>resolve 解析、决议<br>result set 结果集 (for database)<br>retrieve data 检索数据<br>return 返回<br>return type 返回类型<br>return value 返回值<br>revoke 撤销<br>right outer join 右向外联接 (for database)<br>robust 健壮<br>robustness 健壮性<br>roll back 回滚 (for database)<br>roll forward 前滚 (for database)<br>routine 例程<br>row 行 (for database)<br>rowset 行集 (for database)<br>RPC (remote procedure call)RPC(远程过程调用)<br>runtime 执行期、运行期、执行时、运行时<br>rvalue 右值</li><li>S<br>Satisfiability 可满足性<br>save 保存<br>savepoint 保存点 (for database)<br>SAX (Simple API for XML)<br>scalable 可伸缩的、可扩展的<br>schedule 调度<br>scheduler 调度程序<br>schema 模式、纲目结构<br>scope 作用域、生存空间<br>screen 屏幕<br>scroll bar滚动条<br>SDK (Software Development Kit)软件开发包<br>sealed class 密封类<br>search 查找<br>Searching 查找<br>semantics 语义<br>sequential container序列式容器<br>serial 串行<br>serialization/serialize 序列化<br>server 服务器、服务端<br>session 会话 (for database)<br>Set and String Problems 集合与串的问题<br>Set Cover 集合覆盖<br>Set Data Structures 集合<br>Set Packing 集合配置<br>setter 设值函数<br>side effect 副作用<br>signature 签名<br>single-threaded 单线程<br>slider滑块<br>slot 槽<br>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议<br>snapshot 截屏图<br>snapshot 快照 (for database)<br>SOAP (simple object access protocol) 简单对象访问协议<br>software 软件<br>Sorting 排序<br>source code 源码、源代码<br>specialization 特化<br>specification 规范、规格<br>splitter 切分窗口<br>SQL (Structured Query Language) 结构化查询语言 (for database)<br>stack 栈、堆栈<br>standard library 标准库<br>standard template library 标准模板库<br>stateless 无状态的<br>statement 语句、声明<br>static cursor 静态游标 (for database)<br>static SQL statements 静态SQL语句 (for database)<br>status bar 状态条<br>stored procedure 存储过程 (for database)<br>stream 流<br>string 字符串<br>String Matching 模式匹配<br>stub 存根<br>subobject子对象<br>subquery 子查询 (for database)<br>subscript operator 下标操作符<br>support 支持<br>suspend 挂起<br>symbol 记号<br>syntax 语法<br>system databases 系统数据库 (for database)<br>system tables 系统表 (for database)</li><li>T<br>table 表 (for database)<br>table-level constraint 表级约束 (for database)<br>target 标的,目标<br>task switch 工作切换<br>TCP (Transport Control Protocol) 传输控制协议<br>template 模板<br>temporary object 临时对象<br>temporary table 临时表 (for database)<br>text 文本<br>Text Compression 压缩<br>text file 文本文件<br>thin client 瘦客户端<br>third-party 第三方<br>thread 线程<br>thread-safe 线程安全的<br>throw 抛出、引发(常指发出一个exception)<br>trace 跟踪<br>transaction 事务 (for database)<br>transaction log 事务日志 (for database)<br>transaction rollback 事务回滚 (for database)<br>traverse 遍历<br>trigger 触发器 (for database)<br>type 类型</li><li>U<br>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成<br>UML (unified modeling language)统一建模语言<br>unary function 单参函数<br>unary operator 一元操作符<br>unboxing 拆箱、拆箱转换<br>underflow 下限溢位(相对于overflow)<br>Unicode 统一字符编码标准，采用双字节对字符进行编码<br>Union query 联合查询 (for database)<br>UNIQUE constraints UNIQUE约束 (for database)<br>unique index 唯一索引 (for database)<br>unmanaged code 非受控代码、非托管代码<br>unmarshal 散集<br>unqualified 未经限定的、未经修饰的<br>URI (Uniform Resource identifier) 统一资源标识符<br>URL (Uniform Resource Locator) 统一资源定位器<br>user 用户<br>user interface 用户界面</li><li>V<br>value types 值类型<br>variable 变量<br>vector 向量(一种容器，有点类似array)<br>vendor 厂商<br>viable 可行的<br>video 视频<br>view 视图 (for database)<br>view 视图<br>virtual function 虚函数<br>virtual machine 虚拟机<br>virtual memory 虚拟内存</li><li>W<br>Web Services web服务<br>WHERE clause WHERE子句 (for database)<br>wildcard characters 通配符字符 (for database)<br>wildcard search 通配符搜索 (for database)<br>window 窗口<br>window function 窗口函数<br>window procedure 窗口过程<br>Windows authentication Windows身份验证<br>wizard 向导<br>word 单词<br>write enable 写启用 (for database)<br>write-only 只写<br>WSDL (Web Service Description Language)Web Service描述语言</li><li>X<br>XML (eXtensible Markup Language) 可扩展标记语言<br>XML Message Interface (XMI) XML消息接口<br>XSD (XML Schema Definition) XML模式定义语言<br>XSL (eXtensible Stylesheet Language) 可扩展样式表语言<br>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换<br>xxx based 基于xxx的<br>xxx oriented 面向xxx</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;A&lt;br&gt;abstract 抽象的&lt;br&gt;abstract base class (ABC)抽象基类&lt;br&gt;abstract class 抽象类&lt;br&gt;abstraction 抽象、抽象物、抽象性&lt;br&gt;access 存取、访问&lt;br&gt;access function 访问函数&lt;br&gt;access level访问级别&lt;br&gt;account 账户&lt;br&gt;action 动作&lt;br&gt;activate 激活&lt;br&gt;active 活动的&lt;br&gt;actual parameter 实参&lt;/p&gt;
    
    </summary>
    
    
      <category term="英文" scheme="http://blog.todaycoder.cn/tags/%E8%8B%B1%E6%96%87/"/>
    
      <category term="编程" scheme="http://blog.todaycoder.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="翻译" scheme="http://blog.todaycoder.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Typora Emoji</title>
    <link href="http://blog.todaycoder.cn/2018/11/18/Typora-Emoji/"/>
    <id>http://blog.todaycoder.cn/2018/11/18/Typora-Emoji/</id>
    <published>2018-11-18T08:13:01.000Z</published>
    <updated>2018-11-18T08:21:46.327Z</updated>
    
    <content type="html"><![CDATA[<p>People</p><table><thead><tr><th></th><th>😄 <code>:smile:</code></th><th>😆 <code>:laughing:</code></th></tr></thead><tbody><tr><td>😊 <code>:blush:</code></td><td>😃 <code>:smiley:</code></td><td>☺️ <code>:relaxed:</code></td></tr><tr><td>😏 <code>:smirk:</code></td><td>😍 <code>:heart_eyes:</code></td><td>😘 <code>:kissing_heart:</code></td></tr><tr><td>😚 <code>:kissing_closed_eyes:</code></td><td>😳 <code>:flushed:</code></td><td>😌 <code>:relieved:</code></td></tr><tr><td>😆 <code>:satisfied:</code></td><td>😁 <code>:grin:</code></td><td>😉 <code>:wink:</code></td></tr><tr><td>😜 <code>:stuck_out_tongue_winking_eye:</code></td><td>😝 <code>:stuck_out_tongue_closed_eyes:</code></td><td>😀 <code>:grinning:</code></td></tr><tr><td>😗 <code>:kissing:</code></td><td>😙 <code>:kissing_smiling_eyes:</code></td><td>😛 <code>:stuck_out_tongue:</code></td></tr><tr><td>😴 <code>:sleeping:</code></td><td>😟 <code>:worried:</code></td><td>😦 <code>:frowning:</code></td></tr><tr><td>😧 <code>:anguished:</code></td><td>😮 <code>:open_mouth:</code></td><td>😬 <code>:grimacing:</code></td></tr><tr><td>😕 <code>:confused:</code></td><td>😯 <code>:hushed:</code></td><td>😑 <code>:expressionless:</code></td></tr><tr><td>😒 <code>:unamused:</code></td><td>😅 <code>:sweat_smile:</code></td><td>😓 <code>:sweat:</code></td></tr><tr><td>😥 <code>:disappointed_relieved:</code></td><td>😩 <code>:weary:</code></td><td>😔 <code>:pensive:</code></td></tr><tr><td>😞 <code>:disappointed:</code></td><td>😖 <code>:confounded:</code></td><td>😨 <code>:fearful:</code></td></tr><tr><td>😰 <code>:cold_sweat:</code></td><td>😣 <code>:persevere:</code></td><td>😢 <code>:cry:</code></td></tr><tr><td>😭 <code>:sob:</code></td><td>😂 <code>:joy:</code></td><td>😲 <code>:astonished:</code></td></tr><tr><td>😱 <code>:scream:</code></td><td></td><td>😫 <code>:tired_face:</code></td></tr><tr><td>😠 <code>:angry:</code></td><td>😡 <code>:rage:</code></td><td>😤 <code>:triumph:</code></td></tr><tr><td>😪 <code>:sleepy:</code></td><td>😋 <code>:yum:</code></td><td>😷 <code>:mask:</code></td></tr><tr><td>😎 <code>:sunglasses:</code></td><td>😵 <code>:dizzy_face:</code></td><td>👿 <code>:imp:</code></td></tr></tbody></table><a id="more"></a><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>😈 <code>:smiling_imp:</code></td><td>😐 <code>:neutral_face:</code></td><td>😶 <code>:no_mouth:</code></td></tr><tr><td>😇 <code>:innocent:</code></td><td>👽 <code>:alien:</code></td><td>💛 <code>:yellow_heart:</code></td></tr><tr><td>💙 <code>:blue_heart:</code></td><td>💜 <code>:purple_heart:</code></td><td>❤️ <code>:heart:</code></td></tr><tr><td>💚 <code>:green_heart:</code></td><td>💔 <code>:broken_heart:</code></td><td>💓 <code>:heartbeat:</code></td></tr><tr><td>💗 <code>:heartpulse:</code></td><td>💕 <code>:two_hearts:</code></td><td>💞 <code>:revolving_hearts:</code></td></tr><tr><td>💘 <code>:cupid:</code></td><td>💖 <code>:sparkling_heart:</code></td><td>✨ <code>:sparkles:</code></td></tr><tr><td>⭐️ <code>:star:</code></td><td>🌟 <code>:star2:</code></td><td>💫 <code>:dizzy:</code></td></tr><tr><td>💥 <code>:boom:</code></td><td>💥 <code>:collision:</code></td><td>💢 <code>:anger:</code></td></tr><tr><td>❗️ <code>:exclamation:</code></td><td>❓ <code>:question:</code></td><td>❕ <code>:grey_exclamation:</code></td></tr><tr><td>❔ <code>:grey_question:</code></td><td>💤 <code>:zzz:</code></td><td>💨 <code>:dash:</code></td></tr><tr><td>💦 <code>:sweat_drops:</code></td><td>🎶 <code>:notes:</code></td><td>🎵 <code>:musical_note:</code></td></tr><tr><td>🔥 <code>:fire:</code></td><td>💩 <code>:hankey:</code></td><td>💩 <code>:poop:</code></td></tr><tr><td>💩 <code>:shit:</code></td><td>👍 <code>:+1:</code></td><td>👍 <code>:thumbsup:</code></td></tr><tr><td>👎 <code>:-1:</code></td><td>👎 <code>:thumbsdown:</code></td><td>👌 <code>:ok_hand:</code></td></tr><tr><td>👊 <code>:punch:</code></td><td>👊 <code>:facepunch:</code></td><td>✊ <code>:fist:</code></td></tr><tr><td>✌️ <code>:v:</code></td><td>👋 <code>:wave:</code></td><td>✋ <code>:hand:</code></td></tr><tr><td>✋ <code>:raised_hand:</code></td><td>👐 <code>:open_hands:</code></td><td>☝️ <code>:point_up:</code></td></tr><tr><td>👇 <code>:point_down:</code></td><td>👈 <code>:point_left:</code></td><td>👉 <code>:point_right:</code></td></tr><tr><td>🙌 <code>:raised_hands:</code></td><td>🙏 <code>:pray:</code></td><td>👆 <code>:point_up_2:</code></td></tr><tr><td>👏 <code>:clap:</code></td><td>💪 <code>:muscle:</code></td><td>🤘 <code>:metal:</code></td></tr><tr><td>🖕 <code>:fu:</code></td><td>🚶 <code>:walking:</code></td><td>🏃 <code>:runner:</code></td></tr><tr><td>🏃 <code>:running:</code></td><td>👫 <code>:couple:</code></td><td>👪 <code>:family:</code></td></tr><tr><td>👬 <code>:two_men_holding_hands:</code></td><td>👭 <code>:two_women_holding_hands:</code></td><td>💃 <code>:dancer:</code></td></tr><tr><td>👯 <code>:dancers:</code></td><td>🙆 <code>:ok_woman:</code></td><td>🙅 <code>:no_good:</code></td></tr><tr><td>💁 <code>:information_desk_person:</code></td><td>🙋 <code>:raising_hand:</code></td><td>👰 <code>:bride_with_veil:</code></td></tr><tr><td>🙎 <code>:person_with_pouting_face:</code></td><td>🙍 <code>:person_frowning:</code></td><td>🙇 <code>:bow:</code></td></tr><tr><td>:couplekiss: <code>:couplekiss:</code></td><td>💑 <code>:couple_with_heart:</code></td><td>💆 <code>:massage:</code></td></tr><tr><td>💇 <code>:haircut:</code></td><td>💅 <code>:nail_care:</code></td><td>👦 <code>:boy:</code></td></tr><tr><td>👧 <code>:girl:</code></td><td>👩 <code>:woman:</code></td><td>👨 <code>:man:</code></td></tr><tr><td>👶 <code>:baby:</code></td><td>👵 <code>:older_woman:</code></td><td>👴 <code>:older_man:</code></td></tr><tr><td>👱 <code>:person_with_blond_hair:</code></td><td>👲 <code>:man_with_gua_pi_mao:</code></td><td>👳 <code>:man_with_turban:</code></td></tr><tr><td>👷 <code>:construction_worker:</code></td><td>👮 <code>:cop:</code></td><td>👼 <code>:angel:</code></td></tr><tr><td>👸 <code>:princess:</code></td><td>😺 <code>:smiley_cat:</code></td><td>😸 <code>:smile_cat:</code></td></tr><tr><td>😻 <code>:heart_eyes_cat:</code></td><td>😽 <code>:kissing_cat:</code></td><td>😼 <code>:smirk_cat:</code></td></tr><tr><td>🙀 <code>:scream_cat:</code></td><td>😿 <code>:crying_cat_face:</code></td><td>😹 <code>:joy_cat:</code></td></tr><tr><td>😾 <code>:pouting_cat:</code></td><td>👹 <code>:japanese_ogre:</code></td><td>👺 <code>:japanese_goblin:</code></td></tr><tr><td>🙈 <code>:see_no_evil:</code></td><td>🙉 <code>:hear_no_evil:</code></td><td>🙊 <code>:speak_no_evil:</code></td></tr><tr><td>💂 <code>:guardsman:</code></td><td>💀 <code>:skull:</code></td><td>🐾 <code>:feet:</code></td></tr><tr><td>👄 <code>:lips:</code></td><td>💋 <code>:kiss:</code></td><td>💧 <code>:droplet:</code></td></tr><tr><td>👂 <code>:ear:</code></td><td>👀 <code>:eyes:</code></td><td>👃 <code>:nose:</code></td></tr><tr><td>👅 <code>:tongue:</code></td><td>💌 <code>:love_letter:</code></td><td>👤 <code>:bust_in_silhouette:</code></td></tr><tr><td>👥 <code>:busts_in_silhouette:</code></td><td>💬 <code>:speech_balloon:</code></td><td>💭 <code>:thought_balloon:</code></td></tr></tbody></table><p>Nature</p><table><thead><tr><th>☀️ <code>:sunny:</code></th><th>☔️ <code>:umbrella:</code></th><th>☁️ <code>:cloud:</code></th></tr></thead><tbody><tr><td>❄️ <code>:snowflake:</code></td><td>⛄️ <code>:snowman:</code></td><td>⚡️ <code>:zap:</code></td></tr><tr><td>🌀 <code>:cyclone:</code></td><td>🌁 <code>:foggy:</code></td><td>🌊 <code>:ocean:</code></td></tr><tr><td>🐱 <code>:cat:</code></td><td>🐶 <code>:dog:</code></td><td>🐭 <code>:mouse:</code></td></tr><tr><td>🐹 <code>:hamster:</code></td><td>🐰 <code>:rabbit:</code></td><td>🐺 <code>:wolf:</code></td></tr><tr><td>🐸 <code>:frog:</code></td><td>🐯 <code>:tiger:</code></td><td>🐨 <code>:koala:</code></td></tr><tr><td>🐻 <code>:bear:</code></td><td>🐷 <code>:pig:</code></td><td>🐽 <code>:pig_nose:</code></td></tr><tr><td>🐮 <code>:cow:</code></td><td>🐗 <code>:boar:</code></td><td>🐵 <code>:monkey_face:</code></td></tr><tr><td>🐒 <code>:monkey:</code></td><td>🐴 <code>:horse:</code></td><td>🐎 <code>:racehorse:</code></td></tr><tr><td>🐫 <code>:camel:</code></td><td>🐑 <code>:sheep:</code></td><td>🐘 <code>:elephant:</code></td></tr><tr><td>🐼 <code>:panda_face:</code></td><td>🐍 <code>:snake:</code></td><td>🐦 <code>:bird:</code></td></tr><tr><td>🐤 <code>:baby_chick:</code></td><td>🐥 <code>:hatched_chick:</code></td><td>🐣 <code>:hatching_chick:</code></td></tr><tr><td>🐔 <code>:chicken:</code></td><td>🐧 <code>:penguin:</code></td><td>🐢 <code>:turtle:</code></td></tr><tr><td>🐛 <code>:bug:</code></td><td>🐝 <code>:honeybee:</code></td><td>🐜 <code>:ant:</code></td></tr><tr><td>🐞 <code>:beetle:</code></td><td>🐌 <code>:snail:</code></td><td>🐙 <code>:octopus:</code></td></tr><tr><td>🐠 <code>:tropical_fish:</code></td><td>🐟 <code>:fish:</code></td><td>🐳 <code>:whale:</code></td></tr><tr><td>🐋 <code>:whale2:</code></td><td>🐬 <code>:dolphin:</code></td><td>🐄 <code>:cow2:</code></td></tr><tr><td>🐏 <code>:ram:</code></td><td>🐀 <code>:rat:</code></td><td>🐃 <code>:water_buffalo:</code></td></tr><tr><td>🐅 <code>:tiger2:</code></td><td>🐇 <code>:rabbit2:</code></td><td>🐉 <code>:dragon:</code></td></tr><tr><td>🐐 <code>:goat:</code></td><td>🐓 <code>:rooster:</code></td><td>🐕 <code>:dog2:</code></td></tr><tr><td>🐖 <code>:pig2:</code></td><td>🐁 <code>:mouse2:</code></td><td>🐂 <code>:ox:</code></td></tr><tr><td>🐲 <code>:dragon_face:</code></td><td>🐡 <code>:blowfish:</code></td><td>🐊 <code>:crocodile:</code></td></tr><tr><td>🐪 <code>:dromedary_camel:</code></td><td>🐆 <code>:leopard:</code></td><td>🐈 <code>:cat2:</code></td></tr><tr><td>🐩 <code>:poodle:</code></td><td>🐾 <code>:paw_prints:</code></td><td>💐 <code>:bouquet:</code></td></tr><tr><td>🌸 <code>:cherry_blossom:</code></td><td>🌷 <code>:tulip:</code></td><td>🍀 <code>:four_leaf_clover:</code></td></tr><tr><td>🌹 <code>:rose:</code></td><td>🌻 <code>:sunflower:</code></td><td>🌺 <code>:hibiscus:</code></td></tr><tr><td>🍁 <code>:maple_leaf:</code></td><td>🍃 <code>:leaves:</code></td><td>🍂 <code>:fallen_leaf:</code></td></tr><tr><td>🌿 <code>:herb:</code></td><td>🍄 <code>:mushroom:</code></td><td>🌵 <code>:cactus:</code></td></tr><tr><td>🌴 <code>:palm_tree:</code></td><td>🌲 <code>:evergreen_tree:</code></td><td>🌳 <code>:deciduous_tree:</code></td></tr><tr><td>🌰 <code>:chestnut:</code></td><td>🌱 <code>:seedling:</code></td><td>🌼 <code>:blossom:</code></td></tr><tr><td>🌾 <code>:ear_of_rice:</code></td><td>🐚 <code>:shell:</code></td><td>🌐 <code>:globe_with_meridians:</code></td></tr><tr><td>🌞 <code>:sun_with_face:</code></td><td>🌝 <code>:full_moon_with_face:</code></td><td>🌚 <code>:new_moon_with_face:</code></td></tr><tr><td>🌑 <code>:new_moon:</code></td><td>🌒 <code>:waxing_crescent_moon:</code></td><td>🌓 <code>:first_quarter_moon:</code></td></tr><tr><td>🌔 <code>:waxing_gibbous_moon:</code></td><td>🌕 <code>:full_moon:</code></td><td>🌖 <code>:waning_gibbous_moon:</code></td></tr><tr><td>🌗 <code>:last_quarter_moon:</code></td><td>🌘 <code>:waning_crescent_moon:</code></td><td>🌜 <code>:last_quarter_moon_with_face:</code></td></tr><tr><td>🌛 <code>:first_quarter_moon_with_face:</code></td><td>🌔 <code>:moon:</code></td><td>🌍 <code>:earth_africa:</code></td></tr><tr><td>🌎 <code>:earth_americas:</code></td><td>🌏 <code>:earth_asia:</code></td><td>🌋 <code>:volcano:</code></td></tr><tr><td>🌌 <code>:milky_way:</code></td><td>⛅️ <code>:partly_sunny:</code></td></tr></tbody></table><p>Objects</p><table><thead><tr><th>🎍 <code>:bamboo:</code></th><th>💝 <code>:gift_heart:</code></th><th>🎎 <code>:dolls:</code></th></tr></thead><tbody><tr><td>🎒 <code>:school_satchel:</code></td><td>🎓 <code>:mortar_board:</code></td><td>🎏 <code>:flags:</code></td></tr><tr><td>🎆 <code>:fireworks:</code></td><td>🎇 <code>:sparkler:</code></td><td>🎐 <code>:wind_chime:</code></td></tr><tr><td>🎑 <code>:rice_scene:</code></td><td>🎃 <code>:jack_o_lantern:</code></td><td>👻 <code>:ghost:</code></td></tr><tr><td>🎅 <code>:santa:</code></td><td>🎄 <code>:christmas_tree:</code></td><td>🎁 <code>:gift:</code></td></tr><tr><td>🔔 <code>:bell:</code></td><td>🔕 <code>:no_bell:</code></td><td>🎋 <code>:tanabata_tree:</code></td></tr><tr><td>🎉 <code>:tada:</code></td><td>🎊 <code>:confetti_ball:</code></td><td>🎈 <code>:balloon:</code></td></tr><tr><td>🔮 <code>:crystal_ball:</code></td><td>💿 <code>:cd:</code></td><td>📀 <code>:dvd:</code></td></tr><tr><td>💾 <code>:floppy_disk:</code></td><td>📷 <code>:camera:</code></td><td>📹 <code>:video_camera:</code></td></tr><tr><td>🎥 <code>:movie_camera:</code></td><td>💻 <code>:computer:</code></td><td>📺 <code>:tv:</code></td></tr><tr><td>📱 <code>:iphone:</code></td><td>☎️ <code>:phone:</code></td><td>☎️ <code>:telephone:</code></td></tr><tr><td>📞 <code>:telephone_receiver:</code></td><td>📟 <code>:pager:</code></td><td>📠 <code>:fax:</code></td></tr><tr><td>💽 <code>:minidisc:</code></td><td>📼 <code>:vhs:</code></td><td>🔉 <code>:sound:</code></td></tr><tr><td>🔈 <code>:speaker:</code></td><td>🔇 <code>:mute:</code></td><td>📢 <code>:loudspeaker:</code></td></tr><tr><td>📣 <code>:mega:</code></td><td>⌛️ <code>:hourglass:</code></td><td>⏳ <code>:hourglass_flowing_sand:</code></td></tr><tr><td>⏰ <code>:alarm_clock:</code></td><td>⌚️ <code>:watch:</code></td><td>📻 <code>:radio:</code></td></tr><tr><td>📡 <code>:satellite:</code></td><td>➿ <code>:loop:</code></td><td>🔍 <code>:mag:</code></td></tr><tr><td>🔎 <code>:mag_right:</code></td><td>🔓 <code>:unlock:</code></td><td>🔒 <code>:lock:</code></td></tr><tr><td>🔏 <code>:lock_with_ink_pen:</code></td><td>🔐 <code>:closed_lock_with_key:</code></td><td>🔑 <code>:key:</code></td></tr><tr><td>💡 <code>:bulb:</code></td><td>🔦 <code>:flashlight:</code></td><td>🔆 <code>:high_brightness:</code></td></tr><tr><td>🔅 <code>:low_brightness:</code></td><td>🔌 <code>:electric_plug:</code></td><td>🔋 <code>:battery:</code></td></tr><tr><td>📲 <code>:calling:</code></td><td>✉️ <code>:email:</code></td><td>📫 <code>:mailbox:</code></td></tr><tr><td>📮 <code>:postbox:</code></td><td>🛀 <code>:bath:</code></td><td>🛁 <code>:bathtub:</code></td></tr><tr><td>🚿 <code>:shower:</code></td><td>🚽 <code>:toilet:</code></td><td>🔧 <code>:wrench:</code></td></tr><tr><td>🔩 <code>:nut_and_bolt:</code></td><td>🔨 <code>:hammer:</code></td><td>💺 <code>:seat:</code></td></tr><tr><td>💰 <code>:moneybag:</code></td><td>💴 <code>:yen:</code></td><td>💵 <code>:dollar:</code></td></tr><tr><td>💷 <code>:pound:</code></td><td>💶 <code>:euro:</code></td><td>💳 <code>:credit_card:</code></td></tr><tr><td>💸 <code>:money_with_wings:</code></td><td>📧 <code>:e-mail:</code></td><td>📥 <code>:inbox_tray:</code></td></tr><tr><td>📤 <code>:outbox_tray:</code></td><td>✉️ <code>:envelope:</code></td><td>📨 <code>:incoming_envelope:</code></td></tr><tr><td>📯 <code>:postal_horn:</code></td><td>📪 <code>:mailbox_closed:</code></td><td>📬 <code>:mailbox_with_mail:</code></td></tr><tr><td>📭 <code>:mailbox_with_no_mail:</code></td><td>🚪 <code>:door:</code></td><td>🚬 <code>:smoking:</code></td></tr><tr><td>💣 <code>:bomb:</code></td><td>🔫 <code>:gun:</code></td><td>🔪 <code>:hocho:</code></td></tr><tr><td>💊 <code>:pill:</code></td><td>💉 <code>:syringe:</code></td><td>📄 <code>:page_facing_up:</code></td></tr><tr><td>📃 <code>:page_with_curl:</code></td><td>📑 <code>:bookmark_tabs:</code></td><td>📊 <code>:bar_chart:</code></td></tr><tr><td>📈 <code>:chart_with_upwards_trend:</code></td><td>📉 <code>:chart_with_downwards_trend:</code></td><td>📜 <code>:scroll:</code></td></tr><tr><td>📋 <code>:clipboard:</code></td><td>📆 <code>:calendar:</code></td><td>📅 <code>:date:</code></td></tr><tr><td>📇 <code>:card_index:</code></td><td>📁 <code>:file_folder:</code></td><td>📂 <code>:open_file_folder:</code></td></tr><tr><td>✂️ <code>:scissors:</code></td><td>📌 <code>:pushpin:</code></td><td>📎 <code>:paperclip:</code></td></tr><tr><td>✒️ <code>:black_nib:</code></td><td>✏️ <code>:pencil2:</code></td><td>📏 <code>:straight_ruler:</code></td></tr><tr><td>📐 <code>:triangular_ruler:</code></td><td>📕 <code>:closed_book:</code></td><td>📗 <code>:green_book:</code></td></tr><tr><td>📘 <code>:blue_book:</code></td><td>📙 <code>:orange_book:</code></td><td>📓 <code>:notebook:</code></td></tr><tr><td>📔 <code>:notebook_with_decorative_cover:</code></td><td>📒 <code>:ledger:</code></td><td>📚 <code>:books:</code></td></tr><tr><td>🔖 <code>:bookmark:</code></td><td>📛 <code>:name_badge:</code></td><td>🔬 <code>:microscope:</code></td></tr><tr><td>🔭 <code>:telescope:</code></td><td>📰 <code>:newspaper:</code></td><td>🏈 <code>:football:</code></td></tr><tr><td>🏀 <code>:basketball:</code></td><td>⚽️ <code>:soccer:</code></td><td>⚾️ <code>:baseball:</code></td></tr><tr><td>🎾 <code>:tennis:</code></td><td>🎱 <code>:8ball:</code></td><td>🏉 <code>:rugby_football:</code></td></tr><tr><td>🎳 <code>:bowling:</code></td><td>⛳️ <code>:golf:</code></td><td>🚵 <code>:mountain_bicyclist:</code></td></tr><tr><td>🚴 <code>:bicyclist:</code></td><td>🏇 <code>:horse_racing:</code></td><td>🏂 <code>:snowboarder:</code></td></tr><tr><td>🏊 <code>:swimmer:</code></td><td>🏄 <code>:surfer:</code></td><td>🎿 <code>:ski:</code></td></tr><tr><td>♠️ <code>:spades:</code></td><td>♥️ <code>:hearts:</code></td><td>♣️ <code>:clubs:</code></td></tr><tr><td>♦️ <code>:diamonds:</code></td><td>💎 <code>:gem:</code></td><td>💍 <code>:ring:</code></td></tr><tr><td>🏆 <code>:trophy:</code></td><td>🎼 <code>:musical_score:</code></td><td>🎹 <code>:musical_keyboard:</code></td></tr><tr><td>🎻 <code>:violin:</code></td><td>👾 <code>:space_invader:</code></td><td>🎮 <code>:video_game:</code></td></tr><tr><td>🃏 <code>:black_joker:</code></td><td>🎴 <code>:flower_playing_cards:</code></td><td>🎲 <code>:game_die:</code></td></tr><tr><td>🎯 <code>:dart:</code></td><td>🀄️ <code>:mahjong:</code></td><td>🎬 <code>:clapper:</code></td></tr><tr><td>📝 <code>:memo:</code></td><td>📝 <code>:pencil:</code></td><td>📖 <code>:book:</code></td></tr><tr><td>🎨 <code>:art:</code></td><td>🎤 <code>:microphone:</code></td><td>🎧 <code>:headphones:</code></td></tr><tr><td>🎺 <code>:trumpet:</code></td><td>🎷 <code>:saxophone:</code></td><td>🎸 <code>:guitar:</code></td></tr><tr><td>👞 <code>:shoe:</code></td><td>👡 <code>:sandal:</code></td><td>👠 <code>:high_heel:</code></td></tr><tr><td>💄 <code>:lipstick:</code></td><td>👢 <code>:boot:</code></td><td>👕 <code>:shirt:</code></td></tr><tr><td>👕 <code>:tshirt:</code></td><td>👔 <code>:necktie:</code></td><td>👚 <code>:womans_clothes:</code></td></tr><tr><td>👗 <code>:dress:</code></td><td>🎽 <code>:running_shirt_with_sash:</code></td><td>👖 <code>:jeans:</code></td></tr><tr><td>👘 <code>:kimono:</code></td><td>👙 <code>:bikini:</code></td><td>🎀 <code>:ribbon:</code></td></tr><tr><td>🎩 <code>:tophat:</code></td><td>👑 <code>:crown:</code></td><td>👒 <code>:womans_hat:</code></td></tr><tr><td>👞 <code>:mans_shoe:</code></td><td>🌂 <code>:closed_umbrella:</code></td><td>💼 <code>:briefcase:</code></td></tr><tr><td>👜 <code>:handbag:</code></td><td>👝 <code>:pouch:</code></td><td>👛 <code>:purse:</code></td></tr><tr><td>👓 <code>:eyeglasses:</code></td><td>🎣 <code>:fishing_pole_and_fish:</code></td><td>☕️ <code>:coffee:</code></td></tr><tr><td>🍵 <code>:tea:</code></td><td>🍶 <code>:sake:</code></td><td>🍼 <code>:baby_bottle:</code></td></tr><tr><td>🍺 <code>:beer:</code></td><td>🍻 <code>:beers:</code></td><td>🍸 <code>:cocktail:</code></td></tr><tr><td>🍹 <code>:tropical_drink:</code></td><td>🍷 <code>:wine_glass:</code></td><td>🍴 <code>:fork_and_knife:</code></td></tr><tr><td>🍕 <code>:pizza:</code></td><td>🍔 <code>:hamburger:</code></td><td>🍟 <code>:fries:</code></td></tr><tr><td>🍗 <code>:poultry_leg:</code></td><td>🍖 <code>:meat_on_bone:</code></td><td>🍝 <code>:spaghetti:</code></td></tr><tr><td>🍛 <code>:curry:</code></td><td>🍤 <code>:fried_shrimp:</code></td><td>🍱 <code>:bento:</code></td></tr><tr><td>🍣 <code>:sushi:</code></td><td>🍥 <code>:fish_cake:</code></td><td>🍙 <code>:rice_ball:</code></td></tr><tr><td>🍘 <code>:rice_cracker:</code></td><td>🍚 <code>:rice:</code></td><td>🍜 <code>:ramen:</code></td></tr><tr><td>🍲 <code>:stew:</code></td><td>🍢 <code>:oden:</code></td><td>🍡 <code>:dango:</code></td></tr><tr><td>🥚 <code>:egg:</code></td><td>🍞 <code>:bread:</code></td><td>🍩 <code>:doughnut:</code></td></tr><tr><td>🍮 <code>:custard:</code></td><td>🍦 <code>:icecream:</code></td><td>🍨 <code>:ice_cream:</code></td></tr><tr><td>🍧 <code>:shaved_ice:</code></td><td>🎂 <code>:birthday:</code></td><td>🍰 <code>:cake:</code></td></tr><tr><td>🍪 <code>:cookie:</code></td><td>🍫 <code>:chocolate_bar:</code></td><td>🍬 <code>:candy:</code></td></tr><tr><td>🍭 <code>:lollipop:</code></td><td>🍯 <code>:honey_pot:</code></td><td>🍎 <code>:apple:</code></td></tr><tr><td>🍏 <code>:green_apple:</code></td><td>🍊 <code>:tangerine:</code></td><td>🍋 <code>:lemon:</code></td></tr><tr><td>🍒 <code>:cherries:</code></td><td>🍇 <code>:grapes:</code></td><td>🍉 <code>:watermelon:</code></td></tr><tr><td>🍓 <code>:strawberry:</code></td><td>🍑 <code>:peach:</code></td><td>🍈 <code>:melon:</code></td></tr><tr><td>🍌 <code>:banana:</code></td><td>🍐 <code>:pear:</code></td><td>🍍 <code>:pineapple:</code></td></tr><tr><td>🍠 <code>:sweet_potato:</code></td><td>🍆 <code>:eggplant:</code></td><td>🍅 <code>:tomato:</code></td></tr><tr><td>🌽 <code>:corn:</code></td><td></td></tr></tbody></table><p>Places</p><table><thead><tr><th>🏠 <code>:house:</code></th><th>🏡 <code>:house_with_garden:</code></th><th>🏫 <code>:school:</code></th></tr></thead><tbody><tr><td>🏢 <code>:office:</code></td><td>🏣 <code>:post_office:</code></td><td>🏥 <code>:hospital:</code></td></tr><tr><td>🏦 <code>:bank:</code></td><td>🏪 <code>:convenience_store:</code></td><td>🏩 <code>:love_hotel:</code></td></tr><tr><td>🏨 <code>:hotel:</code></td><td>💒 <code>:wedding:</code></td><td>⛪️ <code>:church:</code></td></tr><tr><td>🏬 <code>:department_store:</code></td><td>🏤 <code>:european_post_office:</code></td><td>🌇 <code>:city_sunrise:</code></td></tr><tr><td>🌆 <code>:city_sunset:</code></td><td>🏯 <code>:japanese_castle:</code></td><td>🏰 <code>:european_castle:</code></td></tr><tr><td>⛺️ <code>:tent:</code></td><td>🏭 <code>:factory:</code></td><td>🗼 <code>:tokyo_tower:</code></td></tr><tr><td>🗾 <code>:japan:</code></td><td>🗻 <code>:mount_fuji:</code></td><td>🌄 <code>:sunrise_over_mountains:</code></td></tr><tr><td>🌅 <code>:sunrise:</code></td><td>🌠 <code>:stars:</code></td><td>🗽 <code>:statue_of_liberty:</code></td></tr><tr><td>🌉 <code>:bridge_at_night:</code></td><td>🎠 <code>:carousel_horse:</code></td><td>🌈 <code>:rainbow:</code></td></tr><tr><td>🎡 <code>:ferris_wheel:</code></td><td>⛲️ <code>:fountain:</code></td><td>🎢 <code>:roller_coaster:</code></td></tr><tr><td>🚢 <code>:ship:</code></td><td>🚤 <code>:speedboat:</code></td><td>⛵️ <code>:boat:</code></td></tr><tr><td>⛵️ <code>:sailboat:</code></td><td>🚣 <code>:rowboat:</code></td><td>⚓️ <code>:anchor:</code></td></tr><tr><td>🚀 <code>:rocket:</code></td><td>✈️ <code>:airplane:</code></td><td>🚁 <code>:helicopter:</code></td></tr><tr><td>🚂 <code>:steam_locomotive:</code></td><td>🚊 <code>:tram:</code></td><td>🚞 <code>:mountain_railway:</code></td></tr><tr><td>🚲 <code>:bike:</code></td><td>🚡 <code>:aerial_tramway:</code></td><td>🚟 <code>:suspension_railway:</code></td></tr><tr><td>🚠 <code>:mountain_cableway:</code></td><td>🚜 <code>:tractor:</code></td><td>🚙 <code>:blue_car:</code></td></tr><tr><td>🚘 <code>:oncoming_automobile:</code></td><td>🚗 <code>:car:</code></td><td>🚗 <code>:red_car:</code></td></tr><tr><td>🚕 <code>:taxi:</code></td><td>🚖 <code>:oncoming_taxi:</code></td><td>🚛 <code>:articulated_lorry:</code></td></tr><tr><td>🚌 <code>:bus:</code></td><td>🚍 <code>:oncoming_bus:</code></td><td>🚨 <code>:rotating_light:</code></td></tr><tr><td>🚓 <code>:police_car:</code></td><td>🚔 <code>:oncoming_police_car:</code></td><td>🚒 <code>:fire_engine:</code></td></tr><tr><td>🚑 <code>:ambulance:</code></td><td>🚐 <code>:minibus:</code></td><td>🚚 <code>:truck:</code></td></tr><tr><td>🚋 <code>:train:</code></td><td>🚉 <code>:station:</code></td><td>🚆 <code>:train2:</code></td></tr><tr><td>🚅 <code>:bullettrain_front:</code></td><td>🚄 <code>:bullettrain_side:</code></td><td>🚈 <code>:light_rail:</code></td></tr><tr><td>🚝 <code>:monorail:</code></td><td>🚃 <code>:railway_car:</code></td><td>🚎 <code>:trolleybus:</code></td></tr><tr><td>🎫 <code>:ticket:</code></td><td>⛽️ <code>:fuelpump:</code></td><td>🚦 <code>:vertical_traffic_light:</code></td></tr><tr><td>🚥 <code>:traffic_light:</code></td><td>⚠️ <code>:warning:</code></td><td>🚧 <code>:construction:</code></td></tr><tr><td>🔰 <code>:beginner:</code></td><td>🏧 <code>:atm:</code></td><td>🎰 <code>:slot_machine:</code></td></tr><tr><td>🚏 <code>:busstop:</code></td><td>💈 <code>:barber:</code></td><td>♨️ <code>:hotsprings:</code></td></tr><tr><td>🏁 <code>:checkered_flag:</code></td><td>🎌 <code>:crossed_flags:</code></td><td>🏮 <code>:izakaya_lantern:</code></td></tr><tr><td>🗿 <code>:moyai:</code></td><td>🎪 <code>:circus_tent:</code></td><td>🎭 <code>:performing_arts:</code></td></tr><tr><td>📍 <code>:round_pushpin:</code></td><td>🚩 <code>:triangular_flag_on_post:</code></td><td>🇯🇵 <code>:jp:</code></td></tr><tr><td>🇰🇷 <code>:kr:</code></td><td>🇨🇳 <code>:cn:</code></td><td>🇺🇸 <code>:us:</code></td></tr><tr><td>🇫🇷 <code>:fr:</code></td><td>🇪🇸 <code>:es:</code></td><td>🇮🇹 <code>:it:</code></td></tr><tr><td>🇷🇺 <code>:ru:</code></td><td>🇬🇧 <code>:gb:</code></td><td>🇬🇧 <code>:uk:</code></td></tr><tr><td>🇩🇪 <code>:de:</code></td><td></td></tr></tbody></table><p>Symbols</p><table><thead><tr><th>1️⃣ <code>:one:</code></th><th>2️⃣ <code>:two:</code></th><th>3️⃣ <code>:three:</code></th></tr></thead><tbody><tr><td>4️⃣ <code>:four:</code></td><td>5️⃣ <code>:five:</code></td><td>6️⃣ <code>:six:</code></td></tr><tr><td>7️⃣ <code>:seven:</code></td><td>8️⃣ <code>:eight:</code></td><td>9️⃣ <code>:nine:</code></td></tr><tr><td>🔟 <code>:keycap_ten:</code></td><td>🔢 <code>:1234:</code></td><td>0️⃣ <code>:zero:</code></td></tr><tr><td>#️⃣ <code>:hash:</code></td><td>🔣 <code>:symbols:</code></td><td>◀️ <code>:arrow_backward:</code></td></tr><tr><td>⬇️ <code>:arrow_down:</code></td><td>▶️ <code>:arrow_forward:</code></td><td>⬅️ <code>:arrow_left:</code></td></tr><tr><td>🔠 <code>:capital_abcd:</code></td><td>🔡 <code>:abcd:</code></td><td>🔤 <code>:abc:</code></td></tr><tr><td>↙️ <code>:arrow_lower_left:</code></td><td>↘️ <code>:arrow_lower_right:</code></td><td>➡️ <code>:arrow_right:</code></td></tr><tr><td>⬆️ <code>:arrow_up:</code></td><td>↖️ <code>:arrow_upper_left:</code></td><td>↗️ <code>:arrow_upper_right:</code></td></tr><tr><td>⏬ <code>:arrow_double_down:</code></td><td>⏫ <code>:arrow_double_up:</code></td><td>🔽 <code>:arrow_down_small:</code></td></tr><tr><td>⤵️ <code>:arrow_heading_down:</code></td><td>⤴️ <code>:arrow_heading_up:</code></td><td>↩️<code>:leftwards_arrow_with_hook:</code></td></tr><tr><td>↪️ <code>:arrow_right_hook:</code></td><td>↔️ <code>:left_right_arrow:</code></td><td>↕️ <code>:arrow_up_down:</code></td></tr><tr><td>🔼 <code>:arrow_up_small:</code></td><td>🔃 <code>:arrows_clockwise:</code></td><td>🔄 <code>:arrows_counterclockwise:</code></td></tr><tr><td>⏪ <code>:rewind:</code></td><td>⏩ <code>:fast_forward:</code></td><td>ℹ️ <code>:information_source:</code></td></tr><tr><td>🆗 <code>:ok:</code></td><td>🔀 <code>:twisted_rightwards_arrows:</code></td><td>🔁 <code>:repeat:</code></td></tr><tr><td>🔂 <code>:repeat_one:</code></td><td>🆕 <code>:new:</code></td><td>🔝 <code>:top:</code></td></tr><tr><td>🆙 <code>:up:</code></td><td>🆒 <code>:cool:</code></td><td>🆓 <code>:free:</code></td></tr><tr><td>🆖 <code>:ng:</code></td><td>🎦 <code>:cinema:</code></td><td>🈁 <code>:koko:</code></td></tr><tr><td>📶 <code>:signal_strength:</code></td><td>🈹 <code>:u5272:</code></td><td>🈴 <code>:u5408:</code></td></tr><tr><td>🈺 <code>:u55b6:</code></td><td>🈯️ <code>:u6307:</code></td><td>🈷️ <code>:u6708:</code></td></tr><tr><td>🈶 <code>:u6709:</code></td><td>🈵 <code>:u6e80:</code></td><td>🈚️ <code>:u7121:</code></td></tr><tr><td>🈸 <code>:u7533:</code></td><td>🈳 <code>:u7a7a:</code></td><td>🈲 <code>:u7981:</code></td></tr><tr><td>🈂️ <code>:sa:</code></td><td>🚻 <code>:restroom:</code></td><td>🚹 <code>:mens:</code></td></tr><tr><td>🚺 <code>:womens:</code></td><td>🚼 <code>:baby_symbol:</code></td><td>🚭 <code>:no_smoking:</code></td></tr><tr><td>🅿️ <code>:parking:</code></td><td>♿️ <code>:wheelchair:</code></td><td>🚇 <code>:metro:</code></td></tr><tr><td>🛄 <code>:baggage_claim:</code></td><td>🉑 <code>:accept:</code></td><td>🚾 <code>:wc:</code></td></tr><tr><td>🚰 <code>:potable_water:</code></td><td>🚮 <code>:put_litter_in_its_place:</code></td><td>㊙️ <code>:secret:</code></td></tr><tr><td>㊗️ <code>:congratulations:</code></td><td>Ⓜ️ <code>:m:</code></td><td>🛂 <code>:passport_control:</code></td></tr><tr><td>🛅 <code>:left_luggage:</code></td><td>🛃 <code>:customs:</code></td><td>🉐 <code>:ideograph_advantage:</code></td></tr><tr><td>🆑 <code>:cl:</code></td><td>🆘 <code>:sos:</code></td><td>🆔 <code>:id:</code></td></tr><tr><td>🚫 <code>:no_entry_sign:</code></td><td>🔞 <code>:underage:</code></td><td>📵 <code>:no_mobile_phones:</code></td></tr><tr><td>🚯 <code>:do_not_litter:</code></td><td>🚱 <code>:non-potable_water:</code></td><td>🚳 <code>:no_bicycles:</code></td></tr><tr><td>🚷 <code>:no_pedestrians:</code></td><td>🚸 <code>:children_crossing:</code></td><td>⛔️ <code>:no_entry:</code></td></tr><tr><td>✳️ <code>:eight_spoked_asterisk:</code></td><td>✴️ <code>:eight_pointed_black_star:</code></td><td>💟 <code>:heart_decoration:</code></td></tr><tr><td>🆚 <code>:vs:</code></td><td>📳 <code>:vibration_mode:</code></td><td>📴 <code>:mobile_phone_off:</code></td></tr><tr><td>💹 <code>:chart:</code></td><td>💱 <code>:currency_exchange:</code></td><td>♈️ <code>:aries:</code></td></tr><tr><td>♉️ <code>:taurus:</code></td><td>♊️ <code>:gemini:</code></td><td>♋️ <code>:cancer:</code></td></tr><tr><td>♌️ <code>:leo:</code></td><td>♍️ <code>:virgo:</code></td><td>♎️ <code>:libra:</code></td></tr><tr><td>♏️ <code>:scorpius:</code></td><td>♐️ <code>:sagittarius:</code></td><td>♑️ <code>:capricorn:</code></td></tr><tr><td>♒️ <code>:aquarius:</code></td><td>♓️ <code>:pisces:</code></td><td>⛎ <code>:ophiuchus:</code></td></tr><tr><td>🔯 <code>:six_pointed_star:</code></td><td>❎<code>:negative_squared_cross_mark:</code></td><td>🅰️ <code>:a:</code></td></tr><tr><td>🅱️ <code>:b:</code></td><td>🆎 <code>:ab:</code></td><td>🅾️ <code>:o2:</code></td></tr><tr><td>💠<code>:diamond_shape_with_a_dot_inside:</code></td><td>♻️ <code>:recycle:</code></td><td>🔚 <code>:end:</code></td></tr><tr><td>🔛 <code>:on:</code></td><td>🔜 <code>:soon:</code></td><td>🕐 <code>:clock1:</code></td></tr><tr><td>🕜 <code>:clock130:</code></td><td>🕙 <code>:clock10:</code></td><td>🕥 <code>:clock1030:</code></td></tr><tr><td>🕚 <code>:clock11:</code></td><td>🕦 <code>:clock1130:</code></td><td>🕛 <code>:clock12:</code></td></tr><tr><td>🕧 <code>:clock1230:</code></td><td>🕑 <code>:clock2:</code></td><td>🕝 <code>:clock230:</code></td></tr><tr><td>🕒 <code>:clock3:</code></td><td>🕞 <code>:clock330:</code></td><td>🕓 <code>:clock4:</code></td></tr><tr><td>🕟 <code>:clock430:</code></td><td>🕔 <code>:clock5:</code></td><td>🕠 <code>:clock530:</code></td></tr><tr><td>🕕 <code>:clock6:</code></td><td>🕡 <code>:clock630:</code></td><td>🕖 <code>:clock7:</code></td></tr><tr><td>🕢 <code>:clock730:</code></td><td>🕗 <code>:clock8:</code></td><td>🕣 <code>:clock830:</code></td></tr><tr><td>🕘 <code>:clock9:</code></td><td>🕤 <code>:clock930:</code></td><td>💲 <code>:heavy_dollar_sign:</code></td></tr><tr><td>©️ <code>:copyright:</code></td><td>®️ <code>:registered:</code></td><td>™️ <code>:tm:</code></td></tr><tr><td>❌ <code>:x:</code></td><td>❗️ <code>:heavy_exclamation_mark:</code></td><td>‼️ <code>:bangbang:</code></td></tr><tr><td>⁉️ <code>:interrobang:</code></td><td>⭕️ <code>:o:</code></td><td>✖️ <code>:heavy_multiplication_x:</code></td></tr><tr><td>➕ <code>:heavy_plus_sign:</code></td><td>➖ <code>:heavy_minus_sign:</code></td><td>➗ <code>:heavy_division_sign:</code></td></tr><tr><td>💮 <code>:white_flower:</code></td><td>💯 <code>:100:</code></td><td>✔️ <code>:heavy_check_mark:</code></td></tr><tr><td>☑️ <code>:ballot_box_with_check:</code></td><td>🔘 <code>:radio_button:</code></td><td>🔗 <code>:link:</code></td></tr><tr><td>➰ <code>:curly_loop:</code></td><td>〰️ <code>:wavy_dash:</code></td><td>〽️ <code>:part_alternation_mark:</code></td></tr><tr><td>🔱 <code>:trident:</code></td><td>:black_square: <code>:black_square:</code></td><td>:white_square: <code>:white_square:</code></td></tr><tr><td>✅ <code>:white_check_mark:</code></td><td>🔲 <code>:black_square_button:</code></td><td>🔳 <code>:white_square_button:</code></td></tr><tr><td>⚫️ <code>:black_circle:</code></td><td>⚪️ <code>:white_circle:</code></td><td>🔴 <code>:red_circle:</code></td></tr><tr><td>🔵 <code>:large_blue_circle:</code></td><td>🔷 <code>:large_blue_diamond:</code></td><td>🔶 <code>:large_orange_diamond:</code></td></tr><tr><td>🔹 <code>:small_blue_diamond:</code></td><td>🔸 <code>:small_orange_diamond:</code></td><td>🔺 <code>:small_red_triangle:</code></td></tr><tr><td>🔻 <code>:small_red_triangle_down:</code></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;People&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;😄 &lt;code&gt;:smile:&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;😆 &lt;code&gt;:laughing:&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;😊 &lt;code&gt;:blush:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😃 &lt;code&gt;:smiley:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;☺️ &lt;code&gt;:relaxed:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😏 &lt;code&gt;:smirk:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😍 &lt;code&gt;:heart_eyes:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😘 &lt;code&gt;:kissing_heart:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😚 &lt;code&gt;:kissing_closed_eyes:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😳 &lt;code&gt;:flushed:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😌 &lt;code&gt;:relieved:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😆 &lt;code&gt;:satisfied:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😁 &lt;code&gt;:grin:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😉 &lt;code&gt;:wink:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😜 &lt;code&gt;:stuck_out_tongue_winking_eye:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😝 &lt;code&gt;:stuck_out_tongue_closed_eyes:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😀 &lt;code&gt;:grinning:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😗 &lt;code&gt;:kissing:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😙 &lt;code&gt;:kissing_smiling_eyes:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😛 &lt;code&gt;:stuck_out_tongue:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😴 &lt;code&gt;:sleeping:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😟 &lt;code&gt;:worried:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😦 &lt;code&gt;:frowning:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😧 &lt;code&gt;:anguished:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😮 &lt;code&gt;:open_mouth:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😬 &lt;code&gt;:grimacing:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😕 &lt;code&gt;:confused:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😯 &lt;code&gt;:hushed:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😑 &lt;code&gt;:expressionless:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😒 &lt;code&gt;:unamused:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😅 &lt;code&gt;:sweat_smile:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😓 &lt;code&gt;:sweat:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😥 &lt;code&gt;:disappointed_relieved:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😩 &lt;code&gt;:weary:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😔 &lt;code&gt;:pensive:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😞 &lt;code&gt;:disappointed:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😖 &lt;code&gt;:confounded:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😨 &lt;code&gt;:fearful:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😰 &lt;code&gt;:cold_sweat:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😣 &lt;code&gt;:persevere:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😢 &lt;code&gt;:cry:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😭 &lt;code&gt;:sob:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😂 &lt;code&gt;:joy:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😲 &lt;code&gt;:astonished:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😱 &lt;code&gt;:scream:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;😫 &lt;code&gt;:tired_face:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😠 &lt;code&gt;:angry:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😡 &lt;code&gt;:rage:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😤 &lt;code&gt;:triumph:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😪 &lt;code&gt;:sleepy:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😋 &lt;code&gt;:yum:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😷 &lt;code&gt;:mask:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;😎 &lt;code&gt;:sunglasses:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;😵 &lt;code&gt;:dizzy_face:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;👿 &lt;code&gt;:imp:&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="Typora" scheme="http://blog.todaycoder.cn/tags/Typora/"/>
    
      <category term="Emoji" scheme="http://blog.todaycoder.cn/tags/Emoji/"/>
    
      <category term="markdown" scheme="http://blog.todaycoder.cn/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>《大话设计模式》读书笔记（一）</title>
    <link href="http://blog.todaycoder.cn/2018/11/18/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.todaycoder.cn/2018/11/18/《大话设计模式》读书笔记（一）/</id>
    <published>2018-11-18T04:50:14.000Z</published>
    <updated>2018-11-20T15:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、心得"><a href="#一、心得" class="headerlink" title="一、心得"></a>一、心得</h3><p>​    今天的读书笔记是记录《大话设计模式》中附录部分从<strong>（A2-A5）</strong>的内容，为了能让自己更好的去阅读Laravel的源码，从书堆中捡起了大话设计模式这本书，看的时候发现自己把这些面向对象中最基本的概念都还给老师了:joy:，看的时候觉得自己还是学到了一些东西，最深的感悟就是一个知识点不同的阶段去看收获完全不同。</p><p>​    在看书的过程中也会去搜索下相关的知识点，学习一些书本上可能漏掉的相关知识点，话不多说，上干货。</p><a id="more"></a><h3 id="二、具体概念以及代码"><a href="#二、具体概念以及代码" class="headerlink" title="二、具体概念以及代码"></a>二、具体概念以及代码</h3><h4 id="A2：类与实例"><a href="#A2：类与实例" class="headerlink" title="A2：类与实例"></a>A2：类与实例</h4><p>​    先问问大家，对象是什么？类是什么？</p><p>​    平时大家可能经常声明一个类和对象，但是对于他的具体定义有很多人可能说不上来。一切事物皆为对象，对象就是你所有能看到的、听到的、触摸到的以及闻到的等…。准确地说，<strong>对象是一个自包含的实体，用一组可识别的特征和行为来标识</strong>。面向对象编程，英文叫<strong>Object-Oriented Programming</strong>，其实就是针对对象的编程。接下来我们将以一个运动会的例子来给大家讲解下以上的概念。</p><p>​    首先实现一个功能，输出“让猫叫”，这个非常简单。</p><p>​    <code>printf(&quot;喵&quot;);</code></p><p>​    嗯，这个功能是实现了，如果我们需要小猫多“喵”几次怎么办？写个函数不就行了么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catShout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"喵"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    很好，现在的问题是，万一别的地方也要用怎怎么办？</p><p>​    可以声明public方法呀，嗯，是可以。那函数放在哪里呢？你觉得放在这个地方好么？这就好比，居委会的电视机放在你家，而别人家都没有，于是街坊邻居都要来你家看电视，你觉得这样好么？电视机不应该放在居委会，大家要看电视就去居委会么？</p><p>​    所以说，这“猫叫”的函数应该放在一个更合适的地方，这就是”类“。<strong>类就是拥有相同的属性和功能的对象的集合</strong>，我们来看代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"喵"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    那怎么使用这个类呢？我们只要实例化这个类就可以了，那怎么实例化这个类呢？<strong>实例</strong>就是一个真实的对象，比如我们都是人，而你我都是“人”类的实例了，<strong>实例化就是创建对象的过程，使用new关键字来创建。</strong>下面就是实例化的代码。实例化之后的cat就拥有了Cat所有的成员和方法。</p><p>​    <code>Cat cat = new Cat();</code></p><h4 id="A3：构造方法"><a href="#A3：构造方法" class="headerlink" title="A3：构造方法"></a>A3：构造方法</h4><p>​    下面我们希望出生的小猫应该有个自己的名字，比如叫猫咪，当小猫叫的时候最好能说：“我的名字叫猫咪，喵”，此时就需要考虑构造方法。</p><p>​    构造方法？这是做什么的呢？</p><p>​    “<strong>构造方法又叫构造函数，其实就是对类的初始化。构造方法与类同名，无返回值，也不需要void，在new的时候调用</strong>”。</p><p>​    在<code>Cat act = new Cat();</code>的时候new后面的Cat()其实就是构造方法，不对呀，我们没写过这个构造方法呀。嗯，实际情况就是<strong>所有的类都有构造方法，如果你不声明，则系统就会默认生成空的构造方法，若你有定义的构造方法，则默认的构造方法会失效</strong>，下面我们就来实现一个拥有名字小猫“喵”的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我的名字叫"</span> + name + <span class="string">" 喵"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    想要调用该方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat(<span class="string">"猫咪"</span>);</span><br><span class="line">cat-&gt;Shout();</span><br></pre></td></tr></table></figure><p>​    这样我们就实现了“拥有名字的小猫叫喵”的功能了，简单吧。:happy:</p><h4 id="A4：重载"><a href="#A4：重载" class="headerlink" title="A4：重载"></a>A4：重载</h4><p>​    如果我们还没有给小猫取好名字怎么办呢？难道这个实例就不能创建了么？嗯，有些父母在孩子刚生下来的时候确实没有给小孩子取好名字，如果现在直接<code>Cat cat = new Cat();</code>就会报错，原因就是必须给小猫取名字，如果真的要还没想好取什么名字的话可以用<strong>重载</strong>来解决这个问题。</p><p>​    “<strong>方法的重载提供了创建同名的多个方法的能力，但是这些方法需要使用不同的参数</strong>”，并不是只有构造函数才可以重载，普通的方法也是可以重载的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"无名"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我的名字叫"</span> + name + <span class="string">" 喵"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这样的话<code>Cat cat = new Cat();</code>就不会报错了。<strong>方法重载时，两个方法名必须完全相同，但参数类型或者个数必须要有所不同</strong>。那函数重载的好处是什么呢？我想应该是方法的重载可以在不改变原来方法的基础上，新增功能。方法的重载确实提高了函数的可扩展性，如果我们还需要区分猫的姓和名还可以再重载一个<code>public Cat(string firstName, string lastName);</code></p><h4 id="A5：属性与修饰符"><a href="#A5：属性与修饰符" class="headerlink" title="A5：属性与修饰符"></a>A5：属性与修饰符</h4><p>​    <strong>属性是一个方法或一对方法，但在调用它的代码来看，它是一个字段，也就是说属性适合于以字段的方法使用调用的场合。</strong>字段是存储类满足其设计所需要的数据，比如说我们上面提到的<code>private string name=&quot;&quot;;</code>，name就是一个字段，那么修饰符又是指什么呢？</p><p>​    修饰符表示的是对类成员权限的声明，例如我们上面提到的public、private以及protected都是修饰符。public表示它所修饰的类成员可以允许其他任何类来访问，俗称公有类。而private表示只允许同一类中的成员访问，其他类包括它的子类都无法访问，俗称私有类。如果类中的成员没有加修饰符，则被认为是private的。protected后面我们会讲到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ShoutNum = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShoutNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ShoutNum = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getShoutNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ShoutNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    一般我们会把类的成员变量设置为private，想要操作类的成员变量就可以自己写一些get和set方法就好了，那我们为什么要这样做呢？这就好比建房子，我们都不希望房子是全透明的，那样你在家里做的所有事情都会被被人看到，这样就毫无隐私可言。通常我们的房子是有门有窗的，门窗就好比oublic方法，房子里的东西都是private的。这样房子就比较好控制，只要控制好门窗就比较安全了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、心得&quot;&gt;&lt;a href=&quot;#一、心得&quot; class=&quot;headerlink&quot; title=&quot;一、心得&quot;&gt;&lt;/a&gt;一、心得&lt;/h3&gt;&lt;p&gt;​    今天的读书笔记是记录《大话设计模式》中附录部分从&lt;strong&gt;（A2-A5）&lt;/strong&gt;的内容，为了能让自己更好的去阅读Laravel的源码，从书堆中捡起了大话设计模式这本书，看的时候发现自己把这些面向对象中最基本的概念都还给老师了:joy:，看的时候觉得自己还是学到了一些东西，最深的感悟就是一个知识点不同的阶段去看收获完全不同。&lt;/p&gt;
&lt;p&gt;​    在看书的过程中也会去搜索下相关的知识点，学习一些书本上可能漏掉的相关知识点，话不多说，上干货。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design Pattern" scheme="http://blog.todaycoder.cn/tags/Design-Pattern/"/>
    
      <category term="Class and Instantiation" scheme="http://blog.todaycoder.cn/tags/Class-and-Instantiation/"/>
    
  </entry>
  
</feed>
